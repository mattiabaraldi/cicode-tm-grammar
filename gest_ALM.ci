//======================================================================
//  OBJ:       Management and configuration of alarms 
//
//  FILE:      Gest_ALM.ci
//  DATE:      00/09/2002
//  AUTORE:    Negri-Formenti-Ardizzoni-Veratti-Malaguti
//  VERSION:   1.70
//
//  REVISED:
//
//======================================================================
INT	 bmDspAlmGenieShow[lbAlmActGenieR][lbAlmActGenieC]; !Proprietà di viusualizzazione di un elto della pag. allarmi attivi
INT	 bmDspAlmGenieDis[lbAlmActGenieR][lbAlmActGenieC]; !Proprietà di viusualizzazione di un elto della pag. allarmi attivi
INT	 imDspAlmGenieColor[lbAlmActGenieR][lbAlmActGenieC]; !Codice colore da dare ad una singola colonna: vedi proprietà fill->array sul genie
INT	 hmDspAlmGenie2AdvAlmNumRec[lbAlmActGenieR]; !Determinare a quale RecNo corrisponde, datoil genie di pagina
INT	 hmAdvAlmNumRecTag[lbNumAdvAlmRec]; !dato l'n-esimo RecNo, determinare quale cod BFG corrisponde
GLOBAL
INT	 bgDCUInMODBUS; !True la DCU sta andando col MODBUS
INT	 imIndexDiv32[1024];
!INT	 imPLCAlmMsgDefPos[lbPLCMsgAlmNumWord]; !posizione della n_esima definizione per allarmi PLC
INT	 hmQueAlm = -1; !Puntatore a coda x tooltip
GLOBAL
INT	 hgQueAlmSel = -1; !Puntatore a coda x selezione digalm
INT	 imIndexMod32[1024];
INT	 ciMaxAlarm = lbNumAlmTot; !Max. # di allarmi gestibili
INT	 bmAdvAlmOn[lbNumAdvAlmRec];
INT	 imAdvAlmTagRec[lbNumAlmTotPareto]; !dato il codice dell'allarme BFG, ritorna il # di record a cui punta
INT	 imAdvAlmPriv[lbNumAlmTotPareto]; !privilegio da lista allarmi associato al codice BFG
INT	 imAdvAlmRecPriv[lbNumAlmTotPareto]; !privilegio da lista allarmi associato al record advalm
!GLOBAL
!INT	 bgAlmFlagEnable[1024];
!allarmi di comunicazione
INT	 bmCommAlm[lbNumAlmTotPareto]; !il determinato allarme è un allarme di comunicazione che può essere tirato su da HMI
INT	 bmCommAlmFail[lbNumAlmTotPareto]; !stato dell'allarme di comunicazione
INT	 hmHMIVital[lbNumVitalTot]; !puntatore al # di allarme di una determinata vitalità
GLOBAL
INT	 hgHMIVitalAlmRecord[lbNumVitalTot]; !puntatore al Record adv alm
INT	 hmHMIVitalAlmMsg[lbNumVitalTot]; !puntatore al codice di sottomessaggio # di allarme di una determinata vitalità
GLOBAL
STRING sgHMIVitalNameDisp[lbNumVitalTot]; !nome della tag di interscambio per la vitalità
GLOBAL
STRING sgHMIVitalTag[lbNumVitalTot]; !nome della tag di interscambio per la vitalità
GLOBAL
STRING sgHMIVitalOutTag[lbNumVitalTot]; !nome della tag di interscambio per la vitalità in uscita
GLOBAL
INT	 bgHMIVitalSck[lbNumVitalTot]; !boolean di vitalità se essa proviene da socket
GLOBAL
INT	 bgStopOnTaskContOn[lbNumVitalTot]; !indica se la scansione della vitalità deve essere interrotta durante l'invio ricetta
!struttura dati delle scritte su template
INT	 imScrTemplPosX[lbNumBoxScrTemplate]; !coordinate per il plotdraw
INT	 imScrTemplPosY[lbNumBoxScrTemplate];
INT	 imScrTemplPosX2[lbNumBoxScrTemplate];
INT	 imScrTemplPosY2[lbNumBoxScrTemplate];
INT	 imAltBox[lbNumBoxScrTemplate];
INT	 imLarghBox[lbNumBoxScrTemplate];
STRING smScrSuTemplInt[lbNumBoxScrTemplate]; !Intestazione del box
INT	 imScrSuTemplCol[lbNumBoxScrTemplate][256]; ![x] id di scritta [y] stato corrispondente (colore)
INT	 imScrTemplSt[lbNumBoxScrTemplate]; !stato scritto da qualcuno per poi burdigare le scritte
INT	 hmScrTemplFont[lbNumBoxScrTemplate][256]; !Font da piazzare
INT	 imPosOffsetPosX[lbNumBoxScrTemplate]; !offset di tracciamento in caso del 1024*768
INT	 imScrTepmlBoxType[lbNumBoxScrTemplate]; !0 box con intestazione, 1 box piccoli per allarmi
INT	 bmStsAlm[4]; !Stato allarme per categoria
INT	 ciMaxAlarmBackUp = lbNumAlmTot; !BackUp per ciMaxAlarm
GLOBAL
INT	 ciMaxPLCAlarms = lbNumAlmPLC; !Max # di allarmi provenienti da PLC
INT	 imCategoriaAdvAlm[lbNumAlmTotPareto]; !Categoria di ogni allarme di tipo advanced
INT	 hmAdvAlmBFGCodeTag[lbNumAlmTotPareto]; !dato il cod BFG dell'allarme, determinare quale record di adv alm corrisponde
INT	 hmAdvAlmBFGCodeTagMsgQue[lbNumMsgBank]; !puntatore alla coda con i vari elementi l'elemento stringa è il codice numerico mentre l'intero è il record dbf bella combinazione
INT	 imAdvAlmBFGCodeTagRootVar[lbNumAlmTotPareto]; !true: l'allarme possiede dei root var
INT	 bmAdvAlmOnPrec[lbNumAlmTotPareto]; !flag attivazione ciclo precedente advanced alarms: la posizione è il record 0 degli adv alm
INT	 bmStsAlmFlag[4]; !Flag per aggiornamento Stato Allarmi
INT	 bmStsAlmFlagPrec[4]; !Flag per aggiornamento Stato Allarmi stato precedente
INT	 bmPLCHMIBancoFeedBack[32]; !Banco bit
INT	 bmPLCHMICommandFeedBack[32]; !Banco bit
INT	 imTestBFGAlmSourceType[lbNumAlmTotPareto]; !dato il # di alm BFG, risale se è socket o meno
GLOBAL
INT	 hgDigAlmDBF = -1; !Puntatore DB allarmi digitali DIGALM.DBF
!GLOBAL
!INT	 igStatoMac; !copia dello stato macchina da PLC
GLOBAL
INT	 igStatoMac = -1; !copia dello stato macchina da PLC -1 stato di init HMI
!Lookup table dei 2^n per i 32 bit in HEX
!Lookup table locale di velocizzazione scansione                       
INT	 imExp2Bit[32] = 0x00000001,0x00000002,0x00000004,0x00000008,
                       0x00000010,0x00000020,0x00000040,0x00000080,
                       0x00000100,0x00000200,0x00000400,0x00000800,
                       0x00001000,0x00002000,0x00004000,0x00008000,
                       0x00010000,0x00020000,0x00040000,0x00080000,
                       0x00100000,0x00200000,0x00400000,0x00800000,
                       0x01000000,0x02000000,0x04000000,0x08000000,
                       0x10000000,0x20000000,0x40000000,0x80000000;

GLOBAL
STRING sgAttDisat[2] = "@(DISATT.)",
                       "@(ATTIVO)";
!Gestione della messaggistica ausiliaria allarmi provenienti dal PLC
STRING smPLCAlmDescrMsg[20][20]; !array messaggi descrizione allarmi da PLC
GLOBAL
STRING sgNomePaginaAttiva; !nome della pagina attiva
INT	 bmMachStNot3; !True igStatomac <> 3
!GLOBAL
!INT	 bgRicNonDef[lbNumProcessi];
INT	 imContTimeoutBlkBtn; !contatore di sblocco di emergenza tasti (timeout attorno al minuto)
INT	 imNumAdvAlm;
!Generalizzazione allarmi su ADVANCED ALARMS
INT	 imAdvAlmSource[lbNumAdvAlmRec]; !per ogni record di advAlm, restituisce la sorgente a cui deve essere associato (PLC,RTsocket...)
INT	 imAdvAlmSourceOffset[lbNumSorgentiAlm]; !indica dove inizia l'area di igCopiaAlm (long allarmi) relativa alla sorgente da scandire
INT	 imAdvAlmSourceMsgOffset[lbNumSorgentiAlm]; !indica dove inizia l'area di igCopiaMsgId (multimessaggi) relativa alla sorgente da scandire
INT	 imAdvAlmBank[lbNumAdvAlmRec]; !per ogni record di advAlm, restituisce il banco di apparteneneza relativo alla propria sorgente allarmi
INT	 imAdvAlmBit[lbNumAdvAlmRec]; !per ogni record di advAlm, restituisce il bit da consultare per lo stato di attivazione dell'allarme
INT	 imAdvAlmMsgBank[lbNumAdvAlmRec]; !per ogni record di advAlm, restituisce il banco di apparteneneza dal sottomessaggio relativo alla propria sorgente allarmi
INT	 imAdvAlmMsgVal[lbNumAdvAlmRec]; !per ogni record di advAlm, restituisce il valore del sottomessaggio relativo
INT	 imCopiaAdvAlmPos[lbNumAdvAlmRec]; !Posizione di quel determinato allarme nei buffer di copia
INT	 imCopiaAdvAlmMsgPos[lbNumAdvAlmRec]; !Posizione di quel determinato allarme nei buffer di copia sottomessaggi
INT	 imAdvAlmMsgHeadNumber[lbNumAdvAlmRec];
INT	 imCopiaAdvAlm[lbNumAdvAlmRec]; !restituisce il valore del long indicante il valore degli allarmi di un banco
GLOBAL
INT	 igCopiaAdvAlmMsg[lbNumAdvAlmRec]; !restituisce il valore del sottomessaggio di un banco
GLOBAL
INT	 igCopiaAdvAlmMsgH[lbNumAdvAlmRec]; !restituisce il valore del sottomessaggio di un banco - altri 32 bit per parte alta pacchetto 14
INT	 bmFAckAdvAlm[lbNumAdvAlmRec]; !il record in questione DEVE essere a riconoscimento doppio.

!"parametri" sorgente allarmi
STRING smAlmSourceName[lbNumSorgentiAlm]; !restituisce il nome della sorgente allarmi
INT	 imAlmSourceNumBank[lbNumSorgentiAlm]; !indica da quanti banchi è composta la sorgente
INT	 imAlmSourceNumMsgBank[lbNumSorgentiAlm]; !indica da quanti banchi multimessaggio è composta la sorgente
INT	 imAlmSourceMinAlm[lbNumSorgentiAlm]; !indica da quale allarme parte la sorgente ex.plc->0
INT	 imAlmSourceMaxAlm[lbNumSorgentiAlm]; !indica a quale allarme finisce la sorgente ex.plc->223
INT	 imAlmSourceId[lbNumSorgentiAlm]; !indica a quale id di sorgente è collegato
INT	 hmIDNumDef[lbNumSorgentiAlm];
STRING smAlmSourceRef[lbNumSorgentiAlm]; !indica quale è l'indirizzo di riferimento per le sorgenti con tag
STRING smAlmSourceMsgRef[lbNumSorgentiAlm]; !indica quale è l'indirizzo di riferimento messaggi per le sorgenti con tag
INT	 imAlmSourceType[lbNumSorgentiAlm]; !indica il tipo di sorgente allarme 0->tag , 1->socket
INT	 imNumAlmSource = 0; !indica quante sorgenti allarmi sono presenti
!GLOBAL
!INT	 hgAlmSelRecNo[lbNumAdvAlmRec]; !dato l'n_esima voce di selezione, memorizza l'offset del record di "_ADVALM.DBF"
INT	 bmLDWINToggleVal[lbNumToggleFn]; !valore in commutazione della funzione toggle ennesima
GLOBAL
STRING hsAdvAlmMsg;
GLOBAL
INT	 igNumAnniSQLCircolarita = 1; !anni di circolarità del sistema di report su SQL
INT	 hmANGrScritteIco = -1; !scritte area iconografica
INT	 imNumScrTempl; !# di box scritte
INT	 imColGrigio; !colore grigio de'bordi
INT	 imLDStatoMac;
STRING smCommMatr;
STRING smLARev;
GLOBAL
STRING sgLDWINData; !Data di sistema di LDWIN
!GLOBAL
!STRING sgLDWINDataEstesa; !Data di sistema di LDWINcon anno a 4 cifre
!GLOBAL
STRING smLDWINOraMin; !Data di sistema di LDWIN nel formato HH:MM
!GLOBAL
STRING smLDWINOra; !Ora di sistema di LDWIN
!GLOBAL
STRING smLDWINMin; !Minuti di sistema di LDWIN
STRING smDspDataLDWIN; !Data e ora di LDWIN
!GLOBAL
STRING smLDWINOraMinSec; !Data di sistema di LDWIN nel formato HH:MM:SS
STRING smTempoDCU; !hh:mm:ss del sistema DCU x il syncro
INT	 hmLastAlarmFmt = -1; !puntatore al formato per gli allarmi in pagina proc
INT	 imnLastAlmDspMode; !allarmi in pagina proc: tipo di visualzizzazione
INT	 imContLamp[4]; !contatori lampeggio
GLOBAL 
INT	 igVitContSocket[lbNumSocket];
!GLOBAL
STRING smLDWINDataPrec; !Data di LDWIN al ciclo precedente quando scatta la mezzanotte
!GLOBAL
!STRING sgLDWINSec;
INT	 bmStatoMac1OR5; !True quando igStatoMac 0 1 oppure = 5
STRING smPathCsv;
INT	 bmAggiornaDataLDWIN = True; !flag per forzare l'aggiornamento delle variabili di servizio Data di LDWIN
STRING smAlmSourceType[3] = "Tag", "Socket", "Automatico";
STRING smBool2Str[2] = "0", "1";
INT	 imDCUBatchTimePrec; !tempo di Batch al precedente batch (quando si deve riprendere il conteggio)
INT	 bmMacchinaInMoto; !necessaria per informazioni al task mailbox
INT	 imExtModeIco;
INT	 bmPLCVIAlm[105]; !ricordarsi di portarlo a 4!!!!
INT	 imNumVISt; !Unità VI in scansione per area iconografica
INT	 imContVIStScan; !contatore per lo swap ogni sec circa delle icone di stato
GLOBAL
INT	 bgCustomLikeGMOn;
INT	 imAlmDspPage; !0: Allarmi attivi, 1: sommario, 2: allarmi Hw
STRING smAlmDspPageName[3] = "@(ALLARMI ATTIVI)", "@(SOMMARIO ALLARMI)", "@(ALLARMI SISTEMA)";
STRING smAlmDspPageManName[3] = "AlmAct", "AlmSumm", "AlmHw";
INT	 bmAutoAckOn; !MGS 18321 2
INT	 imAlmNatDummyNum = 0;
INT	 bmAlmIsAck[lbNumAlmTotPareto]; !dato il cod BFG dell'allarme, determinare lo stato di ack dell'allarme [0:noAck 1:ack]
INT	 bmAlmIsAckTemp[lbNumAlmTotPareto]; !struttura su cui lavorare in modo da non sovrascrivere i dati di elaborazione
!GLOBAL
INT	 imAckAdvAlm[lbNumAdvAlmRec]; !restituisce il valore del long indicante lo stato degli allarmi di un banco [il bit di ack ha le stesse coordinate di quello di attivazione 0:noAck 1:ack]
!INT	 hmQueTaskAlmSourceImport;
INT	 hmQueTaskAlmSourceImport = -1;
INT	 hmQueTaskAlmWrite = -1; !handle alla coda contenente le informazioni da scrivere su SQL N.B. ogni elemento è un puntatore alla coda contenente le stringhe a blocchi da 127 caratteri del singolo record
INT	 bmAlmServerAlmIsOn[lbNumAdvAlmRec]; !stato di attivazione degli allarmi sul alarm server
INT	 bmAlmServerAlmIsOnPrec[lbNumAdvAlmRec];
INT	 bmAlmServerAlmIsAck[lbNumAdvAlmRec]; !stato di ack del record advanced alarm
INT	 bmAlmServerAlmIsAckPrec[lbNumAdvAlmRec]; !stato di ack della scansione precedente
INT	 bmAlmServerAlmIsFAck[lbNumAdvAlmRec]; !stato di FACK del record advanced alarm
INT	 bmAlmServerAlmIsFAckPrec[lbNumAdvAlmRec]; !stato di FACK della scansione precedente
GLOBAL 
INT	 hgQueCopiaAlmTask = -1; !contiene gli id dei task dei copia allarmi e stato ack delle sergenti -> serve per inibire la copia allarmi durante i test utilizzando TestStopCopiaAlm e TestStartCopiaAlm -> in questo modo si possono attivare gli advalm utilizzando SetAdvAlmFromAlmRecNo(recNo,bVal)
!STRING smAckStatus; !Termine di stato di ACK che potrebbe essere tradotto. 21206_75
!STRING smUnackStatus; !Termine di stato di UNACK che potrebbe essere tradotto. 21206_75
GLOBAL
INT	 bgLateralBelt; !20251_2
INT	 bmAlmManageSuspend = False; !Sospendi il task AlmManage 21206_75
STRING smAlmAckComment = "NA"; !21206_41
GLOBAL
STRING sgAlmDspPageName = "AlmDspOld";
INT	 hmAlmDsp_NextBtn[3] = 257, 262, 266;
INT	 hmAlmDsp_NextBtnArg[3] = 27, 259, 296;
INT	 hmAlmDsp_PrevBtn[3] = 256, 261, 265;
INT	 hmAlmDsp_PrevBtnArg[3] = 27, 259, 296;
GLOBAL
INT	 bgPrintPdfWithWkHtmlToPdf;
GLOBAL
INT	 bgDeleteCitectAlms = True; !cancellazione dei file di servizio per evitare allarmi fantasmi
INT	 bmCitectAlmsDelOverride = False;

//#I
//Gestione Allarmi
//IN: bRestart: Grazie Citect 7.5: al cambio lingua, si smaiala il sistema allarmi e quindi devo riavvià... E po e po...
//#F
FUNCTION AlmManage(INT bRestart = False)
	INT	 iDummy = 0;
	INT	 iDummyDEBUG;
	INT	 iStatoPromptWarmup; !stato automa gestione prompt di warmup
	INT	 iContDCUSynchro; !conteggi ciclo task per la sincronizzazione della DCU
	INT	 iDeltaTTaskAlm; !# di millisecondi di uno slice di task
	INT	 iTempoTaskAlm;
	INT	 iCont;
	INT	 iNumAlm;
	INT	 iPrecStatoMac = -1;
	INT	 bDisAllBtnFn; !True: disabilita sia i bottoni di man che auto
	REAL	 rNumSecWarmup;
	STRING sDummy = "";
	STRING sPercLDWINDATINI = sgPercLDWINDATINI;
	INT	 bEnable;
	INT	 bAlmOn;
	INT	 iAdvAlmSrc;
	INT	 iAdvAlmMsgBnk;
	INT	 iAdvAlmMsgVl;
	INT	 iAdvBit = 0;
	INT	 iDummy2 = 0;
	INT	 bBitVal;
	INT	 bErrHw;
	INT	 bErrHwPrec = -1;
	INT	 bPLCLdOnOff;
	INT	 bPLCLdOnOffPrec = -1;
	INT	 iDCUTimeStampDecodeMode = -1; !Modo di decodifica del timestamp -1 disattivo, 0 da stringa OPC, 1 da interi MODBUS
	INT	 bCopyToDCU2; !valore precalcolato per trasmissione dati verso dcu, seconda pos all'interno del task
	INT	 bAlmOnComm;
	INT	 bLDOn = INIParamOn(lbCfgLDEnable); !registro per velocizzare scansione
	INT	 bByPassOn = INIParamOn(lbCfgMainLDByPass); !registro per velocizzare scansione
	INT	 bVIOn = INIParamOn(lbCfgVITattileEn); !registro per velocizzare scansione
	INT	 bWarmupOn = WarmupAttivo(); !registro per velocizzare scansione
	INT	 bSPCOn = INIParamOn(lbCfgMySPCOn); !registro per velocizzare scansione
	INT	 bRTControlTag = bgRTControlTag; !registro per velocizzare scansione
	INT	 bMISOn = INIParamOn(lbCfgMyMISSupport); !registro per velocizzare scansione
	INT	 iStatoMac;
	INT	 bBatchDCUDaEvento;
	INT	 bMES_MachineStateOn;
	INT	 iLDWINCustomerID = igLDWINCustomerID;
	INT	 iNumAdvAlm = imNumAdvAlm - 1;
	INT	 iTimeCurrent;
	INT	 iTimeSec;
	INT	 iLDWINNumLPro = igLDWINNumLPro;
	INT	 bPPTOn;
	INT	 bCfgConveyorEnable = INIParamOn(lbCfgConveyorEnable);
	INT	 iCfgConveyorType;
	INT	 bSoloVI;
	INT	 bNOTStatoMac1OR5;
	INT	 iExternalDeviceState;
	INT	 iExternalDeviceStatePrev = -1;
	INT	 bCfgExternalDevice = INIParamOn(lbCfgExtConveyor);
	INT	 bCFR21On = INIParamOn(lbCfgMyCFR21On);
	INT	 bScrewFeeder = INIParamOn(lbCfgScrewFeeder);
	INT	 bCANSTOPScrewOnTemplate = INIParamOn(lbCfgMyCANSTOPScrewOnTemplate);
	INT	 bCANSTOPBtn = INIParamOn(lbCfgCANSTOPBtn);
	INT	 bLuceOn = INIParamOn(lbCfgCarouselLights);
	INT	 bInterLock = INIParamOn(lbCfgInterlockedDoors);
	INT	 bMISManualChangeHMIMode = INIParamOn(lbCfgMyMISManualChangeHMIMode);
	INT	 bMISManualSendRecipe = INIParamOn(lbCfgMyMISManualSendRecipe);
	INT	 bEnable1;
	INT	 iValidazione; !Copia locale per velocizzazione/sicurezza
	INT	 iCitectAlmRec;
	STRING sAlmTag;
	INT	 hDev;
	INT	 iErr;
	INT	 bEnTask96Resume;
	STRING sCont;
	INT	 bManualBatchManagement = INIParamOn(lbCfgMyMISManualBatchManagement);
	INT	 iCont2;
	STRING sCont2;
	INT	 hQue;
	INT	 hQue2;
	INT	 iValQue;
	STRING sValQue;
	STRING sValQue2;
	INT	 iValQue2;
	INT	 iCol0;
	STRING sVal;
	STRING sPercLDWINAlmInfo = sgPercLDWINAlmInfo;
	STRING sDummy2;
	STRING sFileLDWININI = sgFileLDWININI;
	STRING sAckTime;
	STRING sOnTime;
	STRING sOffTime;
	INT	 bLateralBelt; !20251
	INT	 bEnQue2;
	INT	 iLen;
	INT	 bAckPrec; !registro x velocizzare
	INT	 bCitect72 = False; !registro x velocizzare [20/01/22 - non si sviluppa più il ramo principale in 720 quindi si forza a false]
	INT	 bFACK = INIParamOn(lbCfgMyCriticalAlmDoubleAck);
	INT	 bWrite = False;
	INT	 bSetFAck;
	STRING sAckComment; !21206_41
	INT	 iTipoMacchina = LDWININIGetIntValMem(lbCfgTipoMacchina);
	INT	 bNew = True;
	INT    bMachStateOnIconographicArea = GetLDWININI2Int("LDWIN", "MachineStateOnIconographicArea", "1", sFileLDWININI); !TODO: forse col tempo diverrà obsoleta la chiave: non cancellare i rami con True 09/10/23 deciso di renderla sempre attiva
	INT	 iOldMinute = -1;
	
	LDWINDefTask(13, "AlmManage", False);
	bmCitectAlmsDelOverride = False;
	!ErrLog("Start AlmManage " + IntToStr(bRestart) + " hgLDWINTaskId[13]= " + IntToStr(hgLDWINTaskId[13]));
	TaskNew("CheckRAM", WndGetFileProfile("LDWIN", "MinFreeRAM", "512", sFileLDWININI) + "," + WndGetFileProfile("LDWIN", "IntervalRAMCheckInSeconds", "3600", sFileLDWININI), 8);
	IF WndGetFileProfile("LDWIN", "CopyMachineStateFromPLCToDCU", "0", sFileLDWININI) = "1" THEN
		TaskNew("MachineStatePLCtoDCU", "", 8);
	END
	!IF WndGetFileProfile("LDWIN", "MachineStateOnIconographicArea", "0", sFileLDWININI) = "1" THEN
	IF bMachStateOnIconographicArea = True THEN
		TaskNew("CycleMachineJob", "", 8);
		TaskNew("CycleExternalIcons", "", 8);
	END
	sgAlmDspPageName = "AlmDsp";
	hmAlmDsp_NextBtnArg[0] = 16;
	hmAlmDsp_PrevBtnArg[0] = 16;
	bmAutoAckOn = INIParamOn(lbCfgMyAlarmsAutoAck); !18321 MGS 2
	bgCustomLikeGMOn = False;
	smPathCsv = sgLDWINPercProgetto[0] + "\LDWINAlarmList.csv"; !va nel _MAIN
	bgDCUInMODBUS = NOT COMDevInMemory();
	IF bCfgConveyorEnable = True THEN
		iCfgConveyorType = LDWINIniGetIntValue(lbCfgConveyorType);
	END
	IF bgDCUInMODBUS = False THEN
		iDCUTimeStampDecodeMode = 1;
	ELSE
		IF bLDOn = True OR iLDWINNumLpro > -1 THEN
			iDCUTimeStampDecodeMode = 0; !via tag OPC
		END
	END
	IF bRestart = False THEN
		bgPrintPdfWithWkHtmlToPdf = GetLDWININI2Int("PRN", "PrintPdfWithWkHtmlToPdf", "1");
		IF bgPrintPdfWithWkHtmlToPdf = True THEN
			!per funzionare, la stampa nativa win 10 ha bisogno di una dir particolare da copiare in program files
			IF LDWINDirExist("C:\Program Files\wkhtmltopdf") = False THEN
				LDWINMessage("wkhtmltopdf [@(Stampa) pdf]", "C:\Program Files\wkhtmltopdf @(Mancante)! ^nCopiare la dir. wkhtmltopdf da R:\...", 0, "", 48);
			END
		END
		IF INIParamOn(lbCfgTagStatoPSW) = True THEN !se le password sono disattivate, qualcuno si deve autenticare comunque e quindi il task rimane in attesa
			SleepMS(200); !gli do del margine... non si sa mai con macchine lente
			WHILE UserInfo(0) = "0" DO !finchè nessuno è autenticato (Grazie Citect 7.5)
				SleepMS(500);
				ErrLog("Attesa Autenticazione");
			END
		END
		!InitAllarmiRT();
		!InitAllarmiPLC();
		!inizializzazione dei messaggi di allarme (descrizioni)
		!PLCAlmMsgInit();
		!AlmMsgInit();
		!inizializzazione array DLL per sistema allarmi socket (pacchetto 14)
		hsAdvAlmMsg = SPCOpenArray(2, lbNumAdvAlmRec);
		!inizializzazione formato allarmi pagina proc
		sDummy         = ParameterGet("Alarm", "LastAlarmFmt", "{TIME,9}{TAG,5} {NAME,65} {DESC,20}");
		hmLastAlarmFmt = FmtOpen("LastAlarmFmt", sDummy, 1);
		IF bCitect72 = True THEN !7.5 dà problemi
			sDummy = ParameterGet("Alarm", "LastAlarmDisplayMode", "0");
			imnLastAlmDspMode = StrToInt(sDummy);
		END
		!UPS task start...
		sDummy = WndGetFileProfile("LDWIN", "UPSDisable", "0", sFileLDWININI);
		IF sDummy = "0" THEN
			TaskNew("HMIUPSSCAN", "", 8);
		END
	ELSE
		DeleteFileIfExists(sPercLDWINAlmInfo); !Per evitare casini cancella il file delle info allarmi in modo che si rifaccia tutto
	END
	TaskNew("ProcDspLastAlarm", "", 8);
	!IF bRestart = False THEN
		!inizializzazione gestione UPS
	!	sDummy = WndGetFileProfile("LDWIN", "UPSDisable", "0", sFileLDWININI);
	!	IF sDummy = "0" THEN
	!		TaskNew("HMIUPSSCAN", "", 8);
	!	END
	!END
	FOR iCont = 0 TO 1023 DO
		imIndexDiv32[iCont] = iCont/32;
		imIndexMod32[iCont] = iCont MOD 32;
	END
	!ErrLog("AlmManage 2");
	IF bVIOn = True THEN
		IF bRestart = False THEN
			TaskNew("LDWINCopiaAlm2", "", 8); !task di copia delle tag
			btPLCPresenzaBetaway = False;
			!Attendi che il task della socket del VI vada su
			WHILE Get_SckTaskTranceiverOn(2) = False DO
				SleepMS(500);
				ErrLog("In Attesa SOCKET VI...");
			END
			hgLDWINTaskId[46] = TaskNew("LDWINTaskVitalityVI", "46", 0);
		END
		bPPTOn = INIParamOn(lbCfgPPTVision);
		bSoloVI = bgHMISoloVI;
	END
	IF bRestart = False THEN
		!Gestione della statistica del sensore di pressione di linea (inizializzazione)
		IF INIParamOn(lbCfgSensPressioneLinea) = True THEN !20197
			TaskNew("CalcPressLinea", "", 8);
		END
		!Invio di un comando di richiesta refresh allarmi
		IF bSoloVI = False THEN !provvisorio: in questo sistema si ipotizza che tutti i sistemi VI NON usino robe phoenix
			DCUMailboxCMD(36, 0, 0, True);
		END
		!10216
		IF bRTControlTag = True THEN
			TaskNew("LDWINCopiaAlm4", "", 8); !task di copia delle tag (solo per le LFS11)
		END
		TaskNew("LDWINCopiaAlm0", "", 8); !task di copia delle tag
	END
	SELECT CASE iLDWINCustomerID
	CASE 1
		LDWINSetShowGrObj(19, True);
		IF bRestart = False THEN
			hgLDWINTaskId[16] = TaskNew("MedaHMIScanStat", IntToStr(iLDWINCustomerID), 8); !Contatori a evento
		END
	CASE 2, 7, 9, 18
		IF bRestart = False THEN
			hgLDWINTaskId[16] = TaskNew("MedaHMIScanStat", IntToStr(iLDWINCustomerID), 8); !Contatori a evento
		END
	CASE 19 !Liva 17227
		IF bRestart = False THEN
			hgLDWINTaskId[16] = TaskNew("MedaHMIScanStat", IntToStr(iLDWINCustomerID), 8); !Contatori a evento
		END
		bCopyToDCU2 = NOT bMISOn;
	CASE 21 !Wala
		bgSetBatchStartOnMachineStart = GetLDWININI2Int("BATCH", "bgSetBatchStartOnMachineStart", "0", sPercLDWINDATINI);
	CASE 25,36 !Green Mountain, Lactalis
		IF bCfgExternalDevice = True THEN
			Set_imExternalDeviceSymbol(2);
			Set_TemplBtnDspSym(94, 2);
			!ErrLog("Set_TemplBtnDspSym 1");
		END
		bgCustomLikeGMOn = True;
	CASE 26 !Lanfranchi
		bCopyToDCU2 = bMISOn; !Lanfranchi: se MES Attivo, copia gli allarmi DCU sul PLC
	CASE 29 !CTS[ROF]
		IF bRestart = False THEN
			hgLDWINTaskId[67] = TaskNew("ChampionsCustomerTask", "", 8);
		END
	CASE 46, 52 !20251
		IF GetLDWININI2Int("Machine", "NoLateralBelt") = False THEN !20251_3 (non tutti i 46, vogliono il nastro laterale...)
			bLateralBelt = True;
			bgLateralBelt = bLateralBelt; !20251_2
		END
	CASE 51 !18102_3
		IF bRestart = False THEN
			TaskNew("UpperPrompt", IntToStr(iLDWINNumLPro) + "," + IntToStr(iLDWINCustomerId), 8);
		END
	END SELECT
	bBatchDCUDaEvento = bgBatchDCUDaEvento;
	IF bRestart = False THEN
		!Backup remoto
		IF INIParamOn(lbCfgMyRemoteBck) = True THEN
			TaskNew("RemoteBckTask", "", 8);
		END
		!HMIVitalInit(iLDWINCustomerID, bVIOn);
		bEnable1 = INIParamOn(lbCfgMyCTPSupport);
		bEnable = INIParamOn(lbCfgMyLBLSupport);
		HMIVitalInit(iLDWINCustomerID, bVIOn, bEnable1, bEnable);
		!IF INIParamOn(lbCfgMyCTPSupport) = True THEN
		IF bEnable1 = True THEN
			TaskNew("CTPSupportTask", "", 8);
			TaskNew("LDWINCopiaAlm6", "", 8); !task di copia delle tag
		END
		!IF INIParamOn(lbCfgMyLBLSupport) = True THEN !22171 LBL
		IF bEnable = True THEN !22171 LBL
			TaskNew("LBLSupportTask", "", 8);
			TaskNew("LDWINCopiaAlm9", "", 8); !task di copia delle tag
		END
		IF bMISOn = True THEN
			bMES_MachineStateOn = INIParamOn(lbCfgMyMISSendMachineState);
			IF iLDWINCustomerId = 25 THEN
				TaskNew("LDWINCopiaAlm8", "", 8); !task di copia delle tag
			END
			TaskNew("MISTransceiver", IntToStr(bCFR21On) + "," + IntToStr(iLDWINCustomerId) + "," + IntToStr(bSPCOn), 8);
		END
		IF bCopyToDCU2 = True THEN !Copia le informazioni relative alla DCU sul PLC
			TaskNew("CopyDCUInfoToPLC", "", 8);
		END
		IF INIParamOn(lbCfgAuxPLC) = True THEN
			TaskNew("AuxPLCtask", "", 8);
		END
		TaskNew("LeggiContatori", IntToStr(bLDOn) + "," + IntToStr(iLDWINCustomerId) + "," + IntToStr(iTipoMacchina), 8);
		hgLDWINTaskId[51] = TaskNew("DspVelTask", IntToStr(bMISOn), 8);
		IF bgImbolzOn = True THEN
			TaskNew("PackNotExitAlmRecoveryTask", "", 8);
		END
		TaskNew("LDWINBtnInputTask", IntToStr(bCFR21On), 8);
		hgLDWINTaskId[68] = TaskNew("ManageMailboxIn", IntToStr(iLDWINCustomerId) + "," + IntToStr(bCANSTOPScrewOnTemplate) + "," + IntToStr(bSPCOn) + "," + IntToStr(bScrewFeeder), 8);
		LDWINWaitForTask(68);
		IF INIParamOn(lbCfgScrewFeeder) = True THEN !In questo punto di sicuro deve arrivare il comando eventuale da DCU: imposta il default a sblocco
			Set_ScrewFeeder();
			ErrLog("Richiesta stato Coclea");
			DCUMailBoxCmd(200, 40, 0, True);
		END
		IF bMISOn = True THEN
			IF INIParamOn(lbCfgMyMISStartupRefreshState) = True THEN
				ErrLog("Invio del comando di refresh");
				DCUMailBoxCmd(207, 3, LDWINIniGetIntValue(lbCfgMyMISDeviceToConnect), True); !comando di refresh stato Asservimento
			END
		END
		hgLDWINTaskId[83] = TaskNew("ScreenSaverTask", "", 8);
		IF iLDWINNumLPro > -1 THEN !se c'è almeno un laser Lpro
			TaskNew("UpperPrompt", IntToStr(iLDWINNumLPro) + "," + IntToStr(iLDWINCustomerId), 8);
		END
		IF bByPassOn = True THEN
			TaskNew("ByPassCalcStatusTask", IntToStr(iLDWINCustomerId), 8);
		END
	END
	FOR iCont = 0 TO lbNumAdvAlmRec - 1 DO !reset dello stato ack all'avvio in modo che anche gli allarmi non presenti risultino ACK
		imAckAdvAlm[iCont] = - 1; !inizializzato a -1(tutti i bit a 1)
	END
	Set_bHMIDisBtn(10, bManualBatchManagement);
	IF bRestart = False THEN
		TaskNew("PromptWaitTask", "", 8);
		!Verifica category.DBF per vedere se corrisponde all'impostazioni della gestione allarmi
		sVal = sgLDWINPercProgetto[1] + "\category.DBF"; !nel LDWIN
		DevModify("DevDummy", "*", "*", sVal, dBASE_DEV);
		hDev = DevOpen("DevDummy", 0);
		IF hDev <> -1 THEN
			!Controllo category.DBF -> il campo LOGDEVICE deve essere vuoto altrimenti gli allarmi vengono raddoppiati[scritti sia automaticamente che manualmente]
			DevFirst(hDev);
			iErr = 0;
			WHILE iErr = 0 DO
				sVal = DevGetField(hDev, "CATEGORY"); !determina la categoria
				sDummy = DevGetField(hDev, "LOGDEVICE");
				IF sVal <> "255" AND sDummy <> "" THEN !tranne per gli allarmi HW gli altri devono avere i device di log vuoti
					Message("AlmManage -> Category.DBF", "registrazione allarmi da LDWIN: categoria " + sVal + " deve avere la colonna LOGDEVICE vuota.^nRegistrazione allarmi DUPLICATA!!", 16);
				END
				iErr = DevNext(hDev);
			END
			IF bgDeleteCitectAlms = False THEN
				!caricamento stato allarmi esecuzione precedente da LDWINAlmInfo.INI
				!inizializzazione base degli allarmi, vengono inizializzati gli stati attuali perchè saranno copiati negli stati precedenti all'inzio della scansione allarmi
				FOR iCont = 0 TO iNumAdvAlm DO !inizializzo l'intero contenuto dell'array, se non è presente il valore in LDWINDATINI lo considero spento e ack
					!Bit 0 Stato di Attivazione
					!Bit 1 Stato di Fack
					!Bit 2 Stato di Ack
					iDummy = GetLDWININI2Int("ALM", "AlmStatus_" + IntToStr(iCont), "4", sPercLDWINAlmInfo); !TODO: studiare bene il default a seconda che ci sia o no il doppio ACK
					bmAlmServerAlmIsOnPrec[iCont] = CheckBit(iDummy, 0);
					bmAlmServerAlmIsAckPrec[iCont] = CheckBit(iDummy, 2);
				END
				!inizializzazione dei dati allarmi per la visualizzazione dei dati attivi
				!nel LDWINAlmInfo.ini la chiave [ALM]AlmDspSize restituisce la dimensione delle righe della matrice da leggere per caricare lo stato precedente
				!non si cerca più l'elemento "" perchè il salvataggio salva solo quelle attive e quindi potrebbero esserci dei dati sporchi di vecchi riavvi
				iDummy = GetLDWININI2Int("ALM", "AlmDspSize", "0", sPercLDWINAlmInfo);
				FOR iCont2 = 1 TO iDummy DO
					IF iCont2 = 1 THEN
						ErrLog("");
					END
					sCont2 = IntToStr(iCont2);
					!Per risparmiare sulla scrittura su disco, la pos. 0 contiene il tag a DB + il nome Bonfi, separati dal carattere "@"
					sDummy = WndGetFileProfile("ALM", "AlmDsp_" + sCont2 + "_0", "", sPercLDWINAlmInfo);
					sValQue2 = sDummy;
					!Determinazione del RecNo
					iDummy2 = StrSearch(0, sValQue2, "_") + 1;
					iValQue2 = StrSearch(0, sValQue2, "@");
					IF iValQue2 > -1 THEN
						sDummy = StrLeft(sValQue2, iValQue2); !Determina il campo Tag
						iLen = StrLength(sValQue2) - iValQue2 - 1;
						sDummy2 = StrRight(sValQue2, iLen); !determina il nome Bonfi
						IF iDummy2 > -1 THEN
							IF iValQue2 > iDummy2 THEN
								sVal = StrMid(sValQue2, iDummy2, iValQue2 - iDummy2); !Determina il campo RecNo
								hmDspAlmGenie2AdvAlmNumRec[iCont2] = StrToInt(sVal);
							END
						END
					END
					IF sDummy <> "" THEN !Se è definito lo copiamo, evitiamo che in caso di errori si lanci un ciclo su un elemento nullo
						sltAlmActDsp[iCont2][0] = sDummy;
						!i colori sono memorizzati in nella chiave [ALM]AlmDspColor_NumRiga nel formato coloreColonna1_coloreColonna2_..._coloreColonnaN
						!utilizzo il strSplitInQue per caricarli nelle strutture
						sDummy = WndGetFileProfile("ALM", "AlmDspColor_" + sCont2, "", sPercLDWINAlmInfo);
						hQue = StrSplitInQue(sDummy, "_", False);
						IF hQue <> -1 THEN
							FOR iCont = 1 TO 14 DO
								sCont = sCont2 + "_" + IntToStr(iCont);
								iValQue = iCont;
								iErr = QuePeek(hQue, iValQue, sValQue, 16); !sValQue contiene l'informazione
								IF iErr = 0 THEN
									iValQue = StrToInt(sValQue);
								ELSE !errore o offset non trovato
									iValQue = 0;
								END
								SELECT CASE iCont
								CASE 1 !Nome dell'allarme alla colonna del genie
									GnAlmActDspSet(iCont2, 1, sDummy2, iValQue);
								CASE 2 !Data e ora
									sDummy2 = WndGetFileProfile("ALM", "AlmDsp_" + sCont, "", sPercLDWINAlmInfo);
									iCol0 = iValQue; !memorizza il valore per poco sotto
								CASE 3 !Data e ora
									bEnQue2 = True; !Splitta il gruppo
								CASE ELSE
									sDummy = WndGetFileProfile("ALM", "AlmDsp_" + sCont, "", sPercLDWINAlmInfo);
									GnAlmActDspSet(iCont2, iCont, sDummy, iValQue);
								END SELECT
								IF bEnQue2 = True THEN
									hQue2 = StrSplitInQue(sDummy2, "@", False);
									IF hQue2 <> -1 THEN
										iValQue2 = 0;
										iErr = QuePeek(hQue2, iValQue2, sValQue2, 16); !sValQue2 contiene l'informazione
										IF iErr = 0 THEN
											GnAlmActDspSet(iCont2, iCont - 1, sValQue2, iCol0);
										END
										iValQue2 = 1;
										iErr = QuePeek(hQue2, iValQue2, sValQue2, 16); !sValQue2 contiene l'informazione
										IF iErr = 0 THEN
											GnAlmActDspSet(iCont2, iCont, sValQue2, iValQue);
										END
										QueClose(hQue2);
									END
									bEnQue2 = False;
								END
							END
						END
						QueClose(hQue);
					END
				END
			END
			!debug
			!TestShowActAlmMarix();
			!--------------------
			TaskNew("TaskWriteAlarmToSQL", "", 8);
			LDWINWaitForTask(95);
			DevClose(hDev);
		ELSE
			Message("ALMMANAGE", "fallimento Apertura " + sVal + "^nRegistrazione allarmi NON GARANTITA!!!!!", 16);
		END
	END !IF bRestart = False
	!ErrLog("AlmManage 3");
	WHILE bgLDWINTaskOn[13] = True DO
		!ErrLog("InitScan");
		iTempoTaskAlm = SysTime();
		!Aggiornamento data e ora di sistema
		iDummy = iTimeCurrent; !memorizza il valore al ciclo precedente
		iTimeCurrent = TimeCurrent();
		IF iDummy > iTimeCurrent THEN !trappola in caso di desincronizzazione del PC magari in caso di utilizzo del time server
			sDummy = TimeToStr(iDummy, 4); !TimeToStr(iTimeCurrentOld, 9) + " - " + TimeToStr(iTimeCurrentOld, 5);
			sVal = TimeToStr(iTimeCurrent, 4); !TimeToStr(iTimeCurrent, 9) + " - " + TimeToStr(iTimeCurrent, 5);
			sDummy = "(" + sDummy + ") " + sVal;
			WrRptAT("@(Desincronizzazione Orario)", sDummy, True);
			ShowMessageTask("@(Desincronizzazione Orario)", sDummy, 16);
		END
		iTimeSec = iTimeCurrent MOD 60; !determinazione dei secondi
		sDummy = TimeToStr(iTimeCurrent, 1);
		smLDWINOraMinSec = sDummy;
		!ErrLog("AlmManage 1.1");
		!IF iTimeSec = 0 OR bmAggiornaDataLDWIN = True THEN !aggiorna la data di sistema ogni minuto oppure su richiesta
		iDummy = iTimeCurrent / 60;
		IF iOldMinute <> iDummy OR bmAggiornaDataLDWIN = True THEN !aggiorna la data di sistema ogni minuto oppure su richiesta
			sVal = StrLeft(sDummy, 5); !determinazione di HH:mm
			smLDWINOra   = StrLeft(sVal, 2);
			smLDWINMin   = StrRight(sVal, 2);
			sgLDWINData  = CalcDataLDWIN(iTimeCurrent);
			IF sVal = "00:00" OR bmAggiornaDataLDWIN = True THEN !alla mezzanotte o su richiesta
				!sul cambio di data
				!IF sgLDWINData <> smLDWINDataPrec THEN
				IF sgLDWINData <> smLDWINDataPrec AND lbPLCCommDisable = False THEN
					!evento cambio di data: tutte le azioni su questo evento vanno messe qui
					!ErrLog("Cambio di data: " + smLDWINDataPrec + "->" + sgLDWINData);
					smLDWINDataPrec   = sgLDWINData;
					CalcDataRawDataSQL();
					TaskNew("LDWINSQLCircularity", IntToStr(igNumAnniSQLCircolarita), 8); !cancella tutti i record delle tabelle MySQL più vecchi di un anno
				END
				bmAggiornaDataLDWIN = False;
			END
			smLDWINOraMin = sVal;
			CalcDspDataLDWIN();
			iOldMinute = iDummy;
		END
		!Robe da far funzionare ogni secondo
		IF iContDCUSynchro = 0 THEN
			!ErrLog("AlmManage: " + smLDWINOraMinSec);
			SELECT CASE iDCUTimeStampDecodeMode
			CASE 0 !Con tag opc
				smTempoDCU = stgTimeStamp;
				IF smTempoDCU = "" THEN
					stgTimeStamp = sDummy;
					itRTUtente = igRTCopiaUtenteAttivo; !comunica l'utente attivo
				END
			CASE 1 !Con interi
				iDummy = stgTimeStamp;
				IF iDummy = 0 THEN
					!ErrLog("Syncro con RT MODBUS: " + sDummy);
					stgTimeStamp = StrToInt(smLDWINOra) * 65536 + StrToInt(smLDWINMin) * 256 + iTimeSec;
					itRTUtente = igRTCopiaUtenteAttivo; !comunica l'utente attivo
				END
			END SELECT
			!17130 si abilita la scansione degli stati di bypass
			IF iLDWINNumLPro > -1 THEN
				FnSelBypassLaser(1);
			END
			!Gestione btn unificato coclea/canstop
			IF bCANSTOPScrewOnTemplate = True THEN
				IF bCANSTOPBtn = True THEN
					iDummy = TagRead("btPLCCocleaCANSTOP", 0, "LDWIN");
					Set_LDWINBtnArExpr(298, iDummy);
					Set_TemplBtnDspSym(298, iDummy);
					!ErrLog("Set_TemplBtnDspSym 2");
				END
				IF bScrewFeeder = True THEN !TODO da tirare via se in uso il template con i bottoni generici
					LDWINSetDisBtn(298, MailBoxCMDOn());
				END
			END
			IF bgMainProcOn = True THEN
				IF hgLDWINTaskId[15] <> -1 THEN
					!ErrLog("TaskResume: hgLDWINTaskId[15]= " + IntToStr(hgLDWINTaskId[15]));
					TaskResume(hgLDWINTaskId[15]);
				END
			END
			iContDCUSynchro = 1;
			!ErrLog("AlmManage: " + smLDWINOraMinSec);
		ELSE
			iContDCUSynchro = 0; !riarmo il sistema
		END
		!fine sezione robe da scansione ad 1 secondo
		!gestione Reset da PLC
		!si ipotizza che il tasto di reset sia fatto sparire e che sul pannello frontale sia presente un bottone di reset
		bDisAllBtnFn = True;
		//scansione dei feedback ai comandi mailbox[non è detto che siano utilizzati sono in full-phoenix]
		!0:luce
		!1:nastro
		!2:wireless
		!3:ads
		!4:Freedrive UR1
		!5:panic Mode UR1
		!6:pinze UR1
		!7:challenge VI
		!8:Knapp VI
		!9:Svuotamento Linea
		!10:Freedrive UR2
		!11:panic Mode UR2
		!12:pinze UR2
		!13: Step Mode
		FOR iCont = 0 TO 31 DO
			iDummy = itPLCHMIBancoFeedBack BITAND imExp2Bit[iCont];
			IF iDummy <> 0 THEN
				bmPLCHMIBancoFeedBack[iCont] = True;
			ELSE
				bmPLCHMIBancoFeedBack[iCont] = False;
			END
		END
		IF LDWINIniGetIntValue(lbCfgMyCobotNumber) = 1 THEN
			Set_LDWINBtnSpia(228, bmPLCHMIBancoFeedBack[4]); !stato freedrive UR
			Set_LDWINBtnSpia(229, bmPLCHMIBancoFeedBack[5]); !stato panic mode UR
			Set_LDWINBtnSpia(230, bmPLCHMIBancoFeedBack[6]); !stato pinza UR
		ELSE
			Set_LDWINBtnSpia(228, True); !stato freedrive UR
			Set_LDWINBtnSpia(229, True); !stato panic mode UR
			Set_LDWINBtnSpia(230, True); !stato pinza UR
		END
		!cobot1
		IF bmPLCHMIBancoFeedBack[4] = True THEN !freedrive ON
			IF bmPLCHMIBancoFeedBack[5] = True THEN !panic Mode
				!aprire popup richiesta posizionamento per panic mode
				TaskNew("ManagePanicMode", "1", 8);
			ELSE !solo popup freedrive
				TaskNew("ManageFreedrive", "1", 8);
			END
		END
		!cobot2
		IF bmPLCHMIBancoFeedBack[10] = True THEN !freedrive ON
			IF bmPLCHMIBancoFeedBack[11] = True THEN !panic Mode
				!aprire popup richiesta posizionamento per panic mode
				TaskNew("ManagePanicMode", "2", 8);
			ELSE !solo popup freedrive
				TaskNew("ManageFreedrive", "2", 8);
			END
		END
		!IF bNew = False THEN
		IF bMachStateOnIconographicArea = False THEN
			IF bmPLCHMIBancoFeedBack[7] = True THEN !challenge Mode
				imExtModeIco = 1;
			ELSE
				IF bmPLCHMIBancoFeedBack[8] = True THEN !Knapp Test Mode
					imExtModeIco = 2;
				ELSE
					IF bgPrivOn[8] = True THEN
						imExtModeIco = 3; !x compattare i simboli in modo da non bloccare l'ambiente di sviluppo
					ELSE
						imExtModeIco = 0;
					END
				END
			END
		END
		btHMI_bBatchOpen = GetBatchStatus();
		btHMI_SvuotamentoLinea = bmPLCHMIBancoFeedBack[9];
		IF bRTControlTag = True THEN !Gestione esclusiva da RT
			//scansione dei feedback ai comandi mailbox
			//!0:luce
			//!1:nastro
			//!2:wireless
			//!3:ads
			//!4:Freedrive UR
			//!5:panic Mode UR
			//!6:pinze UR
			//!7:challenge VI
			//!8:Knapp VI
			Set_LDWINBtnSpia(85, bmPLCHMIBancoFeedBack[2]);
			Set_LDWINBtnSpia(111, bmPLCHMIBancoFeedBack[3]); !Asciugatura in corso
			iStatoMac = itPLCHMIStatoMac; !Assegnamento del valore dello stato macchina a variabile locale di memoria (Da RT)
			IF bgDCUInMODBUS = False THEN
				iStatoMac = iStatoMac BITAND 255; !Lettura da un unico indirizzo su cui c'è altra roba (8 bit riservati)
			END
		ELSE !Gestione da PLC
			iStatoMac = itPLCStatoMac; !Assegnamento del valore dello stato macchina a variabile locale di memoria (Da PLC)
			IF bLuceOn = True THEN
				bmPLCHMIBancoFeedBack[0] = btPLCLuce;
			END
			!decodifica feedback PLC
			FOR iCont = 0 TO 31 DO
				iDummy = itPLCHMICommandFeedBack BITAND imExp2Bit[iCont];
				IF iDummy <> 0 THEN
					bmPLCHMICommandFeedBack[iCont] = True;
				ELSE
					bmPLCHMICommandFeedBack[iCont] = False;
				END
			END
		END
		IF bLuceOn = True THEN
			Set_TemplBtnDspSym(115, bmPLCHMIBancoFeedBack[0]);
			!ErrLog("Set_TemplBtnDspSym 3");
		END
		IF bInterLock = True THEN
			Set_TemplBtnDspSym(198, btPLCDoorInterlock);
			!ErrLog("Set_TemplBtnDspSym 4");
		END
		!tasti funzione man e auto
		IF bgLDWINTaskOn[52] = False AND bgSpr3On = False AND bgGMNewRecipeOn = False THEN
			IF bMISOn = True AND GetBEControlStatus() = False THEN
				bEnable = True;
			ELSE
				bEnable = False;
			END
			bEnable1 = (iStatoMac <> 1) OR (bgMySave = 1) OR (bgRecipeApproved = False AND bCFR21On = True);
			IF bEnable = True AND bMISManualSendRecipe = False THEN
				LDWINSetDisBtn(67, True);
			ELSE
				LDWINSetDisBtn(67, bEnable1 OR btPLCRicettaOn = 1);
			END
			!Gestione Btn invio AM
			LDWINSetDisBtn(314, bEnable1);
			IF bEnable = True AND bMISManualChangeHMIMode = False THEN
				LDWINSetDisBtn(91, True);
				LDWINSetDisBtn(93, True);
				IF bgPrivOn[5] = True THEN !bottone automatico solo se Maint
					LDWINSetDisBtn(92, False);
					IF iStatoMac = 1 OR iStatoMac = 0 THEN !in modo che quando non siamo in inserimento dati non si modifichino le proprietà di disattivazione dei tasti
						Set_bHMIDisBtn(0, False);
					END
				ELSE
					LDWINSetDisBtn(92, True);
				END
			ELSE
				IF iLDWINCustomerID <> 26 THEN ![lanfranchi] disa dei bottoni data ins manuale e auto
					IF bRTControlTag = False THEN
						LDWINSetDisBtn(91, btPLCManuale);
						LDWINSetDisBtn(92, btPLCAutomatico);
					ELSE
						LDWINSetDisBtn(91, btPLCHMIManuale);
						LDWINSetDisBtn(92, btPLCHMIAutomatico);
					END
					LDWINSetDisBtn(93, False);
				END
			END
			bDisAllBtnFn = False;
		END
		!Se attiva la ricetta si disattivano tutti e due (per un Max di 1 minuto)
		IF bDisAllBtnFn = True THEN
			IF imContTimeoutBlkBtn < 120 THEN
				bEnable = True;
				imContTimeoutBlkBtn = imContTimeoutBlkBtn + 1;
			ELSE !forza lo sblocco
				bEnable = False;
			END
			IF iLDWINCustomerID <> 26 THEN
				LDWINSetDisBtn(91, bEnable);
				LDWINSetDisBtn(92, bEnable);
			END
			LDWINSetDisBtn(67, bEnable); !btn Invio ricetta
		END
		!Evento cambiamento stato macchina
		IF iPrecStatoMac <> iStatoMac THEN
			!ErrLog("AlmManage Cambio Stato");
			IF bMES_MachineStateOn = True THEN
				TagWrite("itMes_MachineState", IntToStr(iStatoMac), 0, 1, "LDWIN");
			END
			LDWINFormDestroy(51); !se la shortcut è attiva e cambia lo stato, form di shortcut caputt
			bmStatoMac1OR5 = (iStatoMac = 1 OR iStatoMac = 5) AND iStatoMac <> 0;
			bNOTStatoMac1OR5 = NOT bmStatoMac1OR5;
			LDWINSetDisBtn(228, bNOTStatoMac1OR5);
			LDWINSetDisBtn(229, bNOTStatoMac1OR5);
			LDWINSetDisBtn(230, bNOTStatoMac1OR5);
			LDWINSetDisBtn(232, bNOTStatoMac1OR5);
			!Traccia il cambio di fase macchine
			SELECT CASE iLDWINCustomerID
			CASE 25 !Green Mountain
				imScrTemplSt[0] = iStatoMac;
				LDWINTaskResume(35);
			CASE 26 !Lanfranchi
				IF iPrecStatoMac = -1 THEN
					WrRptAT("@(Stato Macchina)", IntToStr(iStatoMac));
				ELSE
					WrRptAT("@(Stato Macchina)", "(" + IntToStr(iPrecStatoMac) + ") " + IntToStr(iStatoMac));
				END
			END SELECT
			IF iStatoMac > -1 AND iStatoMac < 8 THEN
				imLDStatoMac = iStatoMac;
			ELSE
				imLDStatoMac = 0;
			END
			iPrecStatoMac = iStatoMac;
			IF iStatoMac = 1 THEN
				Set_bHMIDisBtn(1, False); !si suppone che tutte le operazioni su bottoni comincino dall'inizio del data ins IN POI
				!caso circolarità MySQL la mezzanotte è scattata quando la macchina era in collaudo
				!per non appesantire HMI, il chk di circolarità è eseguito al primo arresto in "data ins" della macchina
				LDWINSetDisBtn(189, True);
				LDWINSetDisBtn(198, False);
				LDWINSetDisBtn(131, False); !Rpt Produz.
				LDWINSetDisBtn(206, False); !Reset Cnt 21206_3
				LDWINSetDisBtn(285, False); !Rpt Produz.
				LDWINSetDisBtn(339, False); !Rpt Produz. !20260
				!20157
				LDWINSetDisBtn(164, False); !Versioni Paramvut cfr21
				LDWINSetDisBtn(254, False); !Stampa Paramvt
				SetTempoScreenSaver();
			ELSE
				Set_bHMIDisBtn(1, True); !x impedire la consultazione dei rapporti in uno stato NON DATAINS. Potrebbe succedere se la shortcut è disegnata in DATA INS e POI, per qualche motivo, lo stato macchina cambia
				LDWINSetDisBtn(198, True);
				LDWINSetDisBtn(131, True); !Rpt Produz.
				LDWINSetDisBtn(206, True); !Reset Cnt 21206_3
				LDWINSetDisBtn(285, True); !Rpt Produz.
				LDWINSetDisBtn(339, True); !Rpt Produz. !20260
				!20157
				LDWINSetDisBtn(164, True); !Versioni Paramvut cfr21
				LDWINSetDisBtn(254, True); !Stampa Paramvt
				IF Get_bSpr5On(1) = True THEN !Se la pagina di screen saver è attiva
					RilevaAzione(); !disattiva lo screensaver e, se lo stato <> datains permane, sopsendi il task di screen saver
				ELSE
					!ErrLog("AlmManageTS" + IntToStr(hgLDWINTaskId[83]));
					TaskSuspend(hgLDWINTaskId[83]);
				END
			END
			bEnable = HMIDisBtn(1);
			Set_bHMIDisBtn(0, bEnable);
			IF iStatoMac = 2 OR iStatoMac = 5 THEN
				LDWINSetDisBtn(189, False);
			END
			LDWINSetDisBtn(64,  bEnable); !bottone taglierina
			LDWINSetDisBtn(98,  bEnable); !bottone cfg rapporti
			LDWINSetDisBtn(153, bEnable); !bottone selezione rapporti
			LDWINSetDisBtn(169,  bEnable); !Rirpistino cfg
			LDWINSetDisBtn(170,  bEnable); !Backup cfg
			IF bmStatoMac1OR5 = True THEN
				IF iLDWINNumLPro > -1 THEN
					SetRefBtnPremuto(False);
				END
				MISCalcDisBtn(bMISOn, bManualBatchManagement);
				IF bgLDWINTaskOn[52] = False THEN !modifica il valore dei flag se non c'è nessuna ricetta in invio
					Set_bRecDisBtnArrow(False);
				END
				IF bSPCOn = True THEN !se attivo SPC
					Set_bHMIDisBtn(9, False); !Bottoni pag Istogrammi
				END
				IF bVIOn = True THEN
					LDWINSetDisBtn(57, False); !motori VI
					IF bPPTOn = True THEN
						TaskResume(hgLDWINTaskId[12]); !Riattiva il task
					END
				END
			ELSE
				Set_bRecDisBtnArrow(True);
				LDWINSetDisBtn(58, True); !btn Batch
				IF iLDWINNumLpro > -1 THEN
					SetRefBtnPremuto(True);
				END
				IF bSPCOn = True THEN !se attivo SPC
					Set_bHMIDisBtn(9, True); !Bottoni pag Istogrammi
				END
				SetChiudiSReset(1);
				IF bVIOn = True THEN
					LDWINSetDisBtn(57, True); !motori VI
					IF bPPTOn = True THEN
						!ErrLog("AlmManageTS2" + IntToStr(hgLDWINTaskId[12]));
						TaskSuspend(hgLDWINTaskId[12]); !Sospendi il task
					END
				END
			END
			!Gestione stato "Manuale" dell HMI
			IF iStatoMac <> 3 THEN
				bmMachStNot3 = True;
				LDWINSetDisBtn(142, True);
			ELSE
				bmMachStNot3 = False;
				LDWINSetDisBtn(142, False);
			END
			!Gestione della disabilitazione del tasto diagnostica
			SELECT CASE iTipoMacchina
			CASE lbML
				IF iStatoMac = 1 OR iStatoMac = 3 THEN
					LDWINSetDisBtn(21, False); !diagnostica
				ELSE
					LDWINSetDisBtn(21, True); !diagnostica
				END
			CASE lbMachLVA
				IF INIParamOn(lbCfgLproLOALaser) = True THEN
					IF GetProcAutomation(lbCfgLproLOALaser) = False THEN
						bmMacchinaInMoto = bNOTStatoMac1OR5;
					END
				END
				IF INIParamOn(lbCfgLproLRHLaser) = True THEN
					IF GetProcAutomation(lbCfgLproLRHLaser) = False THEN
						bmMacchinaInMoto = bNOTStatoMac1OR5;
					END
				END
			CASE lbMachLFS
				IF iStatoMac = 1 OR iStatoMac = 3 THEN
					LDWINSetDisBtn(21, False); !diagnostica
				ELSE
					LDWINSetDisBtn(21, True); !diagnostica
				END
				bmMacchinaInMoto = bNOTStatoMac1OR5;
			CASE ELSE
				IF iLDWINCustomerID = 20 THEN !LogoPlaste
					IF iStatoMac = 1 OR iStatoMac = 3 THEN
						LDWINSetDisBtn(21, False); !diagnostica
					ELSE
						LDWINSetDisBtn(21, True); !diagnostica
					END
				ELSE
					IF iStatoMac <> 1 THEN
						LDWINSetDisBtn(21, True); !diagnostica
					ELSE
						LDWINSetDisBtn(21, False); !diagnostica
					END
				END
			END SELECT
			!Gestione bottone reverse
			IF iStatoMac = 1 OR iStatoMac = 7 THEN
				LDWINSetDisBtn(73, False); !Btn reverse
			ELSE
				LDWINSetDisBtn(73, True); !Btn reverse
			END
			TaskResume(hgLDWINTaskId[15]);
		END !fine gestione evento cambio stato macchina
		igStatoMac = iStatoMac;
		!tasti  o robe che devono essere disattivati quando un comando di mailbox è attivo
		LDWINSetDisBtn(55, bgCMDDCUMailboxOn[0]); !reset modello
		IF bCfgConveyorEnable = True THEN
			SELECT CASE iCfgConveyorType
			CASE 0 !DCU
				SetConvStatus(bmPLCHMIBancoFeedBack[1]);
				Set_TemplBtnDspSym(116, bmPLCHMIBancoFeedBack[1]);
				!ErrLog("Set_TemplBtnDspSym 5");
			CASE 1 !pilici
				SetConvStatus(btPLCNastroOn);
				Set_TemplBtnDspSym(116, btPLCNastroOn);
				!ErrLog("Set_TemplBtnDspSym 6");
			END SELECT
		END
		IF bLateralBelt = True THEN
			Set_TemplBtnDspSym(357, btPLCLateralBelt); !20251
		END
		!gestione dispositivi esterni
		IF bCfgExternalDevice = True THEN
			IF bgCustomLikeGMOn = False THEN
				iExternalDeviceState = btPLCHMIOutbExternalConveyorCommand;
				IF iExternalDeviceState <> iExternalDeviceStatePrev THEN
					Set_imExternalDeviceSymbol(iExternalDeviceState);
					Set_TemplBtnDspSym(94, iExternalDeviceState);
					!ErrLog("Set_TemplBtnDspSym 7");
					iExternalDeviceStatePrev = iExternalDeviceState;
				END
			END
		END
		IF bLDOn = True THEN
			bEnable = bgLDWINTaskOn[52];
			LDWINSetDisBtn(12,  bEnable); !DB autodiagnosi
			LDWINSetDisBtn(186, bEnable); !DB formati CTP
			IF bByPassOn = True THEN !se attivo il supporto per il bypass
				bPLCLDOnOff = btPLCLDOnOff;
				IF bPLCLDOnOffPrec <> bPLCLDOnOff THEN
					bgByPassOnOff[0] = bPLCLDOnOff; !stato del bypass
					SetByPassStato(0);
					SetProcInBypass(0, NOT bPLCLDOnOff);
					bPLCLDOnOffPrec = bPLCLDOnOff;
				END
			END
			!Gestione del Prompt di warmup
			IF bWarmupOn = True THEN !questa macchina ha il warmup
				iDummy = itPLCTempoWU;
				IF iDummy > 9 THEN
					rNumSecWarmup = IntToReal(iDummy)/10.0;
					iStatoPromptWarmup = 10;
					LDWINPromptSetString("@(Fine Warmup Tra): " + StrTrim(RealToStr(rNumSecWarmup, 4, 1)) + " s", 0);
				ELSE
					IF iStatoPromptWarmup = 10 THEN
						LDWINPromptSetString("", 0);
						iStatoPromptWarmup = 0;
					END
				END
			END
		END
		!Scansione delle tag provenienti dal PLC
		bmStsAlmFlag[1] = False;
		bmStsAlmFlag[2] = False;
		bmStsAlmFlag[3] = False;
		iValidazione = igValidazione;
		!nuova gestione allarmi -> tutti advanced [PADDY]
		FOR iCont = 0 TO iNumAdvAlm DO
			iNumAlm = hmAdvAlmNumRecTag[iCont]; !# dell'allarme Sia x SPC che per sistema ACK
			bmAlmIsAckTemp[iNumAlm] = 1; !inizializzato a 1(Ack) in modo che lo stato di noAck vinca su tutti grazie al controllo in AND
		END
		!ErrLog("AlmManage 4");
		FOR iCont = 0 TO iNumAdvAlm DO
			//IF iCont = 69 THEN
			//iDummyDEBUG = 0;
			//END
			!Verifica transizione stato allarmi per scrittura su SQL
			sAlmTag = sltAlmTagDev[iCont];
			iCitectAlmRec = AlarmFirstTagRec(sAlmTag, "", "", "LDWIN");
			sOnTime = AlarmGetFieldRec(iCitectAlmRec, "OnTime");
			IF sOnTime > "" THEN !Non ha senso scandire info di un record dal server che comunque sia, non abbia un'ora di ontime.
				sOffTime = AlarmGetFieldRec(iCitectAlmRec, "OffTime");
				bmAlmServerAlmIsOn[iCont] = GetAlmOnByTime(sOnTime, sOffTime); !Grazie Citect 7.5!
				sAckTime = AlarmGetFieldRec(iCitectAlmRec, "AckTime");
				!per non farlo dipendere dalle traduzioni di "ACNOWLEDGED" e "UNACNOWLEDGED", si sfrutta il fatto che l'evento di ACK è segnato da Citect
				!l'ora non dipende dalla lingua o dal formato di data. Se l'allarme non è ACKato, l'ora vale stringa nulla.
				IF sAckTime = "" THEN !21206_75
					bmAlmServerAlmIsAck[iCont] = False;
				ELSE
					bmAlmServerAlmIsAck[iCont] = True;
				END
				bWrite = False;
				IF bmAlmServerAlmIsAckPrec[iCont] <> bmAlmServerAlmIsAck[iCont] THEN
					sAckComment = smAlmAckComment; !21206_41
					bWrite = True;
				END
				IF bmAlmServerAlmIsOnPrec[iCont] <> bmAlmServerAlmIsOn[iCont] THEN
					sAckComment = "NA"; !21206_41
					bWrite = bWrite OR True;
					IF bFack = True THEN
						!se l'allarme viene su da spento che era, di sicuro è da FAckare
						IF bmAlmServerAlmIsOnPrec[iCont] = False AND bmAlmServerAlmIsOn[iCont] = True THEN
							bmAlmServerAlmIsFAck[iCont] = False;
							bmAlmServerAlmIsFAckPrec[iCont] = False;
						END
					END
				END
				IF bFack = True THEN
					bSetFACK = False;
					IF bmAlmServerAlmIsFAckPrec[iCont] <> bmAlmServerAlmIsFAck[iCont] THEN
						IF bmAlmServerAlmIsFAck[iCont] = True THEN
							sAckComment = smAlmAckComment; !21206_41
							bWrite = bWrite OR True;
							bSetFACK = True;
						END
						ErrLog(sAlmTag + " Rec=" + IntToStr(iCont) + " FAckPrec<->FAck = " + IntToStr(bmAlmServerAlmIsFAckPrec[iCont]) + "<->" + IntToStr(bmAlmServerAlmIsFAck[iCont]));
						bmAlmServerAlmIsFAckPrec[iCont] = bmAlmServerAlmIsFAck[iCont];
					END
				END
				!controllo dello stato di attivazione e di ack per verificare se scrivere record su MySql
				!controllo transizione ACK
				IF bWrite > 0 THEN
					!debug
					//IF bFack = True THEN
					//ErrLog(sAlmTag + " Rec=" + IntToStr(iCont) + " FAckPrec<->FAck = " + IntToStr(bmAlmServerAlmIsFAckPrec[iCont]) + "<->" + IntToStr(bmAlmServerAlmIsFAck[iCont]));
					//END
					ErrLog(sAlmTag + " Rec=" + IntToStr(iCont) + " AckPrec<->Ack = " + IntToStr(bmAlmServerAlmIsAckPrec[iCont]) + "<->" + IntToStr(bmAlmServerAlmIsAck[iCont]) +
					" -- StPrec<->St = " + + IntToStr(bmAlmServerAlmIsOnPrec[iCont]) + "<->" + IntToStr(bmAlmServerAlmIsOn[iCont]));
					!-------------
					LDWINAddAlmToBuf(iCont, AlarmGetFieldRec(iCitectAlmRec, "OnDate"), sOnTime, AlarmGetFieldRec(iCitectAlmRec, "OffDate"), sOffTime, AlarmGetFieldRec(iCitectAlmRec, "DeltaTime"),
					AlarmGetFieldRec(iCitectAlmRec, "AckDate"), sAckTime, AlarmGetFieldRec(iCitectAlmRec, "UserName"), AlarmGetFieldRec(iCitectAlmRec, "Category"), bCitect72, bFACK, bSetFACK, sAckComment);
					bEnTask96Resume = True; !almeno un aggiornamento della grafica
				END
			END !IF sOnTime
			!---------------------
			!memorizzazione stato precedente
			bmAdvAlmOnPrec[iCont] = bmAdvAlmOn[iCont];
			!ErrLog("almmanage: iCont= " + IntToStr(iCont));
			bAlmOn = False;
			iAdvAlmSrc = imAdvAlmSource[iCont];
			iAdvBit    = imAdvAlmBit[iCont];
			iDummy2    = imCopiaAdvAlmPos[iCont];
			IF iDummy2 > -1 AND iDummy2 < lbNumAdvAlmRec THEN
				iDummy  = imCopiaAdvAlm[iDummy2]; !long contenente l'allarme analizzato
			ELSE
				!sDummy = "iAdvAlmSrcOffset = " + IntToStr(iAdvAlmSrcOffset) + " iAdvAlmBnk = " + IntToStr(iAdvAlmBnk) + " iCont = " + IntToStr(iCont);
				sDummy = " imCopiaAdvAlmPos[.]=" + IntToStr(imCopiaAdvAlmPos[iCont]) + " iCont=" + IntToStr(iCont);
				ErrLog("? AlmManage " + sDummy);
			END
			IF iValidazione = False THEN
				bAlmOnComm = False;
				IF bmCommAlm[iCont] = True THEN !se si tratta di un allarme di comunicazione
					!ErrLog("CommAlm(" + IntToStr(iCont) + ") = " + IntToStr(iAdvAlmOn));
					bAlmOnComm = bmCommAlmFail[iCont];
				END
			END
			!determina se iAdvBit è a True
			iDummy2 = iDummy BITAND imExp2Bit[iAdvBit];
			IF iDummy2 <> 0 THEN
				!multimessaggio
				iAdvAlmMsgBnk = imAdvAlmMsgBank[iCont];
				IF iAdvAlmMsgBnk <> -1 THEN !esiste multimessaggio
					iDummy2 = imCopiaAdvAlmMsgPos[iCont];
					iDummy = igCopiaAdvAlmMsg[iDummy2];
					iAdvAlmMsgVl = imAdvAlmMsgVal[iCont];
					IF iAdvAlmMsgVl = -2 THEN !allarme multitesta
						//bAlmOn = True;
						IF GetIntAdvAlmMsg(iCont) = imAdvAlmMsgHeadNumber[iCont] THEN
							bAlmOn = True;
						END
					ELSE !multimessaggio
						IF (iAdvAlmSrc = 5) OR (iAdvAlmSrc = 4 AND imAlmSourceType[4] = 1) THEN !se sorgente 5[LOA L-PRO -> pacchetto 14] OPPURE sorgente 4(RTTag) di tipo 1=Socket -> da 17130 in poi gli allarmi motori arrivano con il pacchetto 14
							!leggi dagli array igCopiaAdvAlmMsg e igCopiaAdvAlmMsgH per decidere se attivare gli allarmi
							!il contenuto degli array rappresenta i sottomessaggi attivi identificati dal valore dei bit
							!imAdvAlmMsgVal[.] contiene il bit che deve essere attivo all'interno del banco iAdvAlmMsgBnk per attivare l'allarme
							!se iAdvAlmMsgVal > 31 leggo da igCopiaAdvAlmMsgH
							IF iAdvAlmMsgVl > 31 THEN
								iDummy = igCopiaAdvAlmMsgH[iDummy2];
								iAdvAlmMsgVl = iAdvAlmMsgVl - 32; !in modo da non dover cambiare il BITAND
							END
							!se iAdvAlmMsgVal BITAND copiaAdvAlm > 0 almOn = true
							bBitVal = imExp2Bit[iAdvAlmMsgVl] BITAND iDummy;
							IF bBitVal > 0 THEN
								bAlmOn = True;
							END
						ELSE !altri allarmi
							IF iDummy = iAdvAlmMsgVl THEN
								bAlmOn = True;
							END !iDummy = iAdvAlmMsgVl
						END !iAdvAlmSrc = 5
					END !iAdvAlmMsgVl = -2
				ELSE !no Multimess -> attivare allarme
					bAlmOn = True;
				END !iAdvAlmMsgBnk <> -1
			END
			bAlmOn = bAlmOn OR bAlmOnComm;
			!Gestione allarme attivo
			IF bAlmOn = True THEN
				bmStsAlmFlag[imCategoriaAdvAlm[iCont]] = True;
			END
			bmAdvAlmOn[iCont] = bAlmOn;
			iNumAlm = hmAdvAlmNumRecTag[iCont]; !# dell'allarme Sia x SPC che per sistema ACK
			!Se attiva analisi di Pareto degli allarmi
			IF bSPCOn = True THEN
				IF bmAdvAlmOnPrec[iCont] <> bAlmOn THEN
					IF bAlmOn <> 0 THEN !Transizione da off a On
						!IF lbPLCCommDisable = True THEN
						!ErrLog("BankAdvAlmOn(.) iAdvAlmRecId = " + IntToStr(iCont) + " iNumAlm = " + IntToStr(iNumAlm));
						!END
						SPCParetoAlmSetCont(iCont);
					END
				END
			END
			!Gestione stato ack (iCont ha il puntatore al recNo)
			bAckPrec = GetCitectAlmAckState(iCont); !aggiorna lo "stato precedente" per seguire la filosofia di aggiornare gli stati precedenti al termine della scansione
			iDummy = bmAlmIsAckTemp[iNumAlm] AND bAckPrec;
			bmAlmServerAlmIsAckPrec[iCont] = bAckPrec;
			bmAlmIsAckTemp[iNumAlm] = iDummy;
			bmAlmServerAlmIsOnPrec[iCont] = GetCitectAlmActState(iCont);
		END !FOR iCont = ....
		!ErrLog("AlmManage 5");
		!copia degli stati ack[per i device] sulle strutture da utilizzare in modo che non risenta dell'elaborazione
		FOR iCont = 0 TO iNumAdvAlm DO
			iNumAlm = hmAdvAlmNumRecTag[iCont]; !# dell'allarme Sia x SPC che per sistema ACK
			bmAlmIsAck[iNumAlm] = bmAlmIsAckTemp[iNumAlm];
			iDummy = hmAdvAlmBFGCodeTag[iNumAlm]; !contiene il Recno dell'allarme
			iDummy2 = imCopiaAdvAlmPos[iDummy]; !banco della struttura imAckAdvAlmTemp in cui scrivere
			iAdvBit = imAdvAlmBit[iDummy];
			imAckAdvAlm[iDummy2] = SetBit(imAckAdvAlm[iDummy2], iAdvBit, bmAlmIsAck[iNumAlm]);
		END
		IF bEnTask96Resume = True THEN !almeno un aggiornamento della grafica
			bEnTask96Resume = False;
			LDWINTaskResume(96);
		END
		!lampeggio fulmine rosso
		!parte integrata da richiamare negli adv alm pel richiamo lampeggio fulmine rosso
		!ErrLog("bmStsAlmFlag[1] = " + IntToStr(bmStsAlmFlag[1]));
		IF iValidazione = False THEN
			bmStsAlm[3] = bmStsAlmFlag[3]; !categoria allarme attivo
			IF bmStsAlmFlagPrec[1] <> bmStsAlmFlag[1] THEN
				!ErrLog("Cambio stato allarmi primari: Prec = " + IntToStr(bmStsAlmFlagPrec[1]) + " " +  IntToStr(bmStsAlmFlag[1]));
				SELECT CASE bmStsAlmFlagPrec[1]
				CASE 0 !attivazione
					IF (bmStsAlm[1] = 0 OR bmStsAlm[1] = 4 OR bmStsAlm[1] = 2) THEN
						bmStsAlm[1] = 1;
					END
				CASE 1 !spegnimento
					IF bmStsAlm[2] = 0 THEN !fulmine verde se non ci sono allarmi secondari
						bmStsAlm[1] = 0;
					ELSE !se si ha il fulmine giallo deve scomparire il fulmine rosso
						bmStsAlm[1] = 4;
					END
				END SELECT
				!gestione scritte allarmi su template
				IF iLDWINCustomerID = 25 THEN !Green Mountain
					IF bmStsAlmFlag[1] = True THEN
						imScrTemplSt[3] = 1;
					ELSE
						imScrTemplSt[3] = -1;
					END
					LDWINTaskResume(35);
				END
				bmStsAlmFlagPrec[1] = bmStsAlmFlag[1];
			END
			
			SELECT CASE bmStsAlm[1]
			CASE 1 !fulmine rosso acceso
				imContLamp[1] = imContLamp[1] + 1;
				IF imContLamp[1] >= 0 THEN
					imContLamp[1] = 0;
					bmStsAlm[1] = 3;
				END
			CASE 3 !fulmine rosso spento
				imContLamp[1] = imContLamp[1] + 1;
				IF imContLamp[1] >= 0 THEN
					imContLamp[1] = 0;
					bmStsAlm[1] = 1;
				END
			END SELECT
			
			!parte integrata da richiamare negli adv alm pel richiamo lampeggio fulmine giallo
			IF bmStsAlmFlag[2] <> bmStsAlmFlagPrec[2] THEN
				SELECT CASE bmStsAlmFlagPrec[2]
				CASE 0 !attivazione
					IF bmStsAlm[2] = 0 THEN
						bmStsAlm[2] = 1;
						IF bmStsAlm[1] = 0 OR bmStsAlm[1] = 2 THEN !se non vi è allarme primario ma solo secondario, il fulmine verde deve scomparire oppure validazione
							bmStsAlm[1] = 4;
						END
					END
				CASE 1 !spegnimento
					bmStsAlm[2] = 0;
					IF bmStsAlm[1] = 4 THEN !fulmine verde se fulmine rosso scomparso no secondari
						bmStsAlm[1] = 0;
					END
				END SELECT
				!gestione scritte allarmi su template
				IF iLDWINCustomerID = 25 THEN !Green Mountain
					IF bmStsAlmFlag[2] = True THEN
						imScrTemplSt[4] = 1;
					ELSE
						imScrTemplSt[4] = -1;
					END
					LDWINTaskResume(35);
				END
				bmStsAlmFlagPrec[2] = bmStsAlmFlag[2];
			END
			
			imContLamp[2] = imContLamp[2] + 1;
			SELECT CASE bmStsAlm[2]
			CASE 1 !fulmine giallo spento
				imContLamp[2] = imContLamp[2] + 1;
				IF imContLamp[2] >= 0 THEN
					imContLamp[2] = 0;
					bmStsAlm[2] = 2;
				END
			CASE 2 !fulmine giallo acceso
				imContLamp[2] = imContLamp[2] + 1;
				IF imContLamp[2] >= 0 THEN
					imContLamp[2] = 0;
					bmStsAlm[2] = 1;
				END
			END SELECT
			!gestione scritte allarmi su template
			IF iLDWINCustomerID = 25 THEN !Green Mountain
				!evento allarmi HW
				bErrHw = AlarmActive(6);
				IF bErrHwPrec <> bErrHw THEN
					IF bErrHw = True THEN
						imScrTemplSt[5] = 1;
					ELSE
						imScrTemplSt[5] = -1; !invisibilità modellata dal valore -1
					END
					LDWINTaskResume(35);
					bErrHwPrec = bErrHw;
				END
			END
		ELSE
			IF LDWINShowBtn(45) = True THEN !forza l'icona di validazione attiva se si è nella modalità di validazione
				!ErrLog("IcoValidaz");
				bmStsAlm[1] = 2;
				bmStsAlm[2] = 0;
				bmStsAlm[3] = 0;
			END
		END !fine IF iValidazione
		!Lampeggio fulmine giallo (fine)
		!Calcolo del tempo di esecuzione: va inserito qui per dare più precisione al successibo calcolo dei timer del Lotto
		IF bmAlmManageSuspend = False THEN
			iDeltaTTaskAlm = SysTimeDelta(iTempoTaskAlm);
			iDeltaTTaskAlm = 500 - iDeltaTTaskAlm;
			IF iDeltaTTaskAlm < 50 THEN
				iDeltaTTaskAlm = 50;
			END
			SleepMS(iDeltaTTaskAlm);
		ELSE
			iPrecStatoMac = -1; !21141_2
			bmAlmManageSuspend = False;
			ErrLog("AlmManage Sospeso");
			TaskSuspend(hgLDWINTaskId[13]);
		END
		IF bBatchDCUDaEvento = True THEN
			IF GetBatchStatus() = True THEN
				igDCUBatchTime = imDCUBatchTimePrec + TimeCurrent() - igBatchStartTime;
			END
			IF bmMacchinaInMoto = True THEN
				igDCURunTime = igDCUBatchTime - igDCUStopTime;
			ELSE
				igDCUStopTime = igDCUBatchTime - igDCURunTime;
			END
		END
		!CalcBatchTime();
		CalcBatchTime(bSPCOn);
	END
	IF bgDeleteCitectAlms = False THEN
		ErrLog("-SalvataggioStato Allarmi-");
		!salvataggio stato allarmi su LDWINDAT.ini[salviamo solo gli allarmi utilizzati in lista allarmi]; dati ottenuti da alarmserver
		FOR iCont = 0 TO iNumAdvAlm DO
			!Bit 0 Stato di Attivazione
			!Bit 1 Stato di Fack
			!Bit 2 Stato di Ack
			iDummy = 0;
			iDummy = SetBit(iDummy, 0, GetCitectAlmActState(iCont));
			iDummy = SetBit(iDummy, 2, GetCitectAlmAckState(iCont));
			WndPutFileProfile("ALM", "AlmStatus_" + IntToStr(iCont), iDummy, sPercLDWINAlmInfo);
		END
		!salvataggio dei dati allarmi per la visualizzazione dei dati attivi[solo le posizioni utilizzate e salvare la dimensione dei dati in LDWINDAT.ini [ALM] AlmDspSize]
		!OCCHIO!!!-> in caso di moltissimi dati il sistema richiede molto tempo -> per il # massimo di dati [1000][15] il salvataggio dura circa 5 minuti[testato -> 20ms[su un pc lento[paddy]] per salvare una singola colonna -> 1000*15*20=300000ms=300s ]
		iDummy = 1;
		WHILE iDummy <> -1 DO
			IF sltAlmActDsp[iDummy][0] <> "" THEN !elemento valido
				sDummy = "";
				sVal = IntToStr(iDummy);
				sDummy2 = "";
				FOR iCont = 0 TO 14 DO
					sCont = sVal + "_" + IntToStr(iCont);
					SELECT CASE iCont
					CASE 0
						sDummy2 = sltAlmActDsp[iDummy][iCont];
						sCont2 = sCont; !in modo che la somma sotto, sia memorizzata "prima"
					CASE 1
						sDummy2 = sDummy2 + "@" + sltAlmActDsp[iDummy][iCont];
						WndPutFileProfile("ALM", "AlmDsp_" + sCont2, sDummy2, sPercLDWINAlmInfo);
						sDummy2 = "";
					CASE 2
						sDummy2 = sltAlmActDsp[iDummy][iCont];
						sCont2 = sCont; !in modo che la somma sotto, sia memorizzata "prima"
					CASE 3
						sDummy2 = sDummy2 + "@" + sltAlmActDsp[iDummy][iCont];
						WndPutFileProfile("ALM", "AlmDsp_" + sCont2, sDummy2, sPercLDWINAlmInfo);
						sDummy2 = "";
					CASE ELSE
						WndPutFileProfile("ALM", "AlmDsp_" + sCont, sltAlmActDsp[iDummy][iCont], sPercLDWINAlmInfo);
					END SELECT
					sDummy = sDummy + IntToStr(imDspAlmGenieColor[iDummy][iCont]) + "_";
				END
				sDummy = StrLeft(sDummy, StrLength(sDummy) - 1);!elimino l'ultimo "_"
				WndPutFileProfile("ALM", "AlmDspColor_" + sVal, sDummy, sPercLDWINAlmInfo);
				iDummy = iDummy + 1;
			ELSE
				WndPutFileProfile("ALM", "AlmDspSize", IntToStr(iDummy - 1), sPercLDWINAlmInfo); !salvataggio dimensione
				iDummy = -1; !fine ciclo
			END
		END
		ErrLog("-Fine SalvataggioStato Allarmi-");
		//ELSE
		//IF bmCitectAlmsDelOverride = False THEN
		//!cancella i dati dell'alarm server e alm info
		//DeleteFileIfExists(sPercLDWINAlmInfo);
		//CreaDeleteDir("D:\CitectData\Data\LDWIN_MAIN");
		//ErrLog("-Dati Citect Cancellati-");
		//END
	END
	LDWINTaskEnd(13);
END

//#I
//Determina se lo stato macchina è <> 3
//#F
INT	 
FUNCTION LDWINStMacNot3()
	RETURN bmMachStNot3;
END

//#I
//Debug
//#F
//FUNCTION SimulAlm(INT bEnable)
//	INT	 i;
//	
//	IF bEnable THEN
//		ciMaxAlarm = 0;
//	ELSE
//		ciMaxAlarm = ciMaxAlarmBackUp;
//	END
//	
//	FOR i = 0 TO (ciMaxAlarmBackUp - 1) DO
//		IF bgAlmFlagEnable[i] THEN
//			bgAlmFlag[i] = bEnable;
//		END !IF bgAlmFlagEnable[i]
//	END !FOR i=0 TO (icMaxAlarmBackUp-1)
//END

//#I
// Copies machine state from PLC to DCU
//#F
FUNCTION MachineStatePLCtoDCU()
	LDWINDefTask(109, "MachineStatePLCtoDCU", True);
	WHILE bgLDWINTaskOn[109] = True DO
		itPLCHMIStatoMac = itPLCStatoMac;
		Sleep(1);
	END
	LDWINTaskEnd(109);
END

STRING smConverTable[100] = "000", "001", "002", "003", "004", "005", "006", "007", "008", "009",
                            "010", "011", "012", "013", "014", "015", "016", "017", "018", "019", 
                            "020", "021", "022", "023", "024", "025", "026", "027", "028", "029", 
                            "030", "031", "032", "033", "034", "035", "036", "037", "038", "039", 
                            "040", "041", "042", "043", "044", "045", "046", "047", "048", "049", 
                            "050", "051", "052", "053", "054", "055", "056", "057", "058", "059", 
                            "060", "061", "062", "063", "064", "065", "066", "067", "068", "069", 
                            "070", "071", "072", "073", "074", "075", "076", "077", "078", "079", 
                            "080", "081", "082", "083", "084", "085", "086", "087", "088", "089", 
                            "090", "091", "092", "093", "094", "095", "096", "097", "098", "099";
//#I
//Esegue la seguente funzione:
//se iValue <  10 restituisce   "00iValue"
//se iValue <  100 restituisce  "0iValue"
//se iValue >= 100  restituisce "iValue", stessa cosa per gli eventuali # negativi
//IN: iValue # intero da convertire
//OUT: stringa formattata
//#F
STRING 
FUNCTION sConvert(INT iValue)
	STRING sTemp = "";
	INT	 bEnable = False;
	
	IF iValue > -1 THEN
		IF iValue < 100 THEN
			sTemp = smConverTable[iValue];
		ELSE
			bEnable = True;
		END
	ELSE
		IF iValue > -100 THEN
			sTemp = iValue:#000;
		ELSE
			bEnable = True;
		END
	END
	IF bEnable = True THEN
		sTemp = IntToStr(iValue);
	END
	RETURN sTemp;
END

STRING smConverShortTable[32] = "00", "01", "02", "03", "04", "05", "06", "07", "08", "09",
                                "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", 
                                "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", 
                                "30", "31";
                                
//#I
// Esegue la seguente funzione:
// iValue <  10  -> sTemp = "0iValue"
// IN: iValue # intero da convertire
// OUT: stringa formattata
//#F
STRING 
FUNCTION sConvertShort(INT iValue)
	IF iValue> -1 AND iValue < 32 THEN
		RETURN smConverShortTable[iValue];
	ELSE
		RETURN IntToStr(iValue);
	END
END

//#I
// Inizializza l'array igCategoriaAlm[.] con la categoria dell'allarme
// associato. La ricerca avviene tramite il campo Tag dell'allarme.
// Il valore dell'array può essere 1, 2, 3.
// Nel caso in cui vi siano problemi nell'individuare tutte le categorie,
// viene emesso un codice di errore 0x001.
//#F
INT	 
!FUNCTION InitCatAlm()
!FUNCTION InitCatAlm(INT bSPCOn)
FUNCTION InitCatAlm(INT bSPCOn, STRING sFileLDWININI)
	INT	 iIndex;
	INT	 iCat;
	INT	 iDummy;
	INT	 iPriv;
	INT	 iErrore = 0x000;
	INT	 hAlmRec = -1;
	STRING sCat;
	STRING sTag;
	STRING sDummy;
	STRING sDesc;
	STRING sNome; !testo dell'allarme
	
	imNumAdvAlm = 0;
	hmQueAlm = QueReopen(hmQueAlm, "QueAlm");
	hgQueAlmSel = QueReopen(hgQueAlmSel, "QueAlmSel");
	IF bgLDWINSetup = True THEN
		IF bSPCOn = True THEN
			!ParetoSPCAlmInit(); !inizializzazione del sistema di statistica Pareto per gli allarmi
			ParetoSPCAlmInit(0, sFileLDWININI); !inizializzazione del sistema di statistica Pareto per gli allarmi
		END
	END
	hgQueCatAdvAlm = QueReOpen(hgQueCatAdvAlm, "QueCatAdvAlm");
	DevModify("AdvAlmDef", "*", "*", sgLDWINPercProgetto[1] + "\advalm.dbf", -1);
	hAlmRec = DevOpen("AdvAlmDef", 0);
	IF hAlmRec > -1 THEN
		imNumAdvAlm = DevSize(hAlmRec);
		DevFirst(hAlmRec);
		FOR iIndex = 0 TO imNumAdvAlm - 1 DO
			sCat = DevGetField(hAlmRec, "CATEGORY");
			sTag = DevGetField(hAlmRec, "TAG");
			sltAlmTagDev[iIndex] = sTag;
			!IF sTag = "AL802" THEN
			!ErrLog("802 " + sTag);
			!END
			sDesc  = StrTrim(DevGetField(hAlmRec, "DESC"));
			sDummy = StrMid(sTag, 2, 3); !con il sistema di advalm con l'"_" non finziona più, devo leggere con strmid
			iDummy = StrToInt(sDummy);
			imAdvAlmTagRec[iDummy] = iIndex;
			sNome  = DevGetField(hAlmRec, "NAME");
			sDummy = DevGetField(hAlmRec, "PRIV");
			iPriv = StrToInt(sDummy);
			imAdvAlmPriv[iDummy] = iPriv;
			imAdvAlmRecPriv[iIndex] = iPriv;
			sNome = GetRptNomeAlm(sNome, sDesc);
			QueWrite(hmQueAlm, iIndex, sNome);
			!ricava la descrizione dell'allarme
			sDummy = StrTrim(GetRptNomeAlm("", sDesc));
			sltAlmNativeDescrDev[iIndex] = sDummy;
			IF sCat <> "" THEN
				iCat = StrToInt(StrTrim(sCat));
				sTag = StrLeft(sTag, 5); !tira via gli "_"
				QueWrite(hgQueCatAdvAlm, iCat, sTag); !memorizza la categoria del singolo advalm
				sDummy = (iIndex + 1):#00 + "   " + sTag + " " + sNome;
				iDummy = iIndex;
				QueWrite(hgQueAlmSel, iDummy, sDummy); !riempimento della coda di selezione configurazione digalm su pag. alm config
				imCategoriaAdvAlm[iIndex] = iCat;
			ELSE
				iErrore = 0x002;
			END
			DevNext(hAlmRec);
		END
		DevClose(hAlmRec);
		!ErrLog("AdvAlmREAD QueLength = " + IntToStr(QueLength(hgQueCatAdvAlm)));
	ELSE
		iErrore = 0x001;
	END
	RETURN iErrore;
END

GLOBAL
INT	 hgQueCatAdvAlm = -1; !handle alla coda delle categorie degli advanced alarms

//#I
//Fn di debug del sistema allarmi
//#F
FUNCTION CheckAlm()
	INT	 iRecord;
	INT	 iPriorita;
	STRING sStato;
	
	FOR iPriorita = 4 TO 6 DO
		iRecord = AlarmFirstPriRec(iPriorita, 0, -1);
		IF iRecord <> -1 THEN
			sStato = AlarmGetFieldRec(iRecord, "State");
			IF sStato = "ON" THEN
				sStato = AlarmGetFieldRec(iRecord, "Name");
				iPriorita = 6;
			END
		END
	END
END

//#I
// Inizializza puntatore a DIGALM.DBF o a ADVALM.DBF
//#F
FUNCTION InitAlmConfig()
	IF hgDigAlmDBF = -1 THEN
		DevModify("AdvAlmDef", "*", "*", sgLDWINPercProgetto[1] + "\advalm.dbf", -1);
		hgDigAlmDBF = DevOpen("AdvAlmDef", 0);
	END
	IF hgDigAlmDBF > -1 THEN !Verifica presenza DB
		DevSeek(hgDigAlmDBF, igAlmIdx);
		!GetHMIAlm(igAlmIdx);
		GetHMIAlm(igAlmIdx, hgDigAlmDBF);
	ELSE
		LDWINPromptSetString("DigAlm DB non trovato", 0);
		DevClose(hgDigAlmDBF);
	END
	MakeAlmDBFRptCfg();
END

//#I
//Rilascio del puntatore a DIGALM.DBF
//#F
FUNCTION CloseAlmConfig()
	IF hgDigAlmDBF > -1 THEN
		DevClose(hgDigAlmDBF);
		hgDigAlmDBF = -1;
	END
END

//#I
//Scorre l'indice degli allarmi nel database
//IN: iDirezione: avanti o indietro nella lista
//#F
FUNCTION PosAlmConfig(INT iDirezione)
	SELECT CASE iDirezione
	CASE lbProssimo
		IF igAlmIdx = imNumAdvAlm THEN !Verifica se hai raggiunto la fine del DB
			DevFirst(hgDigAlmDBF); !Punto all'inizio del DB
		ELSE
			DevNext(hgDigAlmDBF);
		END
	CASE lbPrecedente
		IF igAlmIdx = 1 THEN
			DevSeek(hgDigAlmDBF, imNumAdvAlm); !Punta alla fine del DB
		ELSE
			DevPrev(hgDigAlmDBF);
		END
	END SELECT
	igAlmIdx = DevRecNo(hgDigAlmDBF);
	!GetHMIAlm(igAlmIdx);
	GetHMIAlm(igAlmIdx, hgDigAlmDBF);
END

//#I
// Stampa lista allarmi con il seguente formato:
// 
// [Indice][Banco.Pos][Nome]
//
// [Indice]    = ALxx		dove xx = 00..47 + colore se attivo (rosso primario, giallo secondario, blu di tipo 3 
// [Banco.Pos] = Bnky.zz		dove  y = 0..2; zz = 00..47
// [Nome]      = Descrizione dell'allarme
//#F
FUNCTION PrintAlmSet()
	INT	 hFileReport;
	
	!apri il file
	hFileReport = FileOpen(sgNomeFileTempHTML, "w");
	IF hFileReport <> -1 THEN
		!Intestazione
		HTMLInizioFrame(lbRptCfgSistema, hFileReport);
		HTMLIntestazioneListaStampa(hFileReport, "@(LISTA ALLARMI)", 0, 0);
		HTMLCorpoConfigurazioneAllarmi(hFileReport);
		!Chiusura intestazione file HTML
		HTMLFineFrame(lbRptCfgSistema, hFileReport);
		FileClose(hFileReport);
		WebBrowserStampa(sgNomeFileTempHTML);
	ELSE
		LDWINPromptSetString("@(File temp. di stampa non aperto)", 0);
	END
END

INT	 bmDisableSalvaInitLDWIN;

//#I
// Salvataggio dati volatili di LDWIN
// ESPANDERE QUI se si vogliono salvare altri dati
//#F
INT	 
!FUNCTION SalvaInitLDWIN()
FUNCTION SalvaInitLDWIN(INT bSPCOn)
	INT	 iIdx;
	INT	 iCont;
	INT	 iCont1;
	INT	 iCont2;
	INT	 iCont3;
	INT	 iCont4;
	INT	 iErr;
	STRING sDummy;
	STRING sCont;
	STRING sCont1;
	STRING sCont2;
	STRING sPercLDWINDATINI = sgPercLDWINDATINI;
	INT	 iNumTeste = GetLDWININI2Int("MACHINE", lbStrHeadsNumber, "1") - 1;
	INT	 iNumGruppi = CalcNumGrp(iNumTeste + 1, 10) - 1;
	
	ErrLog("SalvainitLDWIN()");
	IF bmDisableSalvaInitLDWIN = False THEN
		!Indice progressivo rapporto
		WndPutFileProfile("LOG", "ReportIndex", IntToStr(GetReportIndex()), sPercLDWINDATINI);
		WndPutFileProfile("LOG", "ProdRptIndex", IntToStr(DspIdxRpt()), sPercLDWINDATINI);
		WndPutFileProfile("BATCH", "igDCURunTime", IntToStr(igDCURunTime), sPercLDWINDATINI);
		WndPutFileProfile("BATCH", "igDCUStopTime", IntToStr(igDCUStopTime), sPercLDWINDATINI);
		WndPutFileProfile("BATCH", "igDCUBatchTime", IntToStr(igDCUBatchTime), sPercLDWINDATINI);
		WndPutFileProfile("BATCH", "igDCUBatchTimePrec", IntToStr(imDCUBatchTimePrec), sPercLDWINDATINI);
		WndPutFileProfile("BATCH", "igNumCicliDaDCUPrec", IntToStr(igNumCicliDaDCUPrec), sPercLDWINDATINI);
		IF INIParamOn(lbCfgMyMultiLineCounters) = True THEN !21297
			FOR iCont = 0 TO igMaxMultiLineCounters - 1 DO
				sCont = IntToStr(iCont);
				WndPutFileProfile("BATCH", "igLDWINBuoniLinea" + sCont, IntToStr(igLDWINBuoniLinea[iCont]), sPercLDWINDATINI);
				WndPutFileProfile("BATCH", "igLDWINScartiLinea" + sCont, IntToStr(igLDWINScartiLinea[iCont]), sPercLDWINDATINI);
			END
		END
		!Contatori Hollister
		IF Get_bmMachSubTypeOptional(lbML, 0) = True THEN
			WndPutFileProfile("BATCH", "igLDWINMachNumStop", IntToStr(igLDWINMachNumStop), sPercLDWINDATINI);
		END
		IF bgUsaDCURunTime = False THEN
			!IF bgEmulAcc = False THEN
			!	sDummy = TagRead("igTimeStopLinea");
			!ELSE
				sDummy = IntToStr(igTimeStopLinea);
			!END
			WndPutFileProfile("BATCH", "igTimeStopLinea", sDummy, sPercLDWINDATINI);
			!IF bgEmulAcc = False THEN
			!	sDummy = TagRead("igTimeStopMac");
			!ELSE
				sDummy = IntToStr(igTimeStopMac);
			!END
			WndPutFileProfile("BATCH", "igTimeStopMac", sDummy, sPercLDWINDATINI);
		END
		IF bgBatchDCUDaEvento = False THEN !Per le vecchie emulazioni: da usare con i Jets V1
			!IF bgEmulAcc = False THEN
			!	sDummy = TagRead("itBatchStartT");
			!ELSE
				sDummy = IntToStr(itBatchStartT);
			!END
			WndPutFileProfile("BATCH", "itBatchStartT", sDummy, sPercLDWINDATINI);
//			IF bgEmulAcc = False THEN
//				sDummy = TagRead("itTimeLineRun");
//				WndPutFileProfile("BATCH", "itTimeLineRun", sDummy, sPercLDWINDATINI);
//			END
		//END
		!IF bgEmulAcc = True THEN
			IF INIParamOn(lbCfgDataStatEn) = True THEN !se è attiva la pagina delle statistiche...
				sDummy = IntToStr(igTimeLineRun);
				WndPutFileProfile("BATCH", "itTimeLineRun", sDummy, sPercLDWINDATINI);
			END
		!END
		END
		sDummy = IntToStr(igTimeRdyMac);
		WndPutFileProfile("BATCH", "igTimeRdyMac", sDummy, sPercLDWINDATINI);
		!conformi di macchina
		WndPutFileProfile("BATCH", "MAINConforming", Get_LDWINProcBuoni(), sPercLDWINDATINI);
		!non conformi macchina
		WndPutFileProfile("BATCH", "MAINNonConforming", Get_LDWINProcScarti(), sPercLDWINDATINI);
		WndPutFileProfile("Passwords", "sgDataAttAvviso", sgDataAttAvviso, sPercLDWINDATINI);
		WndPutFileProfile("HMI", "rgSogliaDCU", RealToStr(rgSogliaDCU, 5, igSCADACfgRealPrec[lbCfgMySoglia0]), sPercLDWINDATINI);
		WndPutFileProfile("HMI", "CalcValSogliaDCU_1", CalcValSogliaDCU(1), sPercLDWINDATINI);
		WndPutFileProfile("HMI", "CalcValSogliaDCU_2", CalcValSogliaDCU(2), sPercLDWINDATINI);
		IF INIParamOn(lbCfgDataStatEn) = 1 THEN
			WndPutFileProfile("BATCH", "rgAvail", RealToStr(rgAvail,4, 1), sPercLDWINDATINI);
			WndPutFileProfile("BATCH", "rgQual", RealToStr(rgQual,4, 1), sPercLDWINDATINI);
			WndPutFileProfile("BATCH", "rgEqEff", RealToStr(rgEqEff,4, 1), sPercLDWINDATINI);
			WndPutFileProfile("BATCH", "rgEffMac", RealToStr(rgEffMac,4, 1), sPercLDWINDATINI);
			WndPutFileProfile("BATCH", "rgUsoMac", RealToStr(rgUsoMac,4, 1), sPercLDWINDATINI);
		END
		!SalvaDataRisultTest();
		SalvaDataRisultTest(iNumTeste, sPercLDWINDATINI);
		SalvaSPCHistINI(sPercLDWINDATINI);
		FOR iCont = 0 TO 1 DO
			sCont = IntToStr(iCont);
			sCont = "rgStatisticaSPC_" + sCont + "_";
			FOR iCont1 = 0 TO lbNumStatArray - 1 DO
				sCont1 = IntToStr(iCont1) + "_";
				!FOR iCont2 = 0 TO 99 DO
				iCont3 = 0;
				FOR iCont2 = 0 TO iNumGruppi DO
					sCont2 = IntToStr(iCont2);
					sDummy = "";
					FOR iCont4 = 0 TO 8 DO
						sDummy = sDummy + StrTrim(RealToStr(rgStatisticaSPC[iCont][iCont1][iCont3], StatLen, StatPrec)) + "_";
						iCont3 = iCont3 + 1;
					END
					sDummy = sDummy + StrTrim(RealToStr(rgStatisticaSPC[iCont][iCont1][iCont3], StatLen, StatPrec));
					iCont3 = iCont3 + 1;
					WndPutFileProfile("BATCH", sCont + sCont1 + sCont2, sDummy, sPercLDWINDATINI);
				END
			END
		END
		FOR iCont = 0 TO iNumTeste DO
			sCont = IntToStr(iCont) + "_";
			FOR iCont1 = 0 TO lbNumStatArray - 1 DO
				sCont1 = sCont + IntToStr(iCont1);
				!Modello LD [Prima lettura]
				WndPutFileProfile("BATCH", "rgStatModelloPrLettLD_" + sCont1, StrTrim(RealToStr(rgStatModelloPrLettLD[iCont][iCont1], StatLen, StatPrec)), sPercLDWINDATINI); !1
				!Modello LD [Delta]
				WndPutFileProfile("BATCH", "rgStatModelloDeltaLD_" + sCont1, StrTrim(RealToStr(rgStatModelloDeltaLD[iCont][iCont1], StatLen, StatPrec)), sPercLDWINDATINI); !1
			END
		END
		FOR iCont1 = 0 TO lbMaxIdStatistiche - 1 DO !Tipo Statistica
			sCont1 = IntToStr(iCont1);
			iCont3 = 0;
			FOR iCont = 0 TO iNumGruppi DO !# Testa
				sCont = "_" + IntToStr(iCont);
				sCont = sCont1 + sCont;
				sDummy = "";
				FOR iCont2 = 0 TO 8 DO
					sDummy = sDummy + IntToStr(GetStatNumTest(iCont1, iCont3)) + "_";
					iCont3 = iCont3 + 1;
				END
				sDummy = sDummy + IntToStr(GetStatNumTest(iCont1, iCont3));
				iCont3 = iCont3 + 1;
				WndPutFileProfile("BATCH", "igNumeroTest1_" + sCont, sDummy, sPercLDWINDATINI);
			END
		END
		IF hgProcVI > -1 THEN
			!Gestione salvataggio contatori VI
			FOR iCont = 0 TO lbNumTelecamereVI - 1 DO
				sCont = IntToStr(iCont);
				WndPutFileProfile("BATCH", "igNumScartiTLC_" + sCont, IntToStr(igNumScartiTLC[iCont]), sPercLDWINDATINI);
				WndPutFileProfile("BATCH", "igNumBuoniTLC_" + sCont, IntToStr(igNumBuoniTLC[iCont]), sPercLDWINDATINI);
				WndPutFileProfile("BATCH", "rgNumBuoniPercTLC_" + sCont, StrTrim(RealToStr(rgNumBuoniPercTLC[iCont], 6, 1)), sPercLDWINDATINI);
				WndPutFileProfile("BATCH", "rgNumScartiPercTLC_" + sCont, StrTrim(RealToStr(rgNumScartiPercTLC[iCont], 6, 1)), sPercLDWINDATINI);
			END
		END
		IF Get_RadioButtonFormSelVal(75) = False THEN !calcolo interno si suppone che i valori minimi e massimi siano memorizzati dalla DCU con valori ritentivi
			WndPutFileProfile("LDWIN", "rgStatPressLinea_0", StrTrim(RealToStr(rgStatPressLinea[0], igCampoContDimNumReale[lbCfgSensPressioneLinea], igSCADACfgRealPrec[lbCfgSensPressioneLinea])), sPercLDWINDATINI);
			WndPutFileProfile("LDWIN", "rgStatPressLinea_1", StrTrim(RealToStr(rgStatPressLinea[1], igCampoContDimNumReale[lbCfgSensPressioneLinea], igSCADACfgRealPrec[lbCfgSensPressioneLinea])), sPercLDWINDATINI);
			WndPutFileProfile("LDWIN", "rgStatPressLinea_2", StrTrim(RealToStr(rgStatPressLinea[2], igCampoContDimNumReale[lbCfgSensPressioneLinea], igSCADACfgRealPrec[lbCfgSensPressioneLinea])), sPercLDWINDATINI);
		END
		WndPutFileProfile("LDWIN", "sgContAssente", sgContAssente, sPercLDWINDATINI);
		WndPutFileProfile("LDWIN", "sgContBuono", sgContBuono, sPercLDWINDATINI);
		WndPutFileProfile("LDWIN", "sgContScarto", sgContScarto, sPercLDWINDATINI);
		WndPutFileProfile("BATCH", "rtMachPerf", StrTrim(RealToStr(rltMachPerf,6, 1)), sPercLDWINDATINI);
		!contatori di processo
		FOR iIdx = 0 TO lbNumProcessi - 1 DO
			sDummy = IntToStr(iIdx);
			WndPutFileProfile("BATCH", "Conforming" + sDummy, IntToStr(igLDWINBuoni[iIdx]), sPercLDWINDATINI);
			WndPutFileProfile("BATCH", "NonConforming" + sDummy, IntToStr(igLDWINScarti[iIdx]), sPercLDWINDATINI);
			WndPutFileProfile("BATCH", "NotTestedProc" + sDummy, IntToStr(igProcNonTestati[iIdx]), sPercLDWINDATINI);
			WndPutFileProfile("BATCH", "NotTestedProcPrec" + sDummy, IntToStr(igProcNonTestatiPrec[iIdx]), sPercLDWINDATINI);
			WndPutFileProfile("LASER", "igRecLProPressuresSel" + sDummy, IntToStr(igRecLProPressuresSel[iIdx]), sPercLDWINDATINI);
		END
		IF bSPCOn = True THEN
			SPCParetoAlmSalvaStat(sPercLDWINDATINI);
		END
		!LDWINVelMediaSaveINI();
		LDWINVelMediaSaveINI(sPercLDWINDATINI);
		!PLCCountersSave(); !19170
		PLCCountersSave(sPercLDWINDATINI); !19170
	END
	ErrLog("SalvaInitLDWIN() Ok Disa: " + smBool2Str[bmDisableSalvaInitLDWIN]);
	RETURN iErr;
END

//#I
//Imposta il valore del boolean
//IN: iVal: valore da impostare
//#F
FUNCTION Set_DisableSalvaInitLDWIN(INT iVal)
	bmDisableSalvaInitLDWIN = iVal;
END

//#I
// Caricamento dati volatili di LDWIN
// ESPANDERE QUI se si vogliono caricare altri dati
// IN: bSPCOn: SPC Attivo
//     sFileLDWININI: percorso di LDWIN.INI
//     sPercLDWINDATINI: percorso di LDWINDAT.INI
//#F
INT	 
!FUNCTION CaricaInitLDWIN(INT bSPCOn);
FUNCTION CaricaInitLDWIN(INT bSPCOn, STRING sFileLDWININI, STRING sPercLDWINDATINI);
	INT	 iErrore;
	INT	 iCont;
	INT	 iCont1;
	INT	 iCont2;
	INT	 iCont4;
	INT	 iCont3;
	INT	 iValQue;
	INT	 hQue = -1;
	INT	 iErr;
	STRING sVal;
	STRING sCont;
	STRING sCont1;
	STRING sValQue;
	STRING sDummy;
	STRING sKey;
	INT	 iNumTeste = GetLDWININI2Int("MACHINE", lbStrHeadsNumber, "1", sFileLDWININI) - 1;
	INT	 iNumGruppi = CalcNumGrp(iNumTeste + 1, 10) - 1;
	REAL	 rValQue;
	
	ErrLog("CaricaInitLDWIN()");
	!ErrSet(1);
	Set_bLDWINDATLoadingOn(True);
	!Sistema multiprocesso
	!igMyContSelezProc[hgProcMain] = GetLDWININI2Int("RECIPE", sgProcActRecINIKey[hgProcMain], "1");
	GetMyContSelezProcFromINI(hgProcMain);
	!igMyContSelezProc[hgProcAM] = GetLDWININI2Int("RECIPE", sgProcActRecINIKey[hgProcAM], "-1");
	GetMyContSelezProcFromINI(hgProcAM);
	LoadLDGraphIni(sFileLDWININI);
	!Indice progressivo Report
	SetReportIndex(WndGetFileProfile("LOG", "ReportIndex", "0", sPercLDWINDATINI));
	sVal = WndGetFileProfile("LOG", "ProdRptIndex", "0", sPercLDWINDATINI);
	SetIdxRepProd(StrToInt(sVal)); !00.1
	!runtime in ms proveniente da DCU
	igDCURunTime = GetLDWININI2Int("BATCH", "igDCURunTime", "0", sPercLDWINDATINI);
	igDCUStopTime = GetLDWININI2Int("BATCH", "igDCUStopTime", "0", sPercLDWINDATINI);
	igDCUBatchTime = GetLDWININI2Int("BATCH", "igDCUBatchTime", "0", sPercLDWINDATINI);
	imDCUBatchTimePrec = GetLDWININI2Int("BATCH", "imDCUBatchTimePrec", "0", sPercLDWINDATINI);
	igNumCicliDaDCUPrec = GetLDWININI2Int("BATCH", "igNumCicliDaDCUPrec", "0", sPercLDWINDATINI);
	igBatchStartTime = GetLDWININI2Int("BATCH", "iTime", "0", sPercLDWINDATINI);
	!Contatori Hollister
	IF Get_bmMachSubTypeOptional(lbML, 0) = True THEN
		igLDWINMachNumStop = GetLDWININI2Int("BATCH", "igLDWINMachNumStop", "0", sPercLDWINDATINI);
	END
//	IF bgEmulAcc = False THEN
//		sVal = WndGetFileProfile("BATCH", "igTimeStopLinea", "0", sPercLDWINDATINI);
//		TagWrite("igTimeStopLinea", sVal);
//		SleepMS(100);
//		IF bgUsaDCURunTime = False THEN
//			AccControl("Stop_Linea_ACC", 5);
//			sVal = WndGetFileProfile("BATCH", "igTimeStopMac", "0", sPercLDWINDATINI);
//			TagWrite("igTimeStopMac", sVal);
//			SleepMS(100);
//		END
//		IF bgBatchDCUDaEvento = False THEN
//			AccControl("Stop_Mac_ACC", 5);
//			sVal = WndGetFileProfile("BATCH", "itBatchStartT", "0", sPercLDWINDATINI);
//			TagWrite("itBatchStartT", sVal);
//			SleepMS(100);
//			AccControl("Batch_Time_ACC", 5);
//			sVal = WndGetFileProfile("BATCH", "itTimeLineRun", "0", sPercLDWINDATINI);
//			SleepMS(100);
//			AccControl("Run_Linea_ACC", 5);
//		END
//	END
	igTimeRdyMac = GetLDWININI2Int("BATCH", "igTimeRdyMac", "0", sPercLDWINDATINI);
	!Buoni multiprocesso
	sVal = WndGetFileProfile("BATCH", "MAINConforming", "0", sPercLDWINDATINI);
	Set_LDWINProcBuoni(StrToInt(sVal));
	!scarti multiprocesso
	sVal = WndGetFileProfile("BATCH", "MAINNonConforming", "0", sPercLDWINDATINI);
	Set_LDWINProcScarti(StrToInt(sVal));
	sgDataAttAvviso = WndGetFileProfile("Passwords", "sgDataAttAvviso", "10/02/05", sPercLDWINDATINI);
	!soglie da visualizzare
	Set_ValSogliaDCU("rgSogliaDCU", 0, sPercLDWINDATINI);
	Set_ValSogliaDCU("CalcValSogliaDCU_1", 1, sPercLDWINDATINI);
	Set_ValSogliaDCU("CalcValSogliaDCU_2", 2, sPercLDWINDATINI);
	IF INIParamOn(lbCfgDataStatEn) = 1 THEN !se è attiva la pagina delle statistiche...
		rgAvail = GetLDWININI2Real("BATCH", "rgAvail", "0.0", sPercLDWINDATINI);
		rgQual = GetLDWININI2Real("BATCH", "rgQual", "0.0", sPercLDWINDATINI);
		rgEqEff = GetLDWININI2Real("BATCH", "rgEqEff", "0.0", sPercLDWINDATINI);
		rgEffMac = GetLDWININI2Real("BATCH", "rgEffMac", "0.0", sPercLDWINDATINI);
		rgUsoMac = GetLDWININI2Real("BATCH", "rgUsoMac", "0.0", sPercLDWINDATINI);
	END
	!CaricaDataRisultTest();
	CaricaDataRisultTest(iNumTeste, sPercLDWINDATINI);
	InitStatFmt(); !Inizializza la visualizzazione delle statistiche
	CaricaStatSPCHistINI(sPercLDWINDATINI);
	FOR iCont = 0 TO 1 DO
		sCont = IntToStr(iCont);
		!LVDT
		!SPC
		sCont = "rgStatisticaSPC_" + sCont + "_";
		FOR iCont1 = 0 TO lbNumStatArray - 1 DO
			sCont1 = IntToStr(iCont1) + "_";
			iCont3 = 0;
			FOR iCont2 = 0 TO iNumGruppi DO
				sKey = sCont + sCont1 + IntToStr(iCont2);
				sDummy = WndGetFileProfile("BATCH", sKey, "0.0_0.0_0.0_0.0_0.0_0.0_0.0_0.0_0.0_0.0", sPercLDWINDATINI);
				hQue = StrSplitInQue(sDummy, "_", False);
				IF hQue <> -1 THEN
					FOR iCont4 = 0 TO 9 DO
						iValQue = iCont4;
						iErr = QuePeek(hQue, iValQue, sValQue, 16); !sValQue contiene l'informazione
						IF iErr = 0 THEN
							rValQue = StrToReal(sValQue);
						ELSE !errore o offset non trovato
							rValQue = 0.0;
						END
						rgStatisticaSPC[iCont][iCont1][iCont3] = rValQue; !1
						//IF (iCont = 0 AND iCont1 = 0) OR (iCont = 1 AND iCont1 = lbNumStatArray - 1) THEN
						//ErrLog("rgStatisticaSPC[" + IntToStr(iCont) + "][" + IntToStr(iCont1) + "][" + IntToStr(iCont3)+ "]=" + StrTrim(RealToStr(rgStatisticaSPC[iCont][iCont1][iCont3], StatLen, StatPrec)));
						//END
						iCont3 = iCont3 + 1;
					END
				END
				QueClose(hQue);
			END
		END
	END
	FOR iCont = 0 TO iNumTeste DO
		sCont = IntToStr(iCont) + "_";
		FOR iCont1 = 0 TO lbNumStatArray - 1 DO
			sCont1 = sCont + IntToStr(iCont1);
			!modello LD [Prima lettura]
			rgStatModelloPrLettLD[iCont][iCont1] = GetLDWININI2Real("BATCH", "rgStatModelloPrLettLD_" + sCont1, "0.0", sPercLDWINDATINI);
			!modello LD [Delta]
			rgStatModelloDeltaLD[iCont][iCont1] = GetLDWININI2Real("BATCH", "rgStatModelloDeltaLD_" + sCont1, "0.0", sPercLDWINDATINI);
		END
	END
	FOR iCont1 = 0 TO lbMaxIdStatistiche - 1 DO !Tipo Statistica
		sCont1 = IntToStr(iCont1) + "_";
		iCont3 = 0;
		FOR iCont2 = 0 TO iNumGruppi DO
			sKey = "igNumeroTest1_" + sCont1 + IntToStr(iCont2);
			sDummy = WndGetFileProfile("BATCH", sKey, "0_0_0_0_0_0_0_0_0_0", sPercLDWINDATINI);
			hQue = StrSplitInQue(sDummy, "_", False);
			IF hQue <> -1 THEN
				FOR iCont4 = 0 TO 9 DO
					iValQue = iCont4;
					iErr = QuePeek(hQue, iValQue, sValQue, 16); !sValQue contiene l'informazione
					IF iErr = 0 THEN
						iValQue = StrToInt(sValQue);
					ELSE !errore o offset non trovato
						iValQue = 0;
					END
					//IF iCont1 = 0 OR iCont1 = 14 THEN
					//ErrLog("SetStatNumTest(" + IntToStr(iCont1) + "," + IntToStr(iCont3) + ")=" + sValQue);
					//END
					SetStatNumTest(iCont1, iValQue, iCont3); !1
					iCont3 = iCont3 + 1;
				END
				QueClose(hQue);
			END
		END
	END
	IF hgProcVI > -1 THEN
		!Gestione caricamento contatori VI
		FOR iCont = 0 TO lbNumTelecamereVI - 1 DO
			sCont = IntToStr(iCont);
			igNumScartiTLC[iCont] = GetLDWININI2Int("BATCH", "igNumScartiTLC_" + sCont, "0", sPercLDWINDATINI);
			igNumBuoniTLC[iCont] =  GetLDWININI2Int("BATCH", "igNumBuoniTLC_" + sCont, "0", sPercLDWINDATINI);
			rgNumBuoniPercTLC[iCont] = GetLDWININI2Real("BATCH", "rgNumBuoniPercTLC_" + sCont, "0.0", sPercLDWINDATINI);
			rgNumScartiPercTLC[iCont] = GetLDWININI2Real("BATCH", "rgNumScartiPercTLC_" + sCont, "0.0", sPercLDWINDATINI);
		END
	END
	sgContAssente = WndGetFileProfile("LDWIN", "sgContAssente", "0", sPercLDWINDATINI);
	sgContBuono = WndGetFileProfile("LDWIN", "sgContBuono", "1", sPercLDWINDATINI);
	sgContScarto = WndGetFileProfile("LDWIN", "sgContScarto", "1", sPercLDWINDATINI);
	IF NOT (sgContAssente = "1") AND NOT (sgContAssente = "0") THEN !In caso di problemi con LDWIN.DAT forzo al valore di default
		sgContAssente = "0";
	END
	IF NOT (sgContBuono = "1") AND NOT (sgContBuono = "0") THEN !In caso di problemi con LDWIN.DAT forza al valore di default
		sgContBuono = "1";
	END
	IF NOT (sgContScarto = "1") AND NOT (sgContScarto = "0") THEN !In caso di problemi con LDWIN.DAT forza al valore di default
		sgContScarto = "1";
	END
	IF Get_RadioButtonFormSelVal(75) = False THEN !calcolo interno si suppone che i valori minimi e massimi siano memorizzati dalla DCU con valori ritentivi
		rgStatPressLinea[0] = GetLDWININI2Real("LDWIN", "rgStatPressLinea_0", "0.00", sPercLDWINDATINI);
		rgStatPressLinea[1] = GetLDWININI2Real("LDWIN", "rgStatPressLinea_1", "0.00", sPercLDWINDATINI);
		rgStatPressLinea[2] = GetLDWININI2Real("LDWIN", "rgStatPressLinea_2", "0.00", sPercLDWINDATINI);
	END
	rltMachPerf = GetLDWININI2Real("BATCH", "rtMachPerf", "0.0", sPercLDWINDATINI);
	IF bSPCOn = True THEN
		SPCParetoAlmCaricaStat(sPercLDWINDATINI);
	END
	iErrore = IsError();
	IF iErrore <> 0 THEN
		IF iErrore <> 12 AND iErrore <> 8 THEN !il <>12 serve per impedire che, se LDWIN parte senza PLC non detoni a causa di problemi di tag da debuggare poi da interfaccia
			ErrLog("CaricaInitLDWIN() Errore lettura: Reinizializzazione LDWIN.DAT: " + ErrMsg(iErrore));
			!SalvaInitLDWIN();
			SalvaInitLDWIN(bSPCOn);
		ELSE
			Message("CaricaInitLDWIN", ErrMsg(iErrore) + " Err: " + IntToStr(iErrore), 48);
			iErrore = 0;
		END
	END
	!LDWINVelMediaLoadINI();
	LDWINVelMediaLoadINI(sPercLDWINDATINI);
	IF WndGetFileProfile("LDWIN", "GenericChallengeMode", "0", sFileLDWININI) = "1" THEN
		ChallengeInit();
	END
	!ErrSet(0);
	Set_bLDWINDATLoadingOn(False);
	RETURN iErrore;
END

GLOBAL
INT	 bgResetUpSendMailbox; !True: invia il comando di Mailbox

//#I
//lancia il reset di tutti gli allarmi attivi:
//se alla fine del processo non sono presenti allarmi
//allora attiva il laser
//IN: iModo: 0: btn su HMI 1: btn fisico TODO: se da ext si invoca il reset, come vanno gestito il privilegio della funzionalità?
//OUT: 0 se OK -1 su errore
//#F
FUNCTION ResetAllarmiUp(INT iModo = 0)
	INT	 iCont;
	
	LDWINSetDisBtn(100, True);
	LDWINSetDisBtn(152, True);
	igVitContSocket[1] = 0;
	IF iModo = 0 THEN
		WrRptAT("@(Reset Allarme)", "");
		IF INIParamOn(lbCfgJetsSupport) = True THEN
			TagWrite("btPLCResetAllarme", "0", 0, True, "LDWIN");
		END
	END
	Set_bHMIDisBtn(1, True);
	LDWINCommAlmFailReset();
	!Se la macchina NON ha solamente il VI ed è una macchina IIBR oppure VIBE
	IF bgResetUpSendMailbox = True THEN
		!Invio comando reset allarmi al RT
		IF MailBoxCMDOn() = False THEN
			DCUMailboxCMD(12, 0, 0, True);
		END
	END
	IF INIParamOn(lbCfgVITattileEn) = True THEN !se VI attivo
		FOR iCont = 0 TO lbNumTelecamereVI DO
			bmPLCVIAlm[iCont] = False;
		END
		IF btPLCPresenzaBetaway = True THEN
			SendCmdVI(1);
		END
		igVitContSocket[2] = 0;
	END
	!SPC Riassuntivo e istogramma
	IF INIParamOn(lbCfgMySPCOn) = True THEN !se attivo SPC
		HSTResetBuffer(1); !per resettare gli eventuali allarmi di SPC prova a ricalcolare i Cp vari
	END
	IF INIParamOn(lbCfgMyCTPSupport) = True THEN !CTP attivo
		TagWrite("itHMI_CTPAlmReset", "0");
	END
	IF INIParamOn(lbCfgMyLBLSupport) = True THEN !22171 LBL
		TagWrite("itHMI_LBLAlmReset", "0");
	END
	IF igLDWINCustomerID = 26 THEN !ACK Automatico degli allarmi (Lanfranchi)
		AlarmAck(2, 1, "LDWIN");
		AlarmAck(2, 2, "LDWIN");
		AlarmAck(2, 255, "LDWIN");
	END
	Set_bHMIDisBtn(1, False);
	LDWINSetDisBtn(100, False);
	LDWINSetDisBtn(152, False);
END

//#I
//Gestisce la proprietà "Down" del bottone di reset allarmi
//#F
FUNCTION ResetAllarmiDown()
	LDWINSetDisBtn(100, True);
	LDWINSetDisBtn(152, True);
	TagWrite("btPLCResetAllarme", "1", 0, True, "LDWIN");
	IF igLDWINNumLPro > -1 THEN
		SendCmdLOALpro(3);
	END
	IF INIParamOn(lbCfgMyCTPSupport) = True THEN !CTP attivo
		TagWrite("itHMI_CTPAlmReset", "1", 0, True, "LDWIN");
	END
	IF INIParamOn(lbCfgMyLBLSupport) = True THEN !22171 LBL
		TagWrite("itHMI_LBLAlmReset", "1", 0, True, "LDWIN");
	END
	LDWINSetDisBtn(100, False);
	LDWINSetDisBtn(152, False);
END

//#I
//Test reset allarmi
//iNumVolte: # di volte che si effettua il reset
//#F
FUNCTION ResetAlmTest(INT iNumVolte = 2)
	INT	 iCont;
	
	FOR iCont = 0 TO iNumVolte - 1 DO
		ResetAllarmiDown();
		ResetAllarmiUp();
	END
END

//#I
//Debug Attiva tutti gli allarmi o una parte
//IN: iNumAlms: # di allarmi da attivare
//#F
//FUNCTION AttivaAllAlarms(INT iNumAlms = lbNumAlmTot)
//	INT	 i;
//	
//	DevModify("AdvAlmDef", "*", "*", sgLDWINPercProgetto[1] + "\advalm.dbf", -1);
//	hgDigAlmDBF = DevOpen("AdvAlmDef", 0);
//	IF hgDigAlmDBF > -1 THEN !Verifica presenza DB
//		DevFirst(hgDigAlmDBF);
//		FOR i = 0 TO iNumAlms - 1 DO
//			bgAlmFlagEnable[i] = 1;
//			SCADACfgParAlmWrite(i, 0);
//			DevNext(hgDigAlmDBF);
//		END
//		IF iNumAlms < lbNumAlmTot THEN
//			FOR i = iNumAlms TO lbNumAlmTot - 1 DO
//				bgAlmFlagEnable[i] = 0;
//				SCADACfgParAlmWrite(i, 0);
//				DevNext(hgDigAlmDBF);
//			END
//		END
//		DevClose(hgDigAlmDBF);
//	END
//END

//#I
// Data - 11/28/2008 9:23
// Autore:  CP Sistemi
//
// Descrizione : Inizializza a false tutti gli allarmi ( PLC e RT )
//#F
//FUNCTION InitAllarmiRT()
//	INT	 i;
//	
//	FOR i = 0 TO lbNumAlmRT - 1 DO
//		bgAlmFlagRT[i] = 0;
//	END
//END

//#I
//Pulisce i flag del sistema di allarmi PLC
//#F
//FUNCTION InitAllarmiPLC()
//	INT	 i;
//	
//	FOR i = 0 TO lbNumAlmPLC - 1 DO
//		bgAlmFlag[i] = 0;
//	END
//END

INT	 hmANLastAlm = -1;
INT	 hmANLastAlm2 = -1; !il sistema di visualizzazione di m...da di Citect accetta AN fino a 3016. Ovviamente
                          !capita che l'AN che tra l'altro non posso cambiare, va a > uso uno di risreva nella speranza sia più basso

//#I
//Visualizzazione formattata dell'allarme attivo
//IN: hAN AN della fx su cui visualizzare il risultato della fn
//#F
FUNCTION ProcDspLastAlarm()
	STRING sPagPrev = "";
	STRING sDummy = ParameterGet("Animator", "MaxAn", "1024");
	INT	 iPagInfo;
	!INT	 iMaxAn;
	INT	 iMaxAn = StrToInt(sDummy);
	INT	 hAN = -1;
	INT	 hLastAlarmFmt;
	
	!ErrLog("-ProcDspLastAlarm- ");
	!iMaxAn = StrToInt(sDummy);
	sDummy = ParameterGet("Alarm", "LastAlarmFmt", "{TIME,9}{TAG,5} {NAME,65} {DESC,20}");
	hLastAlarmFmt = FmtOpen("LastAlarmFmt", sDummy, 1);
	hmANLastAlm = -1;
	LDWINDefTask(76, "ProcDspLastAlarm");
	WHILE bgLDWINTaskOn[76] = True DO
		IF sPagPrev <> sgNomePaginaAttiva THEN
			hmANLastAlm = -1;
			hmANLastAlm2 = -1;
			hAN = -1;
			sPagPrev = sgNomePaginaAttiva;
			iPagInfo = 0;
		END
		IF hAN > -1 THEN
			IF iPagInfo = 0 THEN !per farlo una sola volta
				AlarmSetInfo(hAN, 5, IntToStr(hLastAlarmFmt));
				iPagInfo = 1;
			END
			IF iPagInfo = 1 THEN
				AlarmDspLast(hAN, 1, 11);
			END
			SleepMS(500);
		ELSE
			IF hmANLastAlm > -1 AND hmANLastAlm < iMaxAn THEN
				hAN = hmANLastAlm;
			ELSE
				IF hmANLastAlm2 > -1 AND hmANLastAlm2 < iMaxAn THEN
					hAN = hmANLastAlm2;
				END
			END
			SleepMS(250);
		END
	END
	LDWINTaskEnd(76);
	!ErrLog("-ProcDspLastAlarm- Fine");
END

//#I
//Registra l'AN per la gestione del last alm
//#F
FUNCTION LastAlmANReg(INT hAN)
	IF hAN > -1 THEN
		hmANLastAlm = hAN;
	END
END

//#I
//Registra l'AN per la gestione del last alm
//#F
FUNCTION LastAlmANReg2(INT hAN)
	IF hAN > -1 THEN
		hmANLastAlm2 = hAN;
	END
END

//#I
//Legge un campo del database _DIGALM
//IN: iIdxAlm, sCampo nome campo database
//OUT: STRING valore stringa del campo
//#F
STRING 
FUNCTION LeggiCampoAlm(INT iIdxAlm, STRING sCampo)
	STRING sVal;
	
	sVal = DevGetField(hgDigAlmDBF, sCampo);
	RETURN sVal;
END

//#I
//Test Array index
//#F
FUNCTION TestArrayIndex()
	INT	 iIndex;
	INT	 iIndex2;
	INT	 iCont;
	INT	 iNum = 100000;
	
	FOR iCont = 0 TO 1023 DO
		imIndexDiv32[iCont] = iCont/32;
		imIndexMod32[iCont] = iCont MOD 32;
	END
	!lookuptable
	ErrLog("LookupTable");
	FOR iCont = 0 TO iNum DO
		FOR iIndex2 = 0 TO 1023 DO
			iIndex = imIndexDiv32[iIndex2];
			iIndex = imIndexMod32[iIndex2];
		END
	END
	ErrLog("Normale");
	FOR iCont = 0 TO iNum DO
		FOR iIndex2 = 0 TO 1023 DO
			iIndex = iCont/32;
			iIndex = iCont MOD 32;
		END
	END
	ErrLog("Fine");
END

//#I
//Restituisce il valore di un elemento di bgStsAlm (per uso HMI)
//IN: iTipoAlm
//OUT: valore della posizione nell array bgstaAlm[.]
//#F
INT	 
FUNCTION GetStsAlm(INT iTipoAlm = 1)
	IF bmAutoAckOn = True THEN !MGS 18321 2
		AlarmAck(2, iTipoAlm);
	END
	RETURN bmStsAlm[iTipoAlm];
END

//#I
//Imposta il valore di un elemento di bgStsAlm (per uso HMI)
//IN: iTipoAlm: tipo di allarme da impostare
//    iVal: valore da impostare
//OUT: valore della posizione nell array bgstaAlm[.]
//#F
FUNCTION SetStsAlm(INT iTipoAlm, INT iVal)
	bmStsAlm[iTipoAlm] = iVal;
END

//#I
//Restituisce il nome del sottomessaggio
//IN: iNumBanco: # di word
//    iNumMsg:   # di messaggio
//#F
STRING 
FUNCTION GetPLCAlmDescrMsg(INT iNumBanco, INT iNumMsg)
	IF iNumBanco >= 0 AND iNumBanco < 20 AND iNumMsg >= 0 AND iNumMsg < 20 THEN
		RETURN StrToLocalText(smPLCAlmDescrMsg[iNumBanco][iNumMsg]);
	ELSE
		RETURN "";
	END
END

//#I
//Inizializzazione del sistema messaggi allarmi
//#F
//FUNCTION AlmMsgInit()
//	INT	 iCont;
//	
//	FOR iCont = 0 TO lbPLCMsgAlmNumWord - 1 DO
//		imPLCAlmMsgDefPos[iCont] = 0;
//	END
//END
   
//#I
//Restituisce stato del feedback da comando mailbox DCU
//IN: iNumFeedBack # del feedback
//OUT: True il FB è attivo
//#I
INT	 
FUNCTION GetPLCHMIBancoFeedBack(INT iNumFeedBack)
	RETURN bmPLCHMIBancoFeedBack[iNumFeedBack];
END

//#I
//Restituisce stato del feedback da comando mailbox PLC
//IN: iNumFeedBack # del feedback
//OUT: True il FB è attivo
//#I
INT	 
FUNCTION GetPLCHMICommandFeedBack(INT iNumFeedBack)
	RETURN bmPLCHMICommandFeedBack[iNumFeedBack];
END

//#I
//Restituisce la descrizione dell'allarme datone il #
//nel caso di gestione solo con adv alm, il riferimento è al record n esimo di advalm.dbf
//legge dalla coda hmQueAlm, cerca il # e restituisce il campo stringa della coda
//IN: iNumAlm: # dell'allarme
//#F
STRING 
FUNCTION GetAlmDescr(INT iAlmNum)
	INT	 iDummy;
	STRING sName = "????";
	
	iDummy = hmAdvAlmBFGCodeTag[iAlmNum];
	QuePeek(hmQueAlm, iDummy, sName, 2);
	IF sName = "" THEN
		sName = IntToStr(iAlmNum) + " ????";
	END
	RETURN sName;
END

//#I
//Restituisce la descrizione dell'allarme datone il RecNo
//nel caso di gestione solo con adv alm, il riferimento è al record n esimo di advalm.dbf
//legge dalla coda hmQueAlm, cerca il # e restituisce il campo stringa della coda
//IN: iRecNo: # dell'allarme
//#F
STRING 
FUNCTION GetAlmDescrRecNo(INT iRecNo)
	INT	 iDummy;
	STRING sName = "????";
	
	iDummy = iRecNo;
	QuePeek(hmQueAlm, iDummy, sName, 2);
	IF sName = "" THEN
		sName = IntToStr(iRecNo) + " ????";
	END
	RETURN sName;
END

//#I
//Apre il advalm, conta i record e memorizza il # nella variabile globale
//#F
FUNCTION LoadAdvAlmSize()
	INT	 hDevAdvAlm;
	INT	 iCont;
	
	DevModify("AdvAlmDef", "*", "*", sgLDWINPercProgetto[1] + "\advalm.dbf", -1);
	hDevAdvAlm = DevOpen("AdvAlmDef", 0);
	IF hDevAdvAlm > -1 THEN
		imNumAdvAlm = DevSize(hDevAdvAlm);
		ErrLog("LoadAdvAlmSize() Numero di advalm = " + IntToStr(imNumAdvAlm));
		DevFirst(hDevAdvAlm);
		FOR iCont = 0 TO imNumAdvAlm - 1 DO
			sltAlmTagDev[iCont] = DevGetField(hDevAdvAlm, "Tag");
			!ErrLog("LoadAdvAlmSize(): sltAlmTagDev[" + IntToStr(iCont) + "]= " + sltAlmTagDev[iCont]);
			DevNext(hDevAdvAlm);
		END
		DevClose(hDevAdvAlm);
	ELSE
		Message("ERRORE", "Errore apertura AdvAlm.DBF", 48);
	END
	!DevClose(hDevAdvAlm);
END

//#I
//Restituisce una stringa contenente lo stato di attivazione e lo stato di ack di un allarme dato il recno di in advalm.dbf
//#F
STRING 
FUNCTION GetAlmTagInfo(INT iAlmRecNo)
	STRING sRet = "";
	STRING sDummy;
	INT	 iRec;
	
	IF iAlmRecNo > -1 AND iAlmRecNo < imNumAdvAlm THEN
		sDummy = sltAlmTagDev[iAlmRecNo];
		iRec = AlarmFirstTagRec(sDummy, "", "", "LDWIN");
		sRet = AlarmGetFieldRec(iRec, "State"); !la funzione citect vuole in ingresso l'handle interno all'allarme, che si ricava con la funzione AlarmFirstTagRec utilizzando la tag come chiave primaria
		sRet = sRet + " - " + AlarmGetFieldRec(iRec, "Type");
	END
	RETURN sRet;
END

//#I
//Visualizza lo stato (attivazione + ACK) di tutti gli allarmi
//#F
FUNCTION ShowAllAlmTagInfo()
	INT	 iCont;
	
	FOR iCont = 0 TO imNumAdvAlm - 1 DO
		ErrLog("ALMTAG: " + sltAlmTagDev[iCont] + " -> " + GetAlmTagInfo(iCont));
	END
END

//#I
//Restituisce lo stato di ack di un singolo allarme
//IN: iAlmRecNo: # Record AdvAlm.dbf
//OUT: 0:noAck
//     1:Ack
//#F
INT	 
FUNCTION GetCitectAlmAckState(INT iAlmRecNo)
	INT	 iVal = False;
	STRING sVal = "";
	
	//IF iAlmRecNo = 0 THEN
	//ErrLog("IrecNo 0");
	//END
	IF iAlmRecNo > -1 AND iAlmRecNo < imNumAdvAlm THEN
		sVal = sltAlmTagDev[iAlmRecNo];
		iVal = AlarmFirstTagRec(sVal, "", "", "LDWIN");
		sVal = AlarmGetFieldRec(iVal, "OnTime"); !Filtro x impedire di elaborare record fantasma con un ontime nullo
		IF sVal <> "" THEN
			sVal = AlarmGetFieldRec(iVal, "AckTime"); !Restituisce ora e minuti in cui è ACKato, in modo da non farlo dipendere dalla  lingua
			IF sVal = "" THEN
				iVal = False;
			ELSE
				iVal = True;
			END
		END
	END
	RETURN iVal;
END

//#I
//Esegue l'ack di un singolo allarme
//IN: iAlmRecNo: RecoNo dell'allarme in AdvAlm.dbf
//OUT: 0:noErr
//#F
INT	 
FUNCTION SetCitectAlmAckState(INT iAlmRecNo)
	INT	 bRet = 0;
	INT	 iRec;
	STRING sAlmTag;
	
	ErrLog("SetCitectAlmAckState(" + IntToStr(iAlmRecNo) + ")");
	IF iAlmRecNo > -1 AND iAlmRecNo < imNumAdvAlm THEN
		sAlmTag = sltAlmTagDev[iAlmRecNo];
		iRec = AlarmFirstTagRec(sAlmTag, "", "", "LDWIN");
		bRet = AlarmAckRec(iRec);
	END
	RETURN bRet;
END

//#I
//Imposta l'ACK di tutti gli allarmi
//OUT: 0:noError
//#F
INT	 
FUNCTION SetALLCitectAlmAckState_ol2()
	INT	 iCont;
	INT	 bRet = 0;
	INT	 bVal = False;
	INT	 bFACK = INIParamOn(lbCfgMyCriticalAlmDoubleAck);
	STRING sUserID = LDWINUserInfo(1);
	
	FOR iCont = 0 TO imNumAdvAlm - 1 DO
		IF bFack = False THEN
			bVal = SetCitectAlmAckState(iCont);
		ELSE
			IF ACKChkIfFACK(sUserID, iCont) = True THEN
				bVal = SetCitectAlmAckState(iCont);
			END
		END
		bRet = bRet AND bVal;
	END
	RETURN bRet;
END

//#I
//Imposta l'ACK di tutti gli allarmi
//OUT: 0:noError 21206_4
//#F
INT	 
FUNCTION SetALLCitectAlmAckState()
	INT	 iCont;
	INT	 bRet = 0;
	INT	 bVal = False;
	INT	 bFACK = INIParamOn(lbCfgMyCriticalAlmDoubleAck);
	!STRING sUserID = LDWINUserInfo(1);
	
	FOR iCont = 0 TO imNumAdvAlm - 1 DO
		IF bFack = False THEN
			bVal = SetCitectAlmAckState(iCont);
		ELSE
			IF bmFAckAdvAlm[iCont] = False THEN !lo fa solo sugli allarmi NON critici
				bVal = SetCitectAlmAckState(iCont);
			END
		END
		bRet = bRet AND bVal;
	END
	RETURN bRet;
END

//#I
//Esegue l'ack di un singolo allarme
//OUT: 0:noAck
//     1:Ack
//#F
INT	 
FUNCTION SetCitectAlmAckStateByCitectRecNo(INT iCitectRecNo)
	INT	 bRet = False;
	
	IF iCitectRecNo > -1 THEN
		bRet = NOT AlarmAckRec(iCitectRecNo);
	END
	RETURN bRet;
END

//#I
//Restituisce lo stato di attivazione di un singolo allarme
//IN: iAlmRecNo: RecNo dell'allarme
//OUT: 0:OFF
//     1:ON
//#F
INT	 
FUNCTION GetCitectAlmActState(INT iAlmRecNo)
	INT	 iVal = 0;
	STRING sVal = "";
	STRING sOnTime;
	
	IF iAlmRecNo > -1 AND iAlmRecNo < imNumAdvAlm THEN
		sVal = sltAlmTagDev[iAlmRecNo];
		iVal = AlarmFirstTagRec(sVal, "", "", "LDWIN");
		sOnTime = AlarmGetFieldRec(iVal, "OnTime");
		sVal = AlarmGetFieldRec(iVal, "OffTime");
		iVal = GetAlmOnByTime(sOnTime, sVal);
	END
	RETURN iVal;
END

//INT	 
//FUNCTION GetCitectAlmActState_old(INT iAlmRecNo)
//	INT	 iVal = 0;
//	STRING sVal = "";
//	STRING sOnTime;
//	STRING sOffTime;
//	
//	IF iAlmRecNo > -1 AND iAlmRecNo < imNumAdvAlm THEN
//		sVal = sltAlmTagDev[iAlmRecNo];
//		iVal = AlarmFirstTagRec(sVal, "", "", "LDWIN");
//		sOnTime = AlarmGetFieldRec(iVal, "OnTime");
//		sOffTime = AlarmGetFieldRec(iVal, "OffTime");
//		iVal = GetAlmOnByTime(sOnTime, sOffTime);
//	END
//	RETURN iVal;
//END

//#I
//Restituisce lo stato di ack di un allarme identificato da # dell'allarme
//IN: iBFGCode: # dell'allarme
//OUT: True: Ack
//     False: noAck
//#F
INT	 
FUNCTION GetAlmIsAck(INT iBFGCode)
	INT	 bRet = -1;
	
	IF iBFGCode >= 0 AND iBFGCode < lbNumAlmTotPareto THEN
		bRet = bmAlmIsAck[iBFGCode];
	END
	RETURN bRet;
END

//#I
//Get an element of imAckAdvAlm[.] vector
//IN: iPos: array position
//OUT: integer vector value
//#F
INT	 
FUNCTION GetAckAdvAlm(INT iPos)
	RETURN imAckAdvAlm[iPos];
END

//#I
//Stampa tutte le informazioni di un allarme
//#F
FUNCTION PrintAlmFullInfo(INT iAlmRecNo)
	STRING sDummy;
	INT	 iRec;
	
	IF iAlmRecNo > -1 AND iAlmRecNo < imNumAdvAlm THEN
		sDummy = sltAlmTagDev[iAlmRecNo];
		iRec = AlarmFirstTagRec(sDummy, "", "", "LDWIN");
		ErrLog("---PRINT INFO ALM: " + sDummy +" -> RecNo: " + IntToStr(iAlmRecNo));
		PrintAlmSingleInfo(iRec, "Category");
		PrintAlmSingleInfo(iRec, "Desc");
		PrintAlmSingleInfo(iRec, "Name");
		PrintAlmSingleInfo(iRec, "Tag");
		PrintAlmSingleInfo(iRec, "Time");
		PrintAlmSingleInfo(iRec, "Date");
		PrintAlmSingleInfo(iRec, "DateExt");
		PrintAlmSingleInfo(iRec, "Type");
		PrintAlmSingleInfo(iRec, "State");
		PrintAlmSingleInfo(iRec, "Value");
		PrintAlmSingleInfo(iRec, "LogState");
		PrintAlmSingleInfo(iRec, "State_desc");
		PrintAlmSingleInfo(iRec, "UserName");
		PrintAlmSingleInfo(iRec, "FullName");
		PrintAlmSingleInfo(iRec, "OnDate");
		PrintAlmSingleInfo(iRec, "OnDateExt");
		PrintAlmSingleInfo(iRec, "OffDate");
		PrintAlmSingleInfo(iRec, "OffDateExt");
		PrintAlmSingleInfo(iRec, "OnTime");
		PrintAlmSingleInfo(iRec, "OffTime");
		PrintAlmSingleInfo(iRec, "DeltaTime");
		PrintAlmSingleInfo(iRec, "OnMilli");
		PrintAlmSingleInfo(iRec, "OffMilli");
		PrintAlmSingleInfo(iRec, "AckDate");
		PrintAlmSingleInfo(iRec, "AckTime");
		PrintAlmSingleInfo(iRec, "AckDateExt");
		PrintAlmSingleInfo(iRec, "SumState");
		PrintAlmSingleInfo(iRec, "SumDesc");
		PrintAlmSingleInfo(iRec, "Native_SumDesc");
		PrintAlmSingleInfo(iRec, "Natice_Comment");
		ErrLog("----------------------------------------");
	END
END

//#I
//Stampa tutte le informazioni di un allarme hardware
//#F
FUNCTION printHWAlmFullInfo(INT iRec)
	
	IF iRec > -1 THEN
		ErrLog("---PRINT INFO HW ALM:");
		PrintAlmSingleInfo(iRec, "Category");
		PrintAlmSingleInfo(iRec, "Desc");
		PrintAlmSingleInfo(iRec, "Name");
		PrintAlmSingleInfo(iRec, "Tag");
		PrintAlmSingleInfo(iRec, "Time");
		PrintAlmSingleInfo(iRec, "Date");
		PrintAlmSingleInfo(iRec, "DateExt");
		PrintAlmSingleInfo(iRec, "Type");
		PrintAlmSingleInfo(iRec, "State");
		PrintAlmSingleInfo(iRec, "Value");
		PrintAlmSingleInfo(iRec, "LogState");
		PrintAlmSingleInfo(iRec, "State_desc");
		PrintAlmSingleInfo(iRec, "UserName");
		PrintAlmSingleInfo(iRec, "FullName");
		PrintAlmSingleInfo(iRec, "OnDate");
		PrintAlmSingleInfo(iRec, "OnDateExt");
		PrintAlmSingleInfo(iRec, "OffDate");
		PrintAlmSingleInfo(iRec, "OffDateExt");
		PrintAlmSingleInfo(iRec, "OnTime");
		PrintAlmSingleInfo(iRec, "OffTime");
		PrintAlmSingleInfo(iRec, "DeltaTime");
		PrintAlmSingleInfo(iRec, "OnMilli");
		PrintAlmSingleInfo(iRec, "OffMilli");
		PrintAlmSingleInfo(iRec, "AckDate");
		PrintAlmSingleInfo(iRec, "AckTime");
		PrintAlmSingleInfo(iRec, "AckDateExt");
		PrintAlmSingleInfo(iRec, "SumState");
		PrintAlmSingleInfo(iRec, "SumDesc");
		PrintAlmSingleInfo(iRec, "Native_SumDesc");
		PrintAlmSingleInfo(iRec, "Natice_Comment");
		ErrLog("----------------------------------------");
	END
END

//#I
//Stampa tutte le informazioni di un allarme
//#F
FUNCTION PrintAlmSingleInfo(INT iAlmRecCitectId, STRING sAlmField)
	ErrLog(sAlmField + ": " + AlarmGetFieldRec(iAlmRecCitectId, sAlmField));
END
   
//#I
//Ricava il valore di bStsAlmFlag
//IN: iNum: riferimento dell'array
//OUT: valore dell'n esimo elemento
//#F
INT	 
FUNCTION Get_bStsAlmFlag(INT iNum)
	RETURN bmStsAlmFlag[iNum];
END

//#I
//Restituisce lo stato macchina
//OUT: il valore filtrato dello stato macchina
//#F
INT	 
FUNCTION GetLDStatoMac()
	RETURN imLDStatoMac;
END

GLOBAL
INT	 hgHMIDefVitalID[lbNumVitalTot]; !Restituisce l'id data la posizione assoluta
GLOBAL
INT	 igHMIVitalNumSck[lbNumVitalTot]; !# di socket assegnata

//#I
//Definisce una struttura dati di controllo della vitalità
//IN: iId: id della vitalità da gestire 0 vitalità PLC HMI LD Bonfi
//              1 vitalità DCU HMI LD Bonfi/o DCU emulato PLC
//              2 vitalità PLC CTP HMI
//              3 vitalità VI HMI
//					 4 vitalità PLC Etichettatrice HMI
//    iNumAlm: # dell'allarme di comunicazione associato a quest'allarme
//    sNomeDisp: nome dispositivo visualizzato nel prompt in caso di errore
//    sNomeTag: nome della tag di riferimento per la vitalità
//    bAbil: questa vitalità va abilitata
//    sNomeTagFailOut: nome dell'eventuale tag da scrivere a true se NON ci sono problemi di vitalità (e false diversamente)
//    iTipo: 0 normale
//           1 la vitalità proviene da una socket e NON si basa su una tag ma su un array Cicode di flag e butta fuori lo stato su una tag
//    iNumSCk: socket che deve essere gestita dalla vitalità
//    bStopOnTaskContOn: indica se la scansione della vitalità deve essere interrotta durante l'invio ricetta
//    iTaskId: posizione riferita agli array dei task tipo bgLDWINTaskOn[]
//    iAlmMsgCode: sottomessaggio: del root var
//#F
FUNCTION HMIDefVitality(INT iId, INT iNumAlm, STRING sNomeDisp, STRING sNomeTag, INT bAbil = True, STRING sNomeTagFailOut = "", INT iTipo = 0, INT iNumSck = 1, INT bStopOnTaskContOn = 1, INT iTaskId = -1, INT iAlmMsgCode = -1)
	INT	 iDummy;
	
	!ErrLog("HMIDefVitality(" + IntToStr(iId) + ")");
	IF iTaskId < 0 THEN
		Message("HMIDefVitality", "iId = " + IntToStr(iId) + " - iTaskId = -1", 16);
	ELSE
		IF iId >= 0 AND iId < lbNumVitalTot THEN
			hmHMIVital[iId]        = iNumAlm;
			hmHMIVitalAlmMsg[iId] = iAlmMsgCode;
			sgHMIVitalNameDisp[iId] = sNomeDisp;
			sgHMIVitalTag[iId]    = sNomeTag;
			sgHMIVitalOutTag[iId] = sNomeTagFailOut;
			igHMIVitalNumSck[iId] = iNumSck;
			set_igNumSckHMIVitalId(iNumSck, iId);
			bgStopOnTaskContOn[iId] = bStopOnTaskContOn;
			IF iNumAlm >= 0 AND iNumAlm < lbNumAlmTotPareto THEN
				IF bAbil = True THEN
					iDummy = GetAlmRecordRootVar(iNumAlm, iAlmMsgCode);
					IF iDummy <> -1 THEN
						Set_bmCommAlm(iDummy, True);
						hgHMIVitalAlmRecord[iId] = iDummy;
					END
					igStatoVitalitaHMIPLC[iId] = -100; !inizialzizzazione
				END
				!Gestione dell'attivazione
				IF iId > 0 THEN !il caso con iId=0 è quello dellla vitalità via PLC la cui attivazione dipende da LDWINHMIINIT
					Set_LDWINVitalPLC(iId, bAbil);
				END
				iDummy = GetNumVital();
				hgHMIDefVitalID[iDummy] = iId;
				iDummy = iDummy + 1;
				SetNumVital(iDummy);
				hgLDWINTaskId[iTaskId] = TaskNew("LDWINTaskVitality" + IntToStr(iTipo), IntToStr(iId) + "," + IntToStr(iTaskId), 0);
			ELSE
				ErrLog("HMIDefVitality(...,Err-> iNumAlm=" + IntToStr(iNumAlm) + "<-Err)");
			END
		ELSE
			ErrLog("HMIDefVitality(Err-> iId=" + IntToStr(iId) + "<-Err,...)");
		END
	END
END

//#I
//Imposta il valore del flag di errore di comunicazione (vitalità)
//IN: iVal: valore del flag
//    iId:  id della vitalità
//#F
FUNCTION SetCommAlmFail(INT iVal, INT iId)
	iId = hgHMIVitalAlmRecord[iId];
	IF iId <> -1 THEN
		bmCommAlmFail[iId] = iVal;
	END
END

//#I
//Ricava il valore del flag di allarme di comunicazione
//IN: iId id di vitalità
//OUT: stato dell'allarme
//#F
INT	 
FUNCTION GetCommAlmFail(INT iId)
	iId = hmHMIVital[iId];
	RETURN bmCommAlmFail[hmAdvAlmBFGCodeTag[iId]];
END

//#I
//
//#F
INT	 
FUNCTION GetVitalId2RecordAlm(INT iVitalID)
	INT	 iNumAlm;
	
	IF hmHMIVitalAlmMsg[iVitalID] <> -1 THEN
		RETURN hgHMIVitalAlmRecord[iVitalID];
	ELSE
		iNumAlm = hmHMIVital[iVitalID];
		RETURN bmCommAlmFail[hmAdvAlmBFGCodeTag[iNumAlm]];
	END
END

//#I
//Vitalities initialization
//IN: iLDWINCustomerID: Customer ID
//    bVI: VI process status
//    bCTPOn: CtPack conveyor status
//    bLBLOn: labeler status
//#F
!FUNCTION HMIVitalInit()
!FUNCTION HMIVitalInit(INT iLDWINCustomerID, INT bVIOn)
FUNCTION HMIVitalInit(INT iLDWINCustomerID, INT bVIOn, INT bCTPOn, INT bLBLOn)
	INT	 iCont;
	
	ErrLog("HMIVitalInit");
	SetNumVital(0);
	FOR iCont = 0 TO lbNumVitalTot - 1 DO
		hgHMIDefVitalID[iCont] = -1;
	END
	IF INIParamOn(lbCfgJetsSupport) = True THEN
		IF GetAlmRecordRootVar(lbNumAlmErrCommHMIPLCJets) > -1 THEN !se è definito in lista...
			HMIDefVitality(0, lbNumAlmErrCommHMIPLCJets, "PLC", "btPLCPresenzaHMI", True, "", 0, 1, 1, 43);
		END
	ELSE
		IF GetAlmRecordRootVar(lbNumAlmErrCommHMIPLC) > -1 THEN !se è definito in lista...
			IF bgRTControlTag = False THEN !se la gestione non è full phoenix (è piu sicuro della verifica del tipo di sorgente 0 perchè alcune macchine fullPhoenix hanno la sorgente 0 a tag OPC)
				HMIDefVitality(0, lbNumAlmErrCommHMIPLC, "PLC", "itPLCPresenzaHMI", True, "", 0, 1, 1, 43);
			END
		END
	END
	IF igProc1Indice = 1 THEN !macchine monoprocesso
		IF bVIOn = True AND iLDWINCustomerID = 16 THEN
			IF bgRTControlTag = False THEN !se la gestione non è full phoenix (è piu sicuro della verifica del tipo di sorgente 0 perchè alcune macchine fullPhoenix hanno la sorgente 0 a tag OPC)
				HMIDefVitality(0, 98, "PLC", "itPLCPresenzaHMI", True, "", 0, 1, 1, 43, 2); !15/05/17 lista allarmi con allarmi di comunicazione in AL98 multimessaggio!!!!
			END
		END
		IF (INIParamOn(lbCfgLproLOALaser) = True AND bgSocket1DCULaser = False) THEN
			HMIDefVitality(1, lbNumAlmErrCommHMIDCU, "DCU", "btPLCHMIVitalita", True, "", 0, 1 , 1, 44);
		ELSE
			HMIDefVitality(1, lbNumAlmErrCommHMIDCU, "DCU", "", True, "btPLCPresenzaRT", 1, 1, 1, 44);
		END
	ELSE
		!IF igLDWINVIMachType = 3 AND INIParamOn(lbCfgVITattileEn) = True AND iLDWINCustomerID = 16 THEN
		!IF igLDWINVIMachType = 3 AND bVIOn = True AND iLDWINCustomerID = 16 THEN
		IF bVIOn = True AND iLDWINCustomerID = 16 THEN
			HMIDefVitality(1, 98, "DCU", "", True, "btPLCPresenzaRT", 1, 1, 1, 44, 1); !15/05/17 lista allarmi con allarmi di comunicazione in AL98 multimessaggio!!!!
		ELSE
			HMIDefVitality(1, lbNumAlmErrCommHMIDCU, "DCU", "", True, "btPLCPresenzaRT", 1, 1, 1, 44);
		END
	END
	!IF INIParamOn(lbCfgMyCTPSupport) = True THEN
	!	HMIDefVitality(2, lbNumAlmErrCommHMICTP, "CTP", "btCTPgbAPLC_HMI_Vitality", INIParamOn(lbCfgMyCTPSupport), "", 0, 1, 0, 45);
	!END
	IF bCTPOn = True THEN
		!HMIDefVitality(2, lbNumAlmErrCommHMICTP, "CTP", "btCTPgbAPLC_HMI_Vitality", INIParamOn(lbCfgMyCTPSupport), "", 0, 1, 0, 45);
		HMIDefVitality(2, lbNumAlmErrCommHMICTP, "CTP", "btCTPgbAPLC_HMI_Vitality", bCTPOn, "", 0, 1, 0, 45);
	END
	!IF INIParamOn(lbCfgMyLBLSupport) = True THEN !22171 LBL
	IF bLBLOn = True THEN !22171 LBL
		!HMIDefVitality(4, lbNumAlmErrCommHMILBL, "LBL", "btLBLgbAPLC_HMI_Vitality", INIParamOn(lbCfgMyLBLSupport), "", 0, 1, 0, 45);
		HMIDefVitality(4, lbNumAlmErrCommHMILBL, "LBL", "btLBLgbAPLC_HMI_Vitality", bLBLOn, "", 0, 1, 0, 45);
	END
	IF bgRTControlTag = False THEN !se la gestione non è full phoenix (è piu sicuro della verifica del tipo di sorgente 0 perchè alcune macchine fullPhoenix hanno la sorgente 0 a tag OPC)
		Set_LDWINVitalPLC(0, True);
	ELSE
		Set_LDWINVitalPLC(0, False);
	END
END

                                      !Hanno tutti lo stesso task id in modo
//#I
//Importa le sorgenti allarmi dal file LDWINAlmSource.DBF
//man mano che legge dal DBF scrive su Gest_AlmDef la funzione di copia automatica delle tag degli allarmi e multimessaggi sulla tag globale
//IN: hFileAlmDef:puntatore al file Gest_AlmDef su cui scrivere la funzione di copia per igCopiaAlm
//#F
FUNCTION ImportAlmSource(INT hFileAlmDef)
	STRING sPath;
	STRING sCont;
	STRING sAlmName;
	STRING sDummyNameField;
	STRING sVarPath;
	STRING sDummy;
	INT	 iType;
	INT	 iDevBank;
	INT	 iDevMsgBank;
	INT	 hDev;
	INT	 iError;
	INT	 iCont;
	INT	 iNumMaxTag = 32;
	INT	 iNumSource;
	INT	 iNumBank;
	INT	 iNumMsgBank;
	INT	 hVarDev;
	INT	 iInd;
	INT	 iCont2;
	INT	 hID;
	INT	 iTaskID = 56; !il primo task id è 57 ma dato che il +1 viene calcolato subito è necessario che l'inizializzaizone sia all'ID precedente
	STRING sTask;
	INT	 iAckTaskID = 85; !il primo task id è 86 ma dato che il +1 viene calcolato subito è necessario che l'inizializzaizone sia all'ID precedente
	STRING sAckTask;
	INT	 iNumBankAck;
	INT	 iDummy;
	
	sPath = StrToXPCmdPath(sgLDWINPercProgetto[0] + "\LDWINAlmSource.DBF"); !va nel _MAIN
	IF FileExist(sPath) THEN
		DevModify("DevDummy", "*", "*", sPath, dBASE_DEV);
		!Verifica delle sorgenti
		hDev = DevOpen("DevDummy", 0);
		!apri variable.dbf del COM
		sVarPath = StrToXPCmdPath(sgLDWINPercProgetto[2] + "\variable.DBF");
		DevModify("DevCOMVariable", "*", "*", sVarPath, dBASE_DEV);
		hVarDev = DevOpen("DevCOMVariable", 0);
		IF hVarDev = -1 THEN
			Message("File Not Found", sVarPath + " non trovato!" , 16);
		END
		IF hDev <> -1 THEN
			FileWriteLn(hFileAlmDef, "");
			iError = 0;
			iNumSource = 0;
			iNumBank = 0;
			iNumMsgBank = 0;
			iNumBankAck = 0;
			hmQueTaskAlmSourceImport = -1;
			hmQueTaskAlmSourceImport = QueOpen("AlmSourceTaskImport", 1);
			IF hmQueTaskAlmSourceImport = -1 THEN !errore coda
				iError = 1; !per inibire il while
				Message("ImportAlmSource", "Errore apertura coda hmQueTaskAlmSourceImport", 16);
			END
			WHILE iError = 0 DO
				//OCCHIOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
				//deve inserire i dati utili in
				//smAlmSourceName[imNumAlmSource]
				//imAlmSourceNumBank[imNumAlmSource]
				//imAlmSourceNumMsgBank[imNumAlmSource]
				//imNumAlmSource
				//perchè una volta terminata la funzione, la funzione globale di importazione allarmi ne dovrà scrivere i definitori
				
				sAlmName = StrTrim(DevGetField(hDev, "Nome"));
				hID      = StrTrim(DevGetField(hDev, "Id"));
				imAlmSourceId[hID] = hID;
				hmIDNumDef[iNumSource] = hID;
				smAlmSourceName[hID] = sAlmName;
				imAlmSourceNumBank[hID] = iNumBank;
				imAlmSourceNumMsgBank[hID] = iNumMsgBank;
				imAlmSourceMinAlm[hID] = StrTrim(DevGetField(hDev, "AlmMin"));
				imAlmSourceMaxAlm[hID] = StrTrim(DevGetField(hDev, "AlmMax"));
				smAlmSourceRef[hID] = StrTrim(DevGetField(hDev, "AlmRef"));
				smAlmSourceMsgRef[hID] = StrTrim(DevGetField(hDev, "MsgRef"));
				iType = StrToInt(StrTrim(DevGetField(hDev, "Type")));
				imAlmSourceType[hID] = iType;
				
				SELECT CASE iType
				CASE 0 !tag esplicite
					sDummy = IntToStr(hID);
					iTaskID = iTaskID + 1;
					sTask = IntToStr(iTaskID);
					FileWriteLn(hFileAlmDef, "//#I");
					!FileWriteLn(hFileAlmDef, "//Task di copia il valore delle tag o degli array di sorgente nell'array principale di scansione di Id: " + sDummy + " Sorgente: " + sAlmName);
					FileWriteLn(hFileAlmDef, "//External tag vector copy task Id: " + sDummy + " Source: " + sAlmName);
					FileWriteLn(hFileAlmDef, "//#F");
					FileWriteLn(hFileAlmDef, "FUNCTION LDWINCopiaAlm" + sDummy + "()");
					!FileWriteLn(hFileAlmDef,"   hgLDWINTaskId[" + sTask + "] = TaskHnd(^"LDWINCopiaAlm" + sDummy + "^");");
					FileWriteLn(hFileAlmDef,"   LDWINDefTask(" + sTask + ", ^"LDWINCopiaAlm" + sDummy + "^");");
					FileWriteLn(hFileAlmDef,"   hgQueCopiaAlmTask = QueOpenAndWrite(hgQueCopiaAlmTask, ^"QueCopiaAlmTask^", 1, hgLDWINTaskId[" + sTask + "], ^"^");");
					!FileWriteLn(hFileAlmDef,"   bgLDWINTaskOn[" + sTask + "] = True;");
					FileWriteLn(hFileAlmDef,"   TaskNew(^"LDWINCpyAlmAckState" + sDummy + "^", ^"^", 8); !task di copia dello stato ack");
					FileWriteLn(hFileAlmDef,"   WHILE bgLDWINTaskOn[" + sTask + "] = True DO");
					//viene indicata solo il nome della tag da leggere, per identificarne la dimensione si apre il variable.dbf,
					//si cerca la tag e se estrapola la grandezza
					//in questo modo si possono avere fino a 32 array di tag/msg per ogni sorgente allarme
					FOR iCont = 0 TO iNumMaxTag - 1 DO
						sCont = IntToStr(iCont);
						sDummyNameField = "AlmTag" + sCont;
						sDummy = StrTrim(DevGetField(hDev, sDummyNameField));
						IF sDummy <> "" THEN
							iInd = GetTagIndex(sDummy, hVarDev);
							SELECT CASE iInd
							CASE -2
								ErrLog("ImportAlmSource: " + sDummy + " not found in variable.dbf");
								iDevBank = -1;
							CASE -1
								!FileWriteLn(hFileAlmDef,"      igCopiaAdvAlm[" + IntToStr(iNumBank) + "] = " + sDummy + ";");
								FileWriteLn(hFileAlmDef,"      SetCopiaAdvAlm(" + IntToStr(iNumBank) + ", " + sDummy + ");");
								iNumBank = iNumBank + 1;
								iDevBank = 1;
							CASE ELSE
								FOR iCont2 = 0 TO iInd - 1 DO
									!FileWriteLn(hFileAlmDef, "      igCopiaAdvAlm[" + IntToStr(iNumBank) + "] = " + sDummy + "[" + IntToStr(iCont2) + "];");
									 FileWriteLn(hFileAlmDef, "      SetCopiaAdvAlm(" + IntToStr(iNumBank) + ", " + sDummy + "[" + IntToStr(iCont2) + "]);");
									iNumBank = iNumBank + 1;
								END
								iDevBank = iInd;
							END SELECT
						END
						sDummyNameField = "MsgTag" + sCont;
						sDummy = StrTrim(DevGetField(hDev, sDummyNameField));
						IF sDummy <> "" THEN
							iInd = GetTagIndex(sDummy, hVarDev);
							SELECT CASE iInd
							CASE -2
								ErrLog("ImportAlmSource: " + sDummy + " not found in variable.dbf");
							CASE -1
								FileWriteLn(hFileAlmDef,"      igCopiaAdvAlmMsg[" + IntToStr(iNumMsgBank) + "] = " + sDummy + ";");
								iNumMsgBank = iNumMsgBank + 1;
							CASE ELSE
								FOR iCont2 = 0 TO iInd - 1 DO
									FileWriteLn(hFileAlmDef,"      igCopiaAdvAlmMsg[" + IntToStr(iNumMsgBank) + "] = " + sDummy + "[" + IntToStr(iCont2) + "];");
									iNumMsgBank = iNumMsgBank + 1;
								END
							END SELECT
						END
					END
					FileWriteLn(hFileAlmDef, "      SleepMS(500);");
					FileWriteLn(hFileAlmDef, "   END !While del task");
					FileWriteLn(hFileAlmDef, "   LDWINTaskEnd(" + sTask + ");");
					FileWriteLn(hFileAlmDef, "END");
					FileWriteLn(hFileAlmDef, "");
				CASE 1,2 !socket/specialeLDWIN: i campi almBank e MsgBank indicano quanti banchi a 32bit devono essere riservati alla sorgente
					iDevBank = StrToInt(StrTrim(DevGetField(hDev, "AlmBank")));
					iDevMsgBank = StrToInt(StrTrim(DevGetField(hDev, "MsgBank")));
					sDummy = IntToStr(hID);
					IF hID = 0 OR hID = 1 THEN
						!verifica che il # di messaggi sia uguale a quello impostato dal pacchetto 11, altrimenti dai errore
						IF iType = 1 THEN
							IF iDevMsgBank <> 20 THEN
								Message("LDWINAlmSource.DBF", "Errore Sorgente ID=" + IntToStr(hID) + ": Sorgente basata su Pacchetto 11. Impostare colonna MSGBANK=" + IntToStr(lbSckPack11NumMsg), 48);
							END
						END
					END
					iNumBank = iNumBank + iDevBank;
					iNumMsgBank = iNumMsgBank + iDevMsgBank;
					!task di copia dello stato ack
					!Stato Ack Allarmi VI su socket devono partire quando è attivo il VI e non sempre (<> 3)
					!Stato Ack Allarmi LPro: su socket quando è attivo almeno un laser Lpro
					IF hID <> 3 AND hID <> 5 THEN 
						QueWrite(hmQueTaskAlmSourceImport, hID, "   TaskNew(^"LDWINCpyAlmAckState" + sDummy + "^", ^"^", 8); !Task di copia dello stato ack [" + sAlmName + "]");
					END
				END SELECT
				!scrittura della funzione di copia di stato Ack
				sDummy = IntToStr(hID);
				iAckTaskID = iAckTaskID + 1;
				sAckTask = IntToStr(iAckTaskID);
				FileWriteLn(hFileAlmDef, "//#I");
				!FileWriteLn(hFileAlmDef, "//Task di copia il valore dello stato di ACK nelle tag o degli array delle sorgente di Id: " + sDummy + " Sorgente: " + sAlmName);
				FileWriteLn(hFileAlmDef, "//ACK status copy Task Id: " + sDummy + " Source: " + sAlmName);
				FileWriteLn(hFileAlmDef, "//#F");
				FileWriteLn(hFileAlmDef, "FUNCTION LDWINCpyAlmAckState" + sDummy + "()");
				FileWriteLn(hFileAlmDef,"   LDWINDefTask(" + sAckTask + ", ^"LDWINCpyAlmAckState" + sDummy + "^");");
				!FileWriteLn(hFileAlmDef,"   hgLDWINTaskId[" + sAckTask + "] = TaskHnd(^"LDWINCpyAlmAckState" + sDummy + "^");");
				FileWriteLn(hFileAlmDef,"   hgQueCopiaAlmTask = QueOpenAndWrite(hgQueCopiaAlmTask, ^"QueCopiaAlmTask^", 1, hgLDWINTaskId[" + sAckTask + "], ^"^");");
				!FileWriteLn(hFileAlmDef,"   bgLDWINTaskOn[" + sAckTask + "] = True;");
				FileWriteLn(hFileAlmDef,"   WHILE bgLDWINTaskOn[" + sAckTask + "] = True DO");
				
				sDummy = "ltHMIAckState" + sDummy;
				iInd = GetTagIndex(sDummy, hVarDev);
				SELECT CASE iInd
				CASE -2
					ErrLog("ImportAlmSource: " + sDummy + " not found in variable.dbf");
					iDummy = -1;
				CASE -1
					!FileWriteLn(hFileAlmDef, "      ltHMIAckState" + IntToStr(hID) + " = igAckAdvAlm[" + IntToStr(iNumBankAck) + "];");
					FileWriteLn(hFileAlmDef, "      ltHMIAckState" + IntToStr(hID) + " = GetAckAdvAlm(" + IntToStr(iNumBankAck) + ");");
					iNumBankAck = iNumBankAck + 1;
					iDummy = 1;
				CASE ELSE
					FOR iCont2 = 0 TO iInd - 1 DO
						!FileWriteLn(hFileAlmDef, "      ltHMIAckState" + IntToStr(hID) + "[" + IntToStr(iCont2) + "] = igAckAdvAlm[" + IntToStr(iNumBankAck) + "];");
						FileWriteLn(hFileAlmDef, "      ltHMIAckState" + IntToStr(hID) + "[" + IntToStr(iCont2) + "] = GetAckAdvAlm(" + IntToStr(iNumBankAck) + ");");
						iNumBankAck = iNumBankAck + 1;
					END
					iDummy = iInd;
				END SELECT
				FileWriteLn(hFileAlmDef, "      SleepMS(500);");
				FileWriteLn(hFileAlmDef, "   END !While del task");
				FileWriteLn(hFileAlmDef, "   LDWINTaskEnd(" + sAckTask + ");");
				FileWriteLn(hFileAlmDef, "END");
				FileWriteLn(hFileAlmDef, "");
				IF iDevBank <> iDummy THEN
					ShowMessageTask("ImportAlmSource", "Sorgente " + IntToStr(hID) + ": Tag " + sDummy + " dimensione non corretta^nRichiesto [" + IntToStr(iDevBank) + "] trovato [" + IntToStr(iDummy) +"]", 16);
				END
				!----------------
				iNumSource = iNumSource + 1;
				iError = DevNext(hDev);
			END
			DevClose(hDev);
			DevClose(hVarDev);
			imNumAlmSource = iNumSource;
		END
	ELSE
		Message("File Not Found", sPath + " non trovato!", 16);
	END
END

INT	 imNumBitTag = 32;
INT	 hmAlmNative = -1; !Puntatore al file civetta AlmNative_abcd.ci

//#I
//importa gli allarmi dal file .csv
//deve riprodurre il comportamento del BUROBOT
//IN: hFileAlmDef:puntatore al file Gest_AlmDef su cui scrivere i definitori degli allarmi
//#F
FUNCTION ImportAlmFromCsv(INT hFileAlmDef)
	STRING sIdAlm;
	STRING sCatAlm;
	STRING sLevelAlm;
	STRING sPLCCode;
	STRING sSubMsgCode;
	STRING sPhoenixCode;
	STRING sIdComp;
	STRING sAlmIta;
	STRING sPriv;
	STRING sEn;
	STRING sAlmName;
	STRING sAlmFullNameTemp; !unisco sAlmIta con sIdComp in modo che la funzione PrepareAdvAlmName riconosca,separi,e traduca anche le []
	STRING sAlmDesc;
	STRING sAlmNameRoot = "";
	STRING sLevelAlmTemp;
	STRING sAlmNameFinal;
	STRING sAlmDescFinal;
	STRING sAlmBankAndBit;
	STRING sFACkAlm = "0"; !21206 AZ
	STRING sDummy;
	STRING sPath;
	INT	 iAlmBankFinal;
	INT	 iAlmBitFinal;
	INT	 iAlmMsgBankFinal;
	INT	 iAlmMsgValFinal;
	INT	 iNumAlm;
	INT	 hDev = -1;
	INT	 iError;
	INT	 iIdSorg = -1;
	INT	 iIdSorgTemp = -1;
	INT	 iAdvAlmRecNo = 0;
	INT	 iPLCType; !0 = OMRON   1 = SIEMENS
	INT	 iOffsetIndirizziVar; !indirizzo del primo banco allarmi, es OMRON=120 SIEMENS=??
	STRING sOffsetIndirizziVarMsg; !per i sottomessaggi, ad es Dxxx = xxx [SIEMENS]
	INT	 iAlmBankRoot;
	INT	 iAlmBitRoot;
	INT	 iAlmBankTmp;
	INT	 iAlmBitTmp;
	INT	 iPhoenixRoot;
	INT	 hDevAdvAlm = -1;
	INT	 bWriteOnAdvAlm; !indica se le informazioni che ho raccolto sono suff per scrivere un nuovo record
	!ad es. gli alm ROOT non vanno scritti perchè ogni sottomessaggio avrà un record su advalm,
	!si memorizzano solo le informazioni per l'attivazione (banco e bit) ed il testo dell'allarme
	INT	 iAlmPLCNumBit = 32;
	INT	 iLen;
	INT	 iPosSep;
	INT	 iAlmBankSocket;
	INT	 iAlmBitSocket;
	INT	 iAlmMsgValSocket;
	INT	 iMinAlmSource;
	INT	 b565Done = False;
	INT	 b568Done = False;
	!INT	 iLarghezzaForm = 25;
	INT	 iLarghezzaForm = 26;
	INT	 iAltezzaForm = 11;
	STRING sOmronCJ = "0";
	STRING sOmronNJ = "1";
	STRING sSiemens = "0";
	STRING sOPC = "0";
	STRING sOmronCQM1 = "0";
	STRING sSiemensMPI = "0";
	STRING sSLC500 = "0";
	STRING sCatalmPrec = "1";
	INT	 bCambia;
	INT	 iAlmSourceType;
	INT	 iPLCSourceType;
	INT	 iDecodeMode = -1;
	INT	 iDummy;
	INT	 iPos1;
	INT	 iPos2;
	INT	 bEnablePrepare = True;
	INT	 bDoppioAck = INIParamOn(lbCfgMyCriticalAlmDoubleAck);
	STRING sFileLDWININI = sgFileLDWININI;
	STRING sFileFound;
	INT	 bDCUMultitesta;
	INT	 iNumTeste = LDWINIniGetIntValMem(lbCfgNumTeste);
	INT	 iCont;
	
	!Message("WORK IN PROGRESS","la lettura da csv funziona, bisogna decidere come utilizzare i dati", 16);
	hDev = LDWINAlarmListOpen();
	IF hDev > -1 THEN
		!seleziona le opzioni
		!sistema le variabili
		!se plc via tag chiedo il tipo
		iPLCSourceType = GetAlmSourceType(0);
		imNumBitTag = 32;
		IF iPLCSourceType = 0 THEN !plc via tag
			!FARE FORM DI SELEZIONE tipoPLC(omron/siemens) - # bit(8 / 16)
			sOmronCJ    = WndGetFileProfile("ALARM", "sOmronCJ",    "0", sFileLDWININI);
			sOmronNJ    = WndGetFileProfile("ALARM", "sOmronNJ",    "0", sFileLDWININI);
			sSiemens    = WndGetFileProfile("ALARM", "sSiemens",    "0", sFileLDWININI);
			sOPC        = WndGetFileProfile("ALARM", "sOPC",        "0", sFileLDWININI);
			sSLC500     = WndGetFileProfile("ALARM", "sSLC500",     "0", sFileLDWININI);
			sOmronCQM1  = WndGetFileProfile("ALARM", "sOmronCQM1",  "0", sFileLDWININI);
			sSiemensMPI = WndGetFileProfile("ALARM", "sSiemensMPI", "0", sFileLDWININI);
			hgLDWINForm[57] = FormNew("Importazione Allarmi", iLarghezzaForm, iAltezzaForm, 32 + 16);
			FormGroupBox(0, 0, iLarghezzaForm - 1, iAltezzaForm, "PLC:");
			FormRadioButton(1, 1, "Omron CJ", sOmronCJ);
			FormRadioButton(1, 2, "Omron NJ/ABC-Logix", sOmronNJ);
			FormRadioButton(1, 3, "Siemens", sSiemens);
			FormRadioButton(1, 4, "OPC", sOPC);
			FormRadioButton(1, 5, "Omron CQM1 [Jets]", sOmronCQM1);
			FormRadioButton(1, 6, "Siemens MPI [Jets]", sSiemensMPI);
			FormRadioButton(1, 7, "AB SLC500 [Jets]", sSLC500);
			IF BottoniOkCancel(iAltezzaForm, iLarghezzaForm, 3, 0, True) <> 299 THEN
				IF sOmronCJ = "1" THEN
					iPLCType = 0;
					iAlmPLCNumBit = 16;
				END
				IF sSiemens = "1" THEN
					iPLCType = 1;
					iAlmPLCNumBit = 8;
				END
				IF sOmronNJ = "1" THEN
					iPLCType = 2;
					iAlmPLCNumBit = 32;
				END
				IF sOpc = "1" THEN
					iPLCType = 2;
					iAlmPLCNumBit = 32;
				END
				IF sOmronCQM1 = "1" THEN
					iPLCType = 0;
					iAlmPLCNumBit = 16;
					imNumBitTag = 16;
				END
				IF sSiemensMPI = "1" THEN
					iPLCType = 0;
					iAlmPLCNumBit = 8;
					imNumBitTag = 16;
				END
				IF sSLC500 = "1" THEN
					iPLCType = 0;
					iAlmPLCNumBit = 16;
					imNumBitTag = 16;
				END
				
				WndPutFileProfile("ALARM", "sOmronCJ",       sOmronCJ, sFileLDWININI);
				WndPutFileProfile("ALARM", "sSiemens",       sSiemens, sFileLDWININI);
				WndPutFileProfile("ALARM", "sOmronNJ",       sOmronNJ, sFileLDWININI);
				WndPutFileProfile("ALARM", "sOpc",               sOpc, sFileLDWININI);
				WndPutFileProfile("ALARM", "sOmronCQM1",   sOmronCQM1, sFileLDWININI);
				WndPutFileProfile("ALARM", "sSiemensMPI", sSiemensMPI, sFileLDWININI);
				WndPutFileProfile("ALARM", "sSLC500",         sSLC500, sFileLDWININI);
			END
		ELSE !plc via socket(emulato)
			iPLCType = -1;
			Message("Tipo PLC [" + IntToStr(iPLCSourceType) + "]", "PLC emulato da RT via socket!", 64);
		END
		!Inizia l'elaborazione
		!hDev = LDWINAlarmListOpen();
		!IF hDev > -1 THEN
		IF hgDigAlmDBF = -1 THEN
			DevModify("AdvAlmDef", "*", "*", sgLDWINPercProgetto[1] + "\advalm.dbf", -1);
			hDevAdvAlm = DevOpen("AdvAlmDef", 0);
		ELSE
			hDevAdvAlm = hgDigAlmDBF;
		END
		IF hDevAdvAlm > -1 THEN
			DevZap(hDevAdvAlm);
			!IF hDev <> -1 THEN
			sAlmName = "";
			sltAlmListCommessa = "????";
			sltAlmListVer = "????";
			!cancella i file Gest_AlmDefNativeABCD" intestati con un # di matricola diverso da quello che sta generando
			sIDComp = LDWININIDspStrValue(lbCfgMatrMacchina);
			sPath = StrToXPCmdPath(sgLDWINPercProgetto[1] + "\" + "Gest_AlmDefNative*.ci");
			sFileFound = FileFind(sPath, 0);
			WHILE StrLength(sFileFound) > 0 DO
				IF StrSearch(0, sFileFound, sIdComp) = -1 THEN !se non trova il # di matricola, cancella il file
					FileDelete(sFileFound);
				END
				sFileFound = FileFind("", 0);
			END
			smCommMatr = StrTrim(DevGetField(hDev, "AlmIta"));
			smLARev = StrTrim(DevGetField(hDev, "IdComp"));
			iDummy = TimeCurrent();
			sDummy = sConvertShort(TimeHour(iDummy)) + sConvertShort(TimeMin(iDummy)) + sConvertShort(TimeSec(iDummy));
			!Creazione del modulo cicode civetta per mantenere le traduzioni di versioni di lista allarmi varie (allarmi multilingua in rapporto allarmi)
			sIDComp = LDWININIDspStrValue(lbCfgMatrMacchina) + "_" + LDWINCompactDate() + "_" + sDummy;
			sAlmName = "Gest_AlmDefNative" + sIDComp + ".ci";
			sDummy = StrToXPCmdPath(sgLDWINPercProgetto[1] + "\" + sAlmName);
			IF hmAlmNative = -1 THEN
				hmAlmNative = FileOpen(sDummy, "w");
			END
			!scrivi l'intestazione del modulo
			IF hmAlmNative <> -1 THEN
				LDWINSetCicodeHead(hmAlmNative, "Alarm backward compatibility native translations definitions", sAlmName, "1.00");
				FileWriteLn(hmAlmNative, "");
			END
			
			iError = DevNext(hDev);
			WHILE iError = 0 DO
				bWriteOnAdvAlm = True;
				sIdAlm = StrTrim(DevGetField(hDev, "IdAlm")); !id allarme es. AL000
				//IF sIdAlm = "AL017" THEN
				//IF iAdvAlmRecNo = 16 THEN
				//ErrLog("AL017");
				//END
				//END
				sCatAlm = StrTrim(DevGetField(hDev, "CatAlm")); !categoria allarme 1-> primario 2-> secondario
				sLevelAlm = StrTrim(DevGetField(hDev, "LevelAlm")); !root - var - std-> per decidere se è un allarme multimess o no
				sPLCCode = StrTrim(DevGetField(hDev, "PLCCode")); !indirizzo PLC dell'allarme o del sotto mess->
				//su questo si fanno i conti per risalire a bit e banco allarme e multimess
				sSubMsgCode = StrTrim(DevGetField(hDev, "SubMsgCode")); !codice del plc per indicare il sottomess
				sPhoenixCode = StrTrim(DevGetField(hDev, "PhoenixCode")); !codice phoenix
				sIdComp = StrTrim(DevGetField(hDev, "IdComp")); !testo tra []
				sAlmIta = StrTrim(DevGetField(hDev, "AlmIta")); !testo allarme
				sPriv = StrTrim(DevGetField(hDev, "Priv")); !privilegio
				sEn = StrTrim(DevGetField(hDev, "En")); !abilitazione
				!IF bDoppioACK = True THEN
				sFACkAlm = StrTrim(DevGetField(hDev, "FAck")); !doppio ACK allarmi critici 21206 !18226
				!END
				sDummy = StrRight(sIdAlm, 3);
				iNumAlm = StrToInt(sDummy);
				//0 - 223 LD PLC -> idSorg=0
				//224 - 303 + warning 0-15 LD RT socket -> idSorg = 1
				//...
				//DEBUG-----
				//IF sIdAlm = "AL569" THEN
				//iError = 0;
				//END
				!ErrLog("ImportAlmFromCsv(.) " + sIdAlm);
				//----------
				iIdSorg = GetSourceFromAlmNum(iNumAlm);
				sDummy = StrUpper(StrLeft(sIdAlm, 2));
				IF sDummy = "WN" THEN
					iIdSorg = -1;
				END
				IF iIdSorg <> -1 OR iIdSorg = 7 THEN !sorgente allarme riconosciuta o riservata per LDWIN
					iMinAlmSource = imAlmSourceMinAlm[iIdSorg];
					sLevelAlmTemp = StrUpper(sLevelAlm);
					iAlmSourceType = getAlmSourceType(iIdSorg);
					iIdSorgTemp = iIdSorg;
					IF iIdSorg = 0 THEN
						IF iAlmSourceType = 1 THEN !se plc via socket
							iIdSorgTemp = 100; !plc emulato via socket
						ELSE
							IF sOpc = "1" THEN
								iIdSorgTemp = 400; !plc emulato via OPC
							END
						END
					END
					IF iIdSorg = 4 AND iAlmSourceType = 1 THEN
						iIdSorgTemp = 100;
					END
					SELECT CASE iIdSorgTemp
					CASE 0,2,8 !PLC
						iOffsetIndirizziVar = StrToInt(smAlmSourceRef[iIdSorg]);
						sOffsetIndirizziVarMsg = smAlmSourceMsgRef[iIdSorg];
					CASE 1,5,100 !RT socket / LPROSocket /plc emulato via socket
						SELECT CASE iNumAlm
						CASE iMinAlmSource //primo alm rt socket
							iAlmBankSocket = 0;
							iAlmBitSocket = 0;
						CASE ELSE
							IF sLevelAlmTemp <> "VAR" THEN !incremento il bit ad ogni allarme ed il banco se il bit è > 31
								IF iIdSorgTemp = 1 THEN !alcune liste allarmi x gli allarmi socket RT NON contengono TUTTI i Record
									iDummy = iNumAlm - iMinAlmSource;
									iAlmBitSocket = iDummy MOD 32;
									iAlmBankSocket = iDummy/32;
								ELSE
									iAlmBitSocket = iAlmBitSocket + 1;
									IF iAlmBitSocket > 31 THEN
										iAlmBankSocket = iAlmBankSocket + 1;
										iAlmBitSocket = 0;
									END
								END
							END
						END SELECT
					CASE 4, 400 !il cambio di banco avviene quando cambia la categoria (due banchi di 32 bit separati: 32 primari e 32 secondari)
						SELECT CASE iNumAlm
						CASE iMinAlmSource //primo alm rt socket
							iAlmBankSocket = 0;
							iAlmBitSocket = 0;
							sCatAlmPrec = sCatAlm;
						CASE ELSE
							IF sLevelAlmTemp <> "VAR" THEN !incremento il bit ad ogni allarme ed il banco se il bit è > 31
								iAlmBitSocket = iAlmBitSocket + 1;
								!CBC (importazione CON ANCHE un PLC): il cambio banco avviene sull'evento di cambio categoria
								IF sOpc = "0" THEN !si modella l'eventuale presenza di un CBC in una macchina che si presume avere ANCHE un PLC
									IF sCatAlmPrec <> sCatAlm THEN
										sCatalmPrec = sCatAlm;
										bCambia = True;
									END
								END
								IF iAlmBitSocket > 31 OR bCambia = True THEN
									bCambia = False;
									iAlmBankSocket = iAlmBankSocket + 1;
									iAlmBitSocket = 0;
								END
							END
						END SELECT
					CASE 6 !CTPTag
						sEN = "0"; !per importarli si usa le rispettive funzioni
					END SELECT
					IF sEn = "1" THEN !allarme abilitato ; )
						sAlmFullNameTemp = sAlmIta + sIdComp; !non gli metto lo spazio così la separazione viene notevolmente meglio
						!IF sIdAlm = "AL097" THEN
						!ErrLog("AL097");
						!END
						IF sAlmFullNameTemp <> "" THEN
							bEnablePrepare = True;
							!Eccezione: Testo principale dell'allarme in cui ci sono delle "[.]" e non c'è la componente
							!in questo caso si aggiunge la notazione "@()" e basta. anche perchè a parsarlo si rischia di debordare il # max di caratteri
							IF sIdComp = "" THEN
								iPos1 = StrSearch(0, sAlmIta, "[");
								iPos2 = StrSearch(0, sAlmIta, "]");
								IF iPos1 > -1 AND iPos2 > -1 THEN
									sAlmName = StrSetNative(sAlmFullNameTemp);
									bEnablePrepare = False;
								END
							END
							IF bEnablePrepare = True THEN
								sAlmName = PrepareAdvAlmName(sAlmFullNameTemp, True);
							END
							sAlmDesc = sgAdvAlmPartTag;
							iDecodeMode = -1;
							SELECT CASE iIdSorgTemp
							CASE 0, 2, 8 !PLC, PLCVI, PLCGMCR
								IF sLevelAlmTemp <> "VAR" THEN
									!debug
									!IF iAlmPLCNumBit = 8 THEN
									!Errlog("sPLCCode = " + sPLCCode);
									!END !sIdAlm
									!IF sIdAlm = "AL025" THEN
									!Errlog("sIdAlm=" + sIdAlm);
									!END
									!IF sIdAlm = "AL000" THEN
									!Errlog("sIdAlm=" + sIdAlm);
									!END
									sAlmBankAndBit = getAlmBankAndBit(iAlmPLCNumBit, iOffsetIndirizziVar, sPLCCode, iPLCType, iIdSorgTemp, sIdAlm);
									!separo banco e bit (utilizzando il # come separatore)
									iLen = StrLength(sAlmBankAndBit);
									iPosSep = StrSearch(0, sAlmBankAndBit, "#");
									iAlmBankTmp = StrToInt(StrLeft(sAlmBankAndBit, iPosSep));
									iAlmBitTmp = StrToInt(StrRight(sAlmBankAndBit, iLen - iPosSep - 1));
								END !sLevelAlmTemp <> "VAR"
								SELECT CASE sLevelAlmTemp
								CASE "ROOT"//se root-> sAlmName <> "" & sAlmDesc = ""
									sAlmNameRoot = sAlmName;
									iAlmBankRoot = iAlmBankTmp;
									iAlmBitRoot = iAlmBitTmp;
									bWriteOnAdvAlm = False;
								CASE "VAR" !se var-> sAlmName = "" & sAlmDesc <> ""
									IF sAlmName <> "@()" THEN
										sAlmNameFinal = sAlmNameRoot + " " + sAlmName;
									ELSE
										sAlmNameFinal = sAlmNameRoot;
									END
									sAlmDescFinal = sAlmDesc;
									iAlmBankFinal = iAlmBankRoot;
									iAlmBitFinal = iAlmBitRoot;
									iAlmMsgBankFinal = GetAlmMsgBank(sOffsetIndirizziVarMsg, sPLCCode, iPLCType, iNumAlm);
									iAlmMsgValFinal = StrToInt(sSubMsgCode);
									bWriteOnAdvAlm = True;
								CASE "STD" !se std-> sAlmName <> "" & (sAlmDesc = "" | sAlmDesc <> "")
									sAlmNameFinal = sAlmName;
									sAlmDescFinal = sAlmDesc;
									iAlmBankFinal = iAlmBankTmp;
									iAlmBitFinal = iAlmBitTmp;
									iAlmMsgBankFinal = -1;
									iAlmMsgValFinal = -1;
									bWriteOnAdvAlm = True;
								END SELECT
							CASE 1, 5, 100 !RT socket / LPROSocket / plc emulato via socket
								!iDecodeMode = 0;
								iDecodeMode = 1;
							CASE 3 !VI SOCKET -> devo inserire solo l'AL371 perchè per gli altri ci pensa la relativa funzione del sistema di importazione del VI
								bWriteOnAdvAlm = False;
								IF iNumAlm = 371 THEN !è sempre sul banco 0 bit 0
									sAlmDescFinal = sAlmDesc;
									sAlmNameFinal = sAlmName;
									iAlmBankFinal = 0;
									iAlmBitFinal = 0;
									iAlmMsgBankFinal = -1;
									iAlmMsgValFinal = -1;
									bWriteOnAdvAlm = True;
								END
							CASE 4, 400 !RTTag ex.CBC, OPC
								bWriteOnAdvAlm = False;
								SELECT CASE iNumAlm
								CASE 565
									IF b565Done = False THEN
										sAlmDescFinal = "{GetAdvAlmMsg(1)}";
										b565Done = True;
										bWriteOnAdvAlm = True;
									END
								CASE 568
									IF b568Done = False THEN
										sAlmDescFinal = "{GetAdvAlmMsg(4)}";
										b568Done = True;
										bWriteOnAdvAlm = True;
									END
								CASE 569
									!ErrLog("569");
									iDecodeMode = 1;
								CASE ELSE
									!gestione normale
									iDecodeMode = 1;
								END SELECT !iNumAlm
							CASE 7 !LDWIN 18307
								bWriteOnAdvAlm = False; !non scrivere record di nessun tipo
							CASE ELSE
								ErrLog("ImportAlmFromCsv(...) Sorgente non gestita " + IntToStr(iIdSorgTemp));
							END SELECT !idsorgTemp
							bDCUMultitesta = False;
							IF iDecodeMode <> -1 THEN
								SELECT CASE sLevelAlmTemp
								CASE "ROOT" !ha sicuramente un phoenix perchè è attivo
									iPhoenixRoot = StrToInt(sPhoenixCode);
									iAlmMsgValSocket = 0; !resetta per i suoi var (i valori rt multimess partono da 1)
									sAlmNameRoot = sAlmName;
									bWriteOnAdvAlm = False;
								CASE "VAR" !il valore corrispondente al messaggio è incrementale
									IF iDecodeMode = 0 THEN
										iAlmMsgValSocket = iAlmMsgValSocket + 1;
									ELSE
										IF StrTrim(sSubMsgCode) = "" THEN
											iAlmMsgValSocket = -1;
											Message("ImportAlmFromCsv()", "Riferimento banco multimessaggio nullo! -> " + sIdAlm, 48);
										ELSE
											iAlmMsgValSocket = StrToInt(sSubMsgCode);
										END
									END
									iAlmBankFinal = iAlmBankSocket;
									iAlmBitFinal = iAlmBitSocket;
									iAlmMsgBankFinal = iPhoenixRoot; !20110
									iAlmMsgValFinal = iAlmMsgValSocket;
									IF sAlmName <> "@()" THEN
										sAlmNameFinal = sAlmNameRoot + " " + sAlmName;
									ELSE
										sAlmNameFinal = sAlmNameRoot;
									END
									sAlmDescFinal = sAlmDesc;
									bWriteOnAdvAlm = True;
								CASE "STD" !se ha un phoenix allora è multitesta [ iAlmMsgVal = -2 =>indica multitesta]
									!il campo desc deve essere {GetAdvAlmMsg(iAdvAlmRecNo)} per ottenere il valore del # testa dcu
									IF sPhoenixCode <> "" THEN !allarme multitesta
										!se l'allarme appartiene alla sorgente 5[LOA L-PRO Socket] allora viene dal pacchetto 14 da DCU, quindi il contenuto è nell'array sulla DLL con handle hsAdvAlmMsg
										IF iIdSorg = 5 OR (iIdSorg = 4 AND imAlmSourceType[4] = 1) THEN !20110
											sAlmDescFinal = "{GetAdvAlmMsg(" + IntToStr(iAdvAlmRecNo) + ",1)}";
										ELSE
											bDCUMultitesta = True;
											sAlmDescFinal = "{GetAdvAlmMsg(" + IntToStr(iAdvAlmRecNo) + ")}";
										END
										iAlmMsgBankFinal = StrToInt(sPhoenixCode);
										iAlmMsgValFinal = -2;
									ELSE !allarme normale
										sAlmDescFinal = sAlmDesc;
										iAlmMsgBankFinal = -1;
										iAlmMsgValFinal = -1;
									END
									sAlmNameFinal = sAlmName;
									iAlmBankFinal = iAlmBankSocket;
									iAlmBitFinal = iAlmBitSocket;
									bWriteOnAdvAlm = True;
								END SELECT
							END !IF iDecodeMode <> -1
							IF bWriteOnAdvAlm = True THEN
								IF iAlmBankFinal >= 0 THEN
									!AdvAlmAddRecord(hDevAdvAlm, hFileAlmDef, IntToStr(iNumAlm), sAlmNameFinal, iAdvAlmRecNo, IntToStr(iAlmBitFinal),
									!iIdSorg, IntToStr(iAlmBankFinal), sPriv, sCatAlm, sAlmDescFinal, iAlmMsgBankFinal, iAlmMsgValFinal);
									IF bDCUMultitesta = True THEN
										FOR iCont = 1 TO iNumTeste DO
//											AdvAlmAddRecord(hDevAdvAlm, hFileAlmDef, IntToStr(iNumAlm), sAlmNameFinal, iAdvAlmRecNo, IntToStr(iAlmBitFinal),
//											iIdSorg, IntToStr(iAlmBankFinal), sPriv, sCatAlm, IntToStr(iCont), iAlmMsgBankFinal, iAlmMsgValFinal, "", False, True, sFAckAlm, True);
//											iAdvAlmRecNo = iAdvAlmRecNo + 1;
											AdvAlmAddRecord(hDevAdvAlm, hFileAlmDef, IntToStr(iNumAlm), sAlmNameFinal, iAdvAlmRecNo, IntToStr(iAlmBitFinal),
											iIdSorg, IntToStr(iAlmBankFinal), sPriv, sCatAlm, IntToStr(iCont), iAlmMsgBankFinal, iAlmMsgValFinal, "", False, True, sFAckAlm, iCont); !23213
											iAdvAlmRecNo = iAdvAlmRecNo + 1;
										END
									ELSE
										AdvAlmAddRecord(hDevAdvAlm, hFileAlmDef, IntToStr(iNumAlm), sAlmNameFinal, iAdvAlmRecNo, IntToStr(iAlmBitFinal),
										iIdSorg, IntToStr(iAlmBankFinal), sPriv, sCatAlm, sAlmDescFinal, iAlmMsgBankFinal, iAlmMsgValFinal, "", False, True, sFAckAlm);
										iAdvAlmRecNo = iAdvAlmRecNo + 1;
									END
								ELSE
									sDummy = " iIdSorgTemp = " + IntToStr(iIdSorgTemp) + " iAlmBankFinal = " + IntToStr(iAlmBankFinal);
									Message("ImportAlmFromCsv()", sDummy, 16);
									ErrLog("ImportAlmFromCsv() " + sDummy);
									iAdvAlmRecNo = iAdvAlmRecNo + 1;
								END
								//iAdvAlmRecNo = iAdvAlmRecNo + 1;
							END
						ELSE
							Message("ImportAlmFromCsv()", "Sul .csv manca il nome di " + sIdAlm + "!", 64);
						END !IF sAlmFullNameTemp <> ""
					END !IF sEn = "1"
				ELSE !IF iIdSorg <> -1 OR iIdSorg = 7
					IF iIdSorg = -1 THEN
						ErrLog("Sorgente allarmi non riconosciuta: Id Allarme " + sIdAlm);
					END
				END
				iError = DevNext(hDev);
			END !WHILE...
			//inserire QUI allarmi in ADVAlm sempre presenti
			//Tag     Name                                             Desc              Expr           Cat
			//AL788	@(Anomalia Cp Distrubuzione Conformi)	      {HSTGetProc(0)}	HSTCpAlmOn(0,142)	2
			//AL788	@(Anomalia Cp Distrubuzione Conformi)	      {HSTGetProc(4)}	HSTCpAlmOn(4,143)	2
			//AL789	@(Anomalia Cp Distrubuzione Non Conformi)	   {HSTGetProc(1)}	HSTCpAlmOn(1,144)	2
			//AL789	@(Anomalia Cp Distrubuzione Non Conformi)	   {HSTGetProc(5)}	HSTCpAlmOn(5,145)	2
			//AL790	@(Anomalia Cpk Distrubuzione Conformi)	      {HSTGetProc(0)}	HSTCpkAlmOn(0,187)	2
			//AL790	@(Anomalia Cpk Distrubuzione Conformi)	      {HSTGetProc(4)}	HSTCpkAlmOn(4,188)	2
			//AL791	@(Anomalia Cpk Distrubuzione Non Conformi)	{HSTGetProc(1)}	HSTCpkAlmOn(1,189)	2
			//AL791	@(Anomalia Cpk Distrubuzione Non Conformi)	{HSTGetProc(5)}	HSTCpkAlmOn(5,190)	2
			//AL788-1
			AdvAlmAddRecord(hDevAdvAlm, hFileAlmDef, "788", "@(Anomalia Cp Distrubuzione Conformi)",     iAdvAlmRecNo, "0", 7, "0", "4", "2", HSTGetProc(0));
			iAdvAlmRecNo = iAdvAlmRecNo + 1;
			//-----------------
			!lasciati 2 bit di riserva per il 788
			//AL788-2
			AdvAlmAddRecord(hDevAdvAlm, hFileAlmDef, "788", "@(Anomalia Cp Distrubuzione Conformi)",     iAdvAlmRecNo, "4", 7, "0", "4", "2", HSTGetProc(4));
			iAdvAlmRecNo = iAdvAlmRecNo + 1;
			//-----------------
			//AL789-1
			AdvAlmAddRecord(hDevAdvAlm, hFileAlmDef, "789", "@(Anomalia Cp Distrubuzione Non Conformi)",  iAdvAlmRecNo, "1", 7, "0", "4", "2", HSTGetProc(1));
			iAdvAlmRecNo = iAdvAlmRecNo + 1;
			//-----------------
			//AL789-2
			AdvAlmAddRecord(hDevAdvAlm, hFileAlmDef, "789", "@(Anomalia Cp Distrubuzione Non Conformi)",  iAdvAlmRecNo, "5", 7, "0", "4", "2", HSTGetProc(5));
			iAdvAlmRecNo = iAdvAlmRecNo + 1;
			//-----------------
			//AL790 -1
			AdvAlmAddRecord(hDevAdvAlm, hFileAlmDef, "790", "@(Anomalia Cpk Distrubuzione Conformi)",     iAdvAlmRecNo, "0", 7, "1", "4", "2", HSTGetProc(0));
			iAdvAlmRecNo = iAdvAlmRecNo + 1;
			//-----------------
			//AL790 -2
			AdvAlmAddRecord(hDevAdvAlm, hFileAlmDef, "790", "@(Anomalia Cpk Distrubuzione Conformi)",     iAdvAlmRecNo, "4", 7, "1", "4", "2", HSTGetProc(4));
			iAdvAlmRecNo = iAdvAlmRecNo + 1;
			//-----------------
			//AL791 -1
			AdvAlmAddRecord(hDevAdvAlm, hFileAlmDef, "791", "@(Anomalia Cpk Distrubuzione Non Conformi)", iAdvAlmRecNo, "1", 7, "1", "4", "2", HSTGetProc(1));
			iAdvAlmRecNo = iAdvAlmRecNo + 1;
			//-----------------
			//AL791 -2
			AdvAlmAddRecord(hDevAdvAlm, hFileAlmDef, "791", "@(Anomalia Cpk Distrubuzione Non Conformi)", iAdvAlmRecNo, "5", 7, "1", "4", "2", HSTGetProc(5));
			iAdvAlmRecNo = iAdvAlmRecNo + 1;
			IF INIParamOn(lbCfgMyRunChart) = True THEN
				IF INIParamOn(lbCfgLDEnable) = True THEN
					!lasciati 2 bit di riserva per il 791
					//-----------------
					//AL792
					AdvAlmAddRecord(hDevAdvAlm, hFileAlmDef, "792", "RunChart X 1a Lettura [LD]", iAdvAlmRecNo, "8", 7, "0", "4", "2", "{SPCRunCharGetMsg(0)}");
					iAdvAlmRecNo = iAdvAlmRecNo + 1;
					//-----------------
					//AL793
					AdvAlmAddRecord(hDevAdvAlm, hFileAlmDef, "793", "RunChart X Delta [LD]", iAdvAlmRecNo,      "9", 7, "0", "4", "2", "{SPCRunCharGetMsg(1)}");
					iAdvAlmRecNo = iAdvAlmRecNo + 1;
					//-----------------
					//AL794
					AdvAlmAddRecord(hDevAdvAlm, hFileAlmDef, "794", "RunChart S 1a Lettura [LD]", iAdvAlmRecNo, "8", 7, "1", "4", "2", "{SPCRunCharGetMsg(2)}");
					iAdvAlmRecNo = iAdvAlmRecNo + 1;
					//-----------------
					//AL795
					AdvAlmAddRecord(hDevAdvAlm, hFileAlmDef, "795", "RunChart S Delta [LD]", iAdvAlmRecNo,      "9", 7, "1", "4", "2", "{SPCRunCharGetMsg(3)}");
					iAdvAlmRecNo = iAdvAlmRecNo + 1;
				END
			END
			//AL800
			AdvAlmAddRecord(hDevAdvAlm, hFileAlmDef, "800", "@(Backup Remoto in corso)", iAdvAlmRecNo, "13", 7, "0", "4", "2", "{RemoteBckGetAlmMsg()}");
			iAdvAlmRecNo = iAdvAlmRecNo + 1;
			//AL801
			AdvAlmAddRecord(hDevAdvAlm, hFileAlmDef, "801", "@(Backup Remoto Non Possibile)", iAdvAlmRecNo, "14", 7, "0", "4", "2", "@(Eseguire Backup Manuale)");
			iAdvAlmRecNo = iAdvAlmRecNo + 1;
			//AL802
			AdvAlmAddRecord(hDevAdvAlm, hFileAlmDef, "802", "@(Backup Remoto Fallito)", iAdvAlmRecNo, "15", 7, "0", "4", "2", "@(Consultare Rapporto Eventi)");
			iAdvAlmRecNo = iAdvAlmRecNo + 1;
			DevClose(hDev);
			DevClose(hDevAdvAlm);
		END !IF hDevAdvAlm > -1
	END !IF hDev > -1
END

//#I
//Definitore di sorgente allarmi
//#F
FUNCTION AlmSourceDef(INT iID, INT iType, STRING sName, INT iAlmBankOffset,INT iAlmMsgBankOffset, INT iMinAlm, INT iMaxAlm)
	imAlmSourceId[imNumAlmSource] = iID;
	smAlmSourceName[iID] = sName;
	imAdvAlmSourceOffset[iID] = iAlmBankOffset;
	imAdvAlmSourceMsgOffset[iID] = iAlmMsgBankOffset;
	imAlmSourceMinAlm[iID] = iMinAlm;
	imAlmSourceMaxAlm[iID] = iMaxAlm;
	imAlmSourceType[iID] = iType;
	imNumAlmSource = imNumAlmSource + 1;
END

//#I
//Definitore advAlm
//IN: 1. iIdSorgAlm: sorgente allarme
//    2. iBFGAlmCode: codice della lista allarmi bonfi ufficiale
//    3. iBank: banco allarme di appartenenza
//    4. iBit: bit dell'allarme
//    5. iMsgBank: banco di messaggio di appartenenza
//    6. iMsgBit: valore del banco allarmi che scatena l'allarme
//    7. iAdvAlmRecNo: # di record in advalm.dbf
//    8. sNatAlmName: nome dell'allarme in formato nativo
//    9. sNatAlmDesc: descrizione dell'allarme in formato nativo
//    10.bFirstAck: True l'allarme in questione è di tipo critico e deve avere l'ack doppio da due utenti diversi 21206
//#F
!FUNCTION AdvAlmDef(INT iIdSorgAlm, INT iBFGAlmCode, INT iBank, INT iBit, INT iMsgBank, INT iMsgBit, INT iAdvAlmRecNo, STRING sNatAlmName = "", STRING sNatAlmDesc = "")
FUNCTION AdvAlmDef(INT iIdSorgAlm, INT iBFGAlmCode, INT iBank, INT iBit, INT iMsgBank, INT iMsgBit, INT iAdvAlmRecNo, STRING sNatAlmName = "", STRING sNatAlmDesc = "", INT bFirstAck = False, INT iHeadNumber = 0)
	INT	 hQue;
	INT	 iDummy;
	INT	 sDummy;
	
	imAdvAlmSource[iAdvAlmRecNo] = iIdSorgAlm;
	hmAdvAlmNumRecTag[iAdvAlmRecNo] = iBFGAlmCode;
	hmAdvAlmBFGCodeTag[iBFGAlmCode] = iAdvAlmRecNo;
	!Costruzione delle code dei root-var
	IF iMsgBank > -1 THEN
		hQue = hmAdvAlmBFGCodeTagMsgQue[iMsgBank];
		IF hQue = -1 THEN
			hQue = QueOpen("AdvAlmDef_" + IntToStr(iBFGAlmCode) + "_" + IntToStr(iMsgBank), 1);
			imAdvAlmBFGCodeTagRootVar[iBFGAlmCode] = iMsgBank;
			hmAdvAlmBFGCodeTagMsgQue[iMsgBank] = hQue;
			!ErrLog("imAdvAlmBFGCodeTagRootVar[" + IntToStr(iBFGAlmCode) + "] =" + IntToStr(iMsgBank));
		END
		iDummy = iMsgBit; !si userà un quepeek in modo 2 e la stringa restituita è il # di record
		sDummy = IntToStr(iAdvAlmRecNo);
		QueWrite(hQue, iDummy, sDummy);
	END
	imAdvAlmBank[iAdvAlmRecNo] = iBank;
	imAdvAlmBit[iAdvAlmRecNo] = iBit;
	imAdvAlmMsgBank[iAdvAlmRecNo] = iMsgBank;
	imAdvAlmMsgVal[iAdvAlmRecNo] = iMsgBit;
	iDummy = imAdvAlmSourceOffset[iIdSorgAlm];
	imCopiaAdvAlmPos[iAdvAlmRecNo] = iDummy + iBank;
	bmFAckAdvAlm[iAdvAlmRecNo] = bFirstAck; !21206
	!Sottomessaggi
	iDummy = imAdvAlmSourceMsgOffset[iIdSorgAlm];
	imCopiaAdvAlmMsgPos[iAdvAlmRecNo] = iDummy + iMsgBank;
	stAlmName[iAdvAlmRecNo] = sNatAlmName;
	stAlmDesc[iAdvAlmRecNo] = sNatAlmDesc;
	imAdvAlmMsgHeadNumber[iAdvAlmRecNo] = iHeadNumber;
END

STRING smAlmSourceTagCol[2] = "ALMTAG", "MSGTAG";

//#I
//Importatore Allarmi
//Scrive su Gest_AlmDef i definitori di allarmi e sorgenti allarmi, e la funzione per copiare i valori delle tag si iCopiaAlm
//#F
FUNCTION ImportAdvAlm()
	STRING sGestAlmDefPath;
	STRING sVal;
	STRING sFilePath;
	STRING sPathLDWIN_MAIN;
	STRING sIdAlm;
	STRING sIdAlmPrec;
	STRING sFail;
	STRING sAlmSource = StrToXPCmdPath(sgLDWINPercProgetto[0] + "\LDWINAlmSource.DBF"); !va nel _MAIN
	STRING sValQue;
	INT	 iNumAlm;
	INT	 iNumAlmPrec = 0;
	INT	 hFile;
	INT	 iCont;
	INT	 hID;
	INT	 hDev;
	INT	 bEnable = False;
	INT	 iError;
	INT	 iAlmFromUSB;
	INT	 bContinue = True;
	INT	 bFail;
	INT	 iDummy;
	INT	 iTipo;
	INT	 iMin;
	INT	 iMax;
	INT	 iCont2;
	INT	 iValQue;
	
	IF hgLDWINForm[57] = -1 THEN
		IF HMIConsensoOper("@(Aggiornamento Automatico):",
			"@(ATTENZIONE!) Il consenso produrrà modifiche PERMANENTI",
			"Procedere con aggiornamento ?") = True THEN
			!Al primo shutdown, fai cancellare D:\CitectData\Data\LDWIN_MAIN e D:\LDWIN\dati\LDWINAlmInfo.INI
			!WndPutFileProfile("ALM", "DeleteCitectAlmData", "1", sgPercLDWINDATINI);
			iAlmFromUSB = ShowRadioBtnForm("Sorgente Lista Alarmi", "Selezionare la locazione della lista allarmi da importare:", 0, "Cartella LDWIN_MAN", "root Dispositivo USB");
			SELECT CASE iAlmFromUSB
			CASE 0!import normale
				bEnable = True;
			CASE 1!import USB
				!inserimento chiave
				Message("Sorgente Lista Alarmi", "il file LDWINAlarmList.csv DEVE essere nella root del dispositivo USB", 64);
				sVal = HMIGetUsbLetter("Sorgente Lista Allarmi");
				IF sVal <> " " THEN !found
					sPathLDWIN_MAIN = sgLDWINPercProgetto[0] + "\";
					sFilePath = sVal + ":\LDWINAlarmList.csv";
					IF FileExist(sFilePath) = True THEN
						LDWINXCopy(sFilePath, sPathLDWIN_MAIN + "*", "/Y", 1000);
						sFilePath = sVal + ":\LDWINAlmSource.DBF";
						IF FileExist(sFilePath) = True THEN
							LDWINXCopy(sFilePath, sPathLDWIN_MAIN + "*", "/Y", 1000);
						END
						bEnable = True;
					ELSE
						Message("ERRORE", "File " + sFilePath + " Non Trovato", 48);
					END
				END
			END SELECT
		END
		IF bEnable = True THEN
			!Verifiche prima di iniziare
			IF FileExist(sAlmSource) THEN
				DevModify("DevDummy", "*", "*", sAlmSource, dBASE_DEV);
				!Verifica delle sorgenti
				hDev = DevOpen("DevDummy", 0);
				IF hDev > -1 THEN
					iError = DevFirst(hDev);
					WHILE iError = 0 AND bContinue = True DO
						bFail = False;
						sVal = DevGetField(hDev, "Type");
						iTipo = StrToInt(sVal);
						sVal = StrTrim(DevGetField(hDev, "AlmMin"))
						iMin = StrToInt(sVal);
						sVal = StrTrim(DevGetField(hDev, "AlmMax"));
						iMax = StrToInt(sVal);
						FOR iCont = iMin TO iMax DO
							imTestBFGAlmSourceType[iCont] = iTipo;
						END
						SELECT CASE iTipo
						CASE 0 !sorgente a TAG controlla che siano specificate le tag
							IF bFail = False THEN
								FOR iCont2 = 0 TO 1 DO
									sVal = DevGetField(hDev, smAlmSourceTagCol[0] + "0");
									bFail = False;
									IF sVal = "" THEN
										sFail = "Gli allarmi della sorgente " + DevGetField(hDev, "NOME") + " sono TAG ma " + smAlmSourceTagCol[0] + "0 NON contiene nomi di tag. Specificare i nomi.";
										iCont2 = 1;
										bFail = True;
									END
								END
							END
						CASE 1
							!Verifica che una sorgente di tipo socket abbia un valore valido nella colonna ALMBANK
							sVal = StrTrim(DevGetField(hDev, "ALMBANK"));
							IF sVal = "" THEN
								bFail = True;
								sFail = "Gli allarmi della sorgente " + DevGetField(hDev, "NOME") + " sono socket ma MSGBANK è vuoto: Specificare il # di banchi da 32 bit.";
							END
							
							IF bFail = False THEN
								FOR iCont2 = 0 TO 1 DO
									!Verifica che una sorgente di tipo socket NON abbia delle tag specificate
									FOR iCont = 0 TO 31 DO
										sVal = DevGetField(hDev, smAlmSourceTagCol[iCont2] + IntToStr(iCont));
										bFail = False;
										IF sVal <> "" THEN
											sFail = "Gli allarmi della sorgente " + DevGetField(hDev, "NOME") + " sono socket ma " + smAlmSourceTagCol[iCont2] + IntToStr(iCont) + " contiene nomi di tag. Togliere i nomi.";
											iCont = 31;
											iCont2 = 1;
											bFail = True;
										END
									END
								END
							END
						END SELECT
						IF bFail = True THEN
							IF HMIConsensoOper("@(ATTENZIONE!) LDWINAlarmSource.DBF Record:"  + IntToStr(DevRecNo(hDev)), sFail, "Procedere ugualmente con l'importazione della lista allarmi?") = False THEN
								bContinue = False;
								bEnable = False;
							END
						END
						iError = DevNext(hDev);
					END
					DevClose(hDev);
				END
			END
		END
		!Verifica che ci siano tutti i record di sorgente (o perlomeno che ce ne siano 9, da 0 a 8)
		IF bEnable = True THEN
			IF FileExist(sAlmSource) THEN
				DevModify("DevDummy", "*", "*", sAlmSource, dBASE_DEV);
				!Verifica delle sorgenti
				hDev = DevOpen("DevDummy", 0);
				IF hDev > -1 THEN
					FOR iCont = 0 TO 8 DO
						DevFirst(hDev);
						iError = DevFind(hDev, IntToStr(iCont), "ID");
						IF iError <> 0 THEN
							bFail = True;
							iError = iCont;
							iCont = 8;
						END
					END
					DevClose(hDev);
					IF bFail = True THEN
						sFail = "Errore! non ha tutte le sorgenti da 0 a 8 elencate: " + IntToStr(iError) + " non trovato!";
						bEnable = HMIConsensoOper("@(ATTENZIONE!) LDWINAlarmSource.DBF", sFail, "Procedere ugualmente con l'importazione della lista allarmi?");
					END
				END
			END
		END
		IF bEnable = True THEN !non accorpare perchè serve per sezionare fasi successive
			!controlla che i codici di allarme dei record crescano sempre di 1 per gli allarmi allocati sulla socket emulata o DCU
			iCont = 0;
			hDev = LDWINAlarmListOpen();
			IF hDev > -1 THEN
				iError = DevNext(hDev);
				WHILE iError = 0 AND bContinue = True DO
					sIdAlm = StrTrim(DevGetField(hDev, "IdAlm")); !id allarme es. AL000
					sVal = StrRight(sIdAlm, 3);
					iNumAlm = StrToInt(sVal);
					IF imTestBFGAlmSourceType[iNumAlm] = 1 THEN
						IF iCont = 0 THEN !controlla che il primo record sia SEMPRE "AL000"
							IF sIdAlm <> "AL000" THEN
								bFail = True;
								sFail = "Manca AL000 come primo allarme [" + sIdAlm + "]";
							END
						END
						IF imTestBFGAlmSourceType[iNumAlmPrec] = 1 THEN
							IF iNumAlmPrec <> iNumAlm THEN
								iDummy = iNumAlm - iNumAlmPrec;
								IF iDummy > 1 OR iDummy < 0 THEN !i numeri di allarme devono crescere sempre di 1 perchè altrimenti vuol dire che sono stati messi solo quelli "Attivi"
									bFail = True;
									sFail = "Controllare [BUROBOT]: tra " + sIdAlmPrec + " e " + sIdAlm + " mancano allarmi. Devono essere consecutivi.";
								END
								iNumAlmPrec = iNumAlm;
							END
						END
						IF bFail = True THEN
							IF HMIConsensoOper("@(ATTENZIONE!) LDWINAlarmList.csv Riga:"  + IntToStr(iCont + 2) + " Allarmi mancanti o non consecutivi. Controllare Lista Allarmi e Burobot", sFail, "Procedere ugualmente con l'importazione della lista allarmi?") = False THEN
								bEnable = False;
								bContinue = False;
							ELSE
								bFail = False;
							END
						END
					ELSE
						iNumAlmPrec = iNumAlm;
					END !IF imTestBFGAlmSourceType[...
					sIdAlmPrec = sIdAlm;
					iCont = iCont + 1;
					iError = DevNext(hDev);
				END
				DevClose(hDev);
			END
		END !IF bEnable
		iCont = 0;
		IF bEnable = True THEN
			ErrLog("LDWIN:Importazione automatica allarmi");
			sGestAlmDefPath = StrToXPCmdPath(sgLDWINPercProgetto[1] + "\Gest_AlmDef.ci");
			hFile = FileOpen(sGestAlmDefPath, "w");
			!write cicode module header
			IF hFile <> -1 THEN
				!LDWINSetCicodeHead(hFile, "Alarm system definitions", "Gest_AlmDef.ci", "1.07");
				LDWINSetCicodeHead(hFile, "Alarm system definitions", "Gest_AlmDef.ci", "1.08");
				ImportAlmSource(hFile);
//				FileWriteLn(hFile, "");
//				FileWriteLn(hFile, "//#I");
//				FileWriteLn(hFile, "//Inizializza il sistema dei messaggi di allarme");
//				FileWriteLn(hFile, "//#F");
//				FileWriteLn(hFile, "FUNCTION PLCAlmMsgInit()");
//				FileWriteLn(hFile, "   !Azzeramento per eventuali reinizializzazioni");
//				FileWriteLn(hFile, "   AlmMsgInit();");
//				FileWriteLn(hFile, "END");
				FileWriteLn(hFile, "");
				FileWriteLn(hFile, "//#I");
				FileWriteLn(hFile, "//Inizializza il sistema degli allarmi");
				FileWriteLn(hFile, "//#F");
				FileWriteLn(hFile, "FUNCTION LDWINAlmDef()");
				FileWriteLn(hFile, "   ResetNumAlmSource();");
				FileWriteLn(hFile, "   !definitori AlmSource");
				FOR iCont = 0 TO imNumAlmSource - 1 DO
					hID = hmIDNumDef[iCont];
					FileWriteLn(hFile, "   AlmSourceDef(" + IntToStr(hID) + "," + IntToStr(imAlmSourceType[hID]) + ",^"" + smAlmSourceName[hID] + "^"," + IntToStr(imAlmSourceNumBank[hID]) + "," + IntToStr(imAlmSourceNumMsgBank[hID]) + "," + IntToStr(imAlmSourceMinAlm[hID]) + "," + IntToStr(imAlmSourceMaxAlm[hID]) + ");!" + smAlmSourceType[imAlmSourceType[hID]]);
				END
				FileWriteLn(hFile, "   !FINE definitori AlmSource");
				FileWriteLn(hFile, "   !definitori AdvAlmDef");
				ImportAlmFromCsv(hFile);
				FileWriteLn(hFile, "   !FINE definitori AdvAlmDef");
				!se VI attivo importa anche i suoi allarmi
				FileWriteLn(hFile, "   !Importazioni allarmi VI");
				FileWriteLn(hFile, "   IF INIParamOn(lbCfgVITattileEn) = True THEN");
				FileWriteLn(hFile, "      DefinisciAllarmiVI();");
				FileWriteLn(hFile, "      TaskNew(^"LDWINCpyAlmAckState3^", ^"^", 8); !task di copia dello stato ack");
				FileWriteLn(hFile, "   END");
				!se CTP attivo importa anche i suoi allarmi
				FileWriteLn(hFile, "   !Importazioni allarmi CTP");
				FileWriteLn(hFile, "   IF INIParamOn(lbCfgMyCTPSupport) = True THEN");
				FileWriteLn(hFile, "      DefinisciAllarmiCTP();");
				FileWriteLn(hFile, "   END");
				!se Etichettatrice attiva importa anche i suoi allarmi
				FileWriteLn(hFile, "   !Importazioni allarmi LBL");
				FileWriteLn(hFile, "   IF INIParamOn(lbCfgMyLBLSupport) = True THEN");
				FileWriteLn(hFile, "      DefinisciAllarmiLBL();");
				FileWriteLn(hFile, "   END");
								!----
				IF INIParamOn(lbCfgVITattileEn) = True THEN
					ErrLog("VI Attivo: importazione automatica allarmi e parametri");
					SQLDefParVI(0);
				END
				IF INIParamOn(lbCfgMyCTPSupport) = True THEN
					ErrLog("CTP Attivo: importazione automatica allarmi e parametri");
					LDWINCTPGeneraDef(0);
				END
				IF INIParamOn(lbCfgMyLBLSupport) = True THEN !22171 LBL
					ErrLog("Etichettatrice Attiva: importazione automatica allarmi e parametri");
					LDWINLBLGeneraDef(0);
				END
				IF hmQueTaskAlmSourceImport <> -1 THEN
					WHILE QueLength(hmQueTaskAlmSourceImport) > 0 DO
						QueRead(hmQueTaskAlmSourceImport, iValQue, sValQue, 0);
						ErrLog("Task: " + IntToStr(iValQue) + " " + sValQue);
						FileWriteLn(hFile, sValQue);
					END
					QueClose(hmQueTaskAlmSourceImport);
				END
				sltAlmListVer = smLARev;
				sltAlmListCommessa = smCommMatr;
				FileWriteLn(hFile, "   sltAlmListVer = ^"" + sltAlmListVer + "^";" );
				FileWriteLn(hFile, "   sltAlmListCommessa = ^"" + sltAlmListCommessa + "^";");
				FileWriteLn(hFile, "END");
				Close_AlmNativeFile();
				HMICompileLDWINMsg();
			END
			FileClose(hFile);
			hgLDWINform[57] = -1;
		END !IF bEnable = True
	END
END

//#I
//Restituisce il valore di bmAdvAlmOn[...] indicante se un determinato allarme è attivo
//IN: iAdvAlmRecNo: # RecNo dell'advalm
//#F
INT	 
FUNCTION AdvAlmIsOn(INT iAdvAlmRecNo)
	RETURN bmAdvAlmOn[iAdvAlmRecNo];
END

//#I
//Restituisce il banco allarme con i dati presi dal csv
//#F
INT	 
FUNCTION GetAlmBank(REAL rRef, REAL rVal)
	INT	 iBank;
	
	iBank = Round(rVal - rRef, 0);
	RETURN iBank;
END

//#I
//Restituisce il bit attivazione allarme con i dati presi dal csv
//#F
INT	 
FUNCTION GetAlmBit(REAL rVal)
	INT	 iBit;
	
	iBit = rVal - Round(rVal, 0);
	RETURN iBit;
END

//#I
//Restituisce il banco sottomessaggio con i dati presi dal csv TODO: questa funzione sembra essere un signleton. Sotituire nell'unico punto di occorrenza
//iPLCType: 0->OMRON CJ     sRef = "xxx"  sVal="Dxxx"
//          1->SIEMENS      sRef = "na"  sVal="DB15.DBBx"
//          1->OMRON NJ     sRef = "na"  sVal="HMI.In.iCod_Alarm1[x]"
//iNumAlm: # di alm (x debug)
//#F
INT	 
FUNCTION GetAlmMsgBank(STRING sRef, STRING sVal, INT iPLCType, INT iNumAlm = -1)
	INT	 iMsgBank;
	INT	 iTemp;
	INT	 iVal;
	INT	 iRef;
	INT	 iDummy;
	STRING sSiemensRef = "DB15.DBB";
	
	IF sVal = "" AND iNumAlm <> -1 THEN
		Message("GetAlmMsgBank(" + sRef + "," + sVal + ", 1)", "Riferimento banco allarme nullo! AL" + IntToStr(iNumAlm), 48);
		RETURN -1;
	END
	SELECT CASE iPLCType
	CASE 0 !OMRON CJ
		iVal = StrToReal(StrRight(sVal, 3));
	CASE 1 !SIEMENS
		iRef = StrLength(sSiemensRef);
		iTemp = StrLength(sVal);
		iDummy = iTemp - iRef;
		IF iDummy >=0 THEN
			iVal = StrToInt(StrRight(sVal, iDummy));
		ELSE
			IF iNumAlm <> -1 THEN
				Message("GetAlmMsgBank(" + sRef + "," + sVal + ", 1)->Siemens", "Errore banco: allarme: " + IntToStr(iNumAlm), 48);
			END
		END
	CASE 2 !OMRON NJ
		iMsgBank = StrToInt(StrExtract(sVal, "[", "]", False));
		RETURN iMsgBank;
	END SELECT
	iRef = StrToInt(sRef);
	iMsgBank = iVal - iRef;
	IF iMsgBank > lbNumMsgBank - 1 THEN
		!capita quando si importano vecchie liste e il source PLC non è configurato con l'offset corretto
		Message("GetAlmMsgBank(" + sRef + "," + sVal + "," + IntToStr(iPLCType) +") Controllare Sorgente Alm PLC",
		"# banco allarme Troppo alto! " + IntToStr(iMsgBank) + " Verificare colonna MSGREF in LDWINAlmSource.dbf", 48);
		RETURN -1;
	END
	RETURN iMsgBank;
END

//#I
//Attiva un advalm(TEST)
//#F
FUNCTION TestAdvAlm(INT iAdvAlmRecNo, INT iIsOn = True)
	bmAdvAlmOn[iAdvAlmRecNo] = iIsOn;
END

//#I
//Ricava il nome di un allarme
//iNumAlm: nome dell'allarme che si vuole ricavare
//OUT: nome dell'allarme del tipo "ALxyz"
//#F
STRING 
FUNCTION GetNomeAllarme(INT iNumAlm)
	INT	 iDummy = iNumAlm;
	STRING sName;
	
	QuePeek(hgQueAlmSel, iDummy, sName, 2);
	RETURN sName;
END

//#I
//Ricava il nome esteso di un allarme da usare nei rpt di cfg o nei tooltips
//IN: sNome: nome dell'allarme, sDesc: descrizione del campo "DESC" dei db di Citect degli allarmi
//#F
STRING 
FUNCTION GetRptNomeAlm(STRING sNome, STRING sDesc)
	STRING sDummy;
	STRING sDummy2;
	INT	 iPos = -1;
	
	sDummy2 = sNome;
	IF sDesc <> "" THEN
		sDummy = StrLeft(sDesc, 1);
		IF sDummy <> "{" THEN
			sDummy2 = sDummy2 + " " + sDesc;
		ELSE
			iPos = StrSearch(0, sDesc, "HSTGetProc(");
			IF iPos > 0 THEN
				iPos = iPos + StrLength("HSTGetProc(");
				sDummy = StrMid(sDesc, iPos, 1);
				sDummy2 = sDummy2 + " " + HSTGetProc(StrToInt(sDummy));
			ELSE
				sDummy2 = sDummy2 + " ...";
			END
			!ErrLog("sDummy2 = " + sDummy2 + ", sDesc = " + sDesc + " , sDummy = " + sDummy);
		END
	END
	RETURN sDummy2;
END

//#I
//Restituisce il banco allarme ed il bit con i dati presi dal csv in formato banco#bit
//OCIO: essendo banchi da 32 bit, si leggono 2locazioni consecutive da 16 sul PLC, quindi i le prime due locaizoni sono sul banco 0 e così via
//IN:
//   iNumBit: grandezza dei banchi PLC (8-16 bit)
//   iRef:indirizzo di partenza del primo banco ex 120
//   sVal: indirizzzo dell'allarme ex 121.01
//   iPLCType: tipo di plc: 0->OMRON 1->SIEMENS
//   iIdSorg: id di sorgente
//   sALM: allarme che si sta elaborando ((per Debug e messaggistica errori)
//OUT:
//   banco e bit calcolati in formato banco#bit
//
//CALCOLI:
//div = 32 / iNumBit
//sVal = "yyy.xx" si separa in bank=yyy e bit=xx separando la stringa sul .
//bancoFinale = (bank - iRef) / div
//bitFinale = bit + (((bank - iRef)MOD div) * iNumBit)
//
//#F
STRING 
FUNCTION GetAlmBankAndBit(INT iNumBit, INT iRef, STRING sVal, INT iPLCType, INT iIdSorg = -1, STRING sALM = "AL000")
	INT	 iDiv;
	INT	 iBankTemp;
	INT	 iBankPlc;
	INT	 iBitPlc;
	INT	 iPosSep;
	INT	 iLen;
	INT	 iBank;
	INT	 iBit;
	INT	 iVal;
	STRING sRet;
	STRING sDummy;
	STRING sNum;
	STRING sSiemens;
	INT	 iDummy;
	STRING sOmronNJRef = "HMI.In.diAlarm";
	
	!ErrLog("getAlmBankAndBit(" + IntToStr(iNumBit) + "," + IntToStr(iRef) + "," + sVal + "," + IntToStr(iPLCType) + "," + IntToStr(iIdSorg) + ")");
	IF iPLCType <> 2 THEN !non OMRON NJ
		IF iPLCType = 1 THEN !SIEMENS ha la M davanti all'indirizzo
			iLen = StrLength(sVal);
			sDummy = StrRight(sVal, iLen - 1);
		ELSE !OMRON
			sSiemens = StrLeft(sVal, 1);
			IF sSiemens <> "M" THEN
				sDummy = sVal;
			ELSE
				Message("getAlmBankAndBit(.)", "La lista è per un PLC Omron ma ho: " + sVal, 32);
			END
		END
		//separo l'indirizzo(utilizzando il . come separatore)
		iLen = StrLength(sDummy);
		iPosSep = StrSearch(0, sDummy, ".");
		IF iPosSep > -1 THEN
			iBankPlc = StrToInt(StrLeft(sDummy, iPosSep));
			!iBitPlc = StrToInt(StrRight(sDummy, iLen - iPosSep - 1));
			iDummy = iLen - iPosSep - 1;
			IF iDummy > 0 THEN
				iBitPlc = StrToInt(StrRight(sDummy, iDummy));
			ELSE
				ErrLog("getAlmBankAndBit(" + IntToStr(iNumBit) + "," + IntToStr(iRef) + "," + sVal + "," + IntToStr(iPLCType) + ") Strrigt <= 0");
			END
			//------
			iDiv = imNumBitTag/iNumBit;
			iBankTemp = iBankPlc - iRef;
			iBank = iBankTemp / iDiv; !contiene il valore intero del banco
			iBit = iBitPlc + ((iBankTemp MOD iDiv) * iNumBit);
			sRet = IntToStr(iBank) + "#" + IntToStr(iBit);
		ELSE
			sDummy = " getAlmBankAndBit(" + IntToStr(iNumBit) + "," + IntToStr(iRef) + "," + sVal + "," + IntToStr(iPLCType) + ",->" + sALM + "<-) Err ^".^" non trovato";
			!ErrLog("getAlmBankAndBit(" + IntToStr(iNumBit) + "," + IntToStr(iRef) + "," + sVal + "," + IntToStr(iPLCType) + ") Err ^".^" non trovato");
			ErrLog(sDummy);
			Message("Errore", sDummy + "^n 1. L'import si aspetta un [banco.bit] che non è stata specificato (vuoto)", 16);
		END
	ELSE !OMRON NJ - ha banchi a 32 bit
		//finchè non si trova un modo più elegante bisogna seguire questa specifica:
		//PLC -   HMI.In.diAlarm1[0-4]->banchi mem 0-4    HMI.In.diAlarm2[0-1]->banchi mem 5-6
		//PLCVI - HMI.In.diAlarm1[5]->banco mem 0    HMI.In.diAlarm2[2]->banco mem 1
		//PLC GMCR - HMI.In.diAlarmGMCR_TO_HMI[0-1] -> banchi mem 0-1 -> nessuna operazione aggiuntiva
		//se trovo HMI.In.diAlarm2[x].y il banco corrispondente è 5+x, perchè nell'array lungo 7 dichiarato come tag degli allarmi,sono 5 primari e 2 secondari
		SELECT CASE iIdSorg
		CASE 8!GMCR
			iVal = -1; !GMCR-> salto il successivo case di iVal in modo da estrarre subito le informazioni
		CASE ELSE!default
			iRef = StrLength(sOmronNJRef);
			IF StrSearch(0, sVal, sOmronNJRef) <> -1 THEN !verifica se la stringa di ingresso è un indirizzamento valido ES: quando ho dei gran var e all'improvviso si presenta un STD che non c'entra una beata minchia
				sNum = StrMid(sVal,iRef, 1);
				IF sNum <> "" THEN
					iVal = StrToInt(StrMid(sVal,iRef, 1)); !ottengo la § di "HMI.In.diAlarm§"
				ELSE
					Message("getAlmBankAndBit(" + IntToStr(iNumBit) + "," + IntToStr(iRef) + "," + sVal + "," + IntToStr(iPLCType) + "," + IntToStr(iIdSorg) + ")", " Cod HMI.In.diAlarm§ non trovato su " + sALM, 48);
					ErrLog("getAlmBankAndBit(" + IntToStr(iNumBit) + "," + IntToStr(iRef) + "," + sVal + "," + IntToStr(iPLCType) + "," + IntToStr(iIdSorg) + ") Cod HMI.In.diAlarm§ non trovato su " + sALM);
				END
			ELSE
				Message("getAlmBankAndBit(" + IntToStr(iNumBit) + "," + IntToStr(iRef) + "," + sVal + "," + IntToStr(iPLCType) + "," + IntToStr(iIdSorg) + ")", sVal + " vs HMI.In.diAlarm§ Errore su " + sALM, 48);
				ErrLog("getAlmBankAndBit(" + IntToStr(iNumBit) + "," + IntToStr(iRef) + "," + sVal + "," + IntToStr(iPLCType) + "," + IntToStr(iIdSorg) + ") " + sVal + " vs HMI.In.diAlarm§ Errore su " + sALM);
			END
		END SELECT
		
		iBank = StrToInt(StrExtract(sVal,"[","]",False));
		SELECT CASE iVal
		CASE 1 !diAlarm1
			IF iBank = 5 THEN !PLC
				iBank = 0;
			END
		CASE 2 !diAlarm2
			IF iBank < 2 THEN !PLC
				iBank = iBank + 5;
			ELSE !PLCVI
				iBank = 1;
			END
		END SELECT
		sDummy = StrExtract(sVal, "[", "", False); !ottengo qualcosa del tipo "x].y" x=banco y=bit
		iBit = StrToInt(StrExtract(sDummy, ".", "", False)); !ottengo la y
		sRet = IntToStr(iBank) + "#" + IntToStr(iBit);
	END
	RETURN sRet;
END

//#I
//Restituisce un messaggio di descrizione allarme
//IN: iAdvAlmRecNo: # di record advalm
//    bSPCStringGetArray: True: ricava il messaggio dalla struttura dati collegata a SPCStringGetArray(.)
//#F
STRING 
FUNCTION GetAdvAlmMsg(INT iAdvAlmRecNo, INT bSPCStringGetArray = False) !20110
	!se l'allarme appartiene alla sorgente 5[LOA L-PRO Socket] allora viene dal pacchetto 14 da DCU, quindi il contenuto è nell'array sulla DLL con handle hsAdvAlmMsg
	IF bSPCStringGetArray = True THEN
		RETURN SPCStringGetArray(hsAdvAlmMsg, imAdvAlmSourceMsgOffset[imAdvAlmSource[iAdvAlmRecNo]] + imAdvAlmMsgBank[iAdvAlmRecNo]);
	ELSE
		!RETURN IntToStr(igCopiaAdvAlmMsg[imAdvAlmSourceMsgOffset[imAdvAlmSource[iAdvAlmRecNo]] + imAdvAlmMsgBank[iAdvAlmRecNo]]);
		RETURN IntToStr(GetIntAdvAlmMsg(iAdvAlmRecNo, bSPCStringGetArray = False));
	END
END

//#I
//Restituisce un messaggio di descrizione allarme
//IN: iAdvAlmRecNo: # di record advalm
//    bSPCStringGetArray: True: ricava il messaggio dalla struttura dati collegata a SPCStringGetArray(.)
//#F
INT
FUNCTION GetIntAdvAlmMsg(INT iAdvAlmRecNo, INT bSPCStringGetArray = False) !20110
	!se l'allarme appartiene alla sorgente 5[LOA L-PRO Socket] allora viene dal pacchetto 14 da DCU, quindi il contenuto è nell'array sulla DLL con handle hsAdvAlmMsg
	IF bSPCStringGetArray = True THEN
		RETURN SPCStringGetArray(hsAdvAlmMsg, imAdvAlmSourceMsgOffset[imAdvAlmSource[iAdvAlmRecNo]] + imAdvAlmMsgBank[iAdvAlmRecNo]);
	ELSE
		RETURN igCopiaAdvAlmMsg[imAdvAlmSourceMsgOffset[imAdvAlmSource[iAdvAlmRecNo]] + imAdvAlmMsgBank[iAdvAlmRecNo]];
	END
END

//#I
//
//#F
INT	 
FUNCTION GetAlmFromSource(INT iIdSource, INT iPos)
	!ErrLog("GetAlmFromSource--> almSource:" +IntToStr(iIdSource) + "- Bank:" + IntToStr(imAdvAlmSourceOffset[iIdSource] + iPos) + "- valore dopo scrittura:" + IntToStr(igCopiaAdvAlmMsg[imAdvAlmSourceOffset[iIdSource] + iPos]));
	RETURN imCopiaAdvAlm[imAdvAlmSourceOffset[iIdSource] + iPos];
END

//#I
//
//#F
INT	 
FUNCTION GetAlmMsgFromSource(INT iIdSource, INT iPos)
	!ErrLog("GetAlmMsgFromSource--> almSource:" +IntToStr(iIdSource) + "- Bank:" + IntToStr(imAdvAlmSourceMsgOffset[iIdSource] + iPos) + "- valore dopo scrittura:" + IntToStr(igCopiaAdvAlmMsg[imAdvAlmSourceMsgOffset[iIdSource] + iPos]));
	RETURN igCopiaAdvAlmMsg[imAdvAlmSourceMsgOffset[iIdSource] + iPos];
END

//#I
//Imposta un valore su un elemento di copia degli ad alm
//IN: iIdSource: id di sorgente
//    iPos: posizione
//    iVal: valore
//#F
FUNCTION SetAlmFromSource(INT iIdSource, INT iPos, INT iVal)
	imCopiaAdvAlm[imAdvAlmSourceOffset[iIdSource] + iPos] = iVal;
	!ErrLog("SetAlmFromSource--> almSource:" +IntToStr(iIdSource) + "- Bank:" + IntToStr(imAdvAlmSourceOffset[iIdSource] + iPos) + "- valore dopo scrittura:" + IntToStr(igCopiaAdvAlm[imAdvAlmSourceOffset[iIdSource] + iPos]));
END

//#I
//Riversa un bit pattern su una specifica locazione di un buffer di scansione
//iIdSource: id della sorgente
//iPos: posizione di offset
//iVal: bit pattern
//#F
FUNCTION SetAlmMsgFromSource(INT iIdSource, INT iPos, INT iVal)
	igCopiaAdvAlmMsg[imAdvAlmSourceMsgOffset[iIdSource] + iPos] = iVal;
	!ErrLog("SetAlmMsgFromSource(iIdSource=" + IntToStr(iIdSource) + ",iPos=" + IntToStr(iPos) + ",iVal=" + IntToStr(iVal) + ") MsgOffset=" + IntToStr(imAdvAlmSourceMsgOffset[iIdSource]));
	!ErrLog("MsgPos=" + IntToStr(imAdvAlmSourceMsgOffset[iIdSource] + iPos) + " almoffset=" + IntToStr(imAdvAlmSourceOffset[iIdSource]));
	!ErrLog("-val alm:" + IntToStr(igCopiaAdvAlm[imAdvAlmSourceOffset[iIdSource]]));
END

//#I
//Restituisce la sorgente a cui appartiene un determinato allarme BFG
//IN: iNumAlm: id di allarme BFG
//OUT: id di sorgente a cui appartiene
//#F
INT	 
FUNCTION GetSourceFromAlmNum(INT iAlmNum)
	INT	 iCont;
	INT	 iMin;
	INT	 iMax;
	INT	 hSource;
	
	FOR iCont = 0 TO imNumAlmSource - 1 DO
		hSource = imAlmSourceId[iCont];
		iMin = imAlmSourceMinAlm[hSource];
		iMax = imAlmSourceMaxAlm[hSource];
		SELECT CASE iAlmNum
		CASE iMin TO iMax
			RETURN hSource;
		END SELECT
	END
	RETURN -1;
END

//#I
//Funzione di test degli allarmi
//#F
FUNCTION TestAlmRT(INT iModo = 0, INT iVal = 255, INT iNumSock = 1)
	INT	 iCont = 0;
	INT	 iCont2;
	
	!resetta tutti i valori
	WHILE iCont < 16 DO
		FOR iCont2 = 0 TO 3 DO
			SetTXInfoPacket(iCont + iCont2, iNumSock, 0);
		END
		iCont = iCont + 4;
	END
	!setto i valori a mio piacimento
	SELECT CASE iModo
	CASE 0
		SetTXInfoPacket(0, iNumSock, 2);
		SetTXInfoPacket(4, iNumSock, 4);
	CASE 1
		iCont = 0;
		WHILE iCont < 16 DO
			FOR iCont2 = 0 TO 3 DO
				SetTXInfoPacket(iCont + iCont2, iNumSock, iVal);
			END
			iCont = iCont + 4;
		END
	END SELECT
	SocketAlmRTDecode(iNumSock);
END

//#I
//Imposta il valore di un elemento dell'array bmAdvAlmOn[.]
//IN: iAdvAlmRecNo: positione nello elenco degli allarmi advanced
//    iIsON: stato desiderato da impostare
//#F
FUNCTION SetAdvAlm(INT iAdvAlmRecNo,INT iIsOn = True)
	bmAdvAlmOn[iAdvAlmRecNo] = iIsOn;
END

//#I
//Forza lo stato di un allarme
//IN: iNumAlm: # dell'allarme secondo la lista BFG
//    iIsON: stato desiderato da impostare
//#F
FUNCTION SetAdvAlmFromNumAlm(INT iNumAlm, INT iIsOn = True)
	INT	 iDummy;
	INT	 iAlmSource = GetSourceFromAlmNum(iNumAlm);
	INT	 iAdvAlmRecNo = hmAdvAlmBFGCodeTag[iNumAlm];
	INT	 iBank;
	
	!ErrLog("SetAdvAlmFromNumAlm(" + IntToStr(iNumAlm) + "," + IntToStr(iIsOn) + ")");
	IF iAdvAlmRecNo <> -1 THEN
		iBank = imAdvAlmBank[iAdvAlmRecNo];
		iDummy = GetAlmFromSource(iAlmSource, iBank);
		iDummy = SetBit(iDummy, imAdvAlmBit[iAdvAlmRecNo], iIsOn);
		SetAlmFromSource(iAlmSource, iBank, iDummy);
	ELSE
		ErrLog("SetAdvAlmFromNumAlm(" + IntToStr(iNumAlm) + "," + IntToStr(iIsOn) + ") Allarme non dichiarato");
	END
END

//#I
//Ricava lo stato di un allarme 3308
//IN: iNumAlm: # dell'allarme secondo la lista BFG
//OUT: Stato allarme secondo valore vettore bmAdvAlmOn[.]
//#F
INT	 
FUNCTION GetAdvAlmFromNumAlm(INT iNumAlm)
	INT	 iAdvAlmRecNo = hmAdvAlmBFGCodeTag[iNumAlm];
	
	!iAdvAlmRecNo = hmAdvAlmBFGCodeTag[iNumAlm];
	IF iAdvAlmRecNo <> -1 THEN
		iAdvAlmRecNo = bmAdvAlmOn[iAdvAlmRecNo];
	ELSE
		iAdvAlmRecNo = False;
		ErrLog("GetAdvAlmFromNumAlm(" + IntToStr(iNumAlm) + ") Allarme non dichiarato");
	END
	RETURN iAdvAlmRecNo;
END


//#I
//estrae tutti i caratteri compresi tra due caratteri specifici
//IN:
//   sStr: stringa da cui estrarre la sottostringa
//   sCharStart:carattere da cui iniziare la copia
//   sCharEnd: carattere in cui fermare la copia
//   bIncludeCtrlChar: indica se includere nella sottostringa i caratteri di controllo (sCharStart, sCharEnd)
//OUT:
//   sottostringa
//#F
STRING 
FUNCTION StrExtract(STRING sStr, STRING sCharStart, STRING sCharEnd, INT bIncludeCtrlChar)
	STRING sRet = "";
	STRING sChar;
	INT	 iLen;
	INT	 iCont;
	INT	 bCopy = False;
	
	iLen = StrLength(sStr);
	FOR iCont = 0 TO iLen - 1 DO
		sChar = StrMid(sStr,iCont, 1);
		IF sChar = sCharStart AND bCopy = False THEN
			bCopy = True;
			IF bIncludeCtrlChar = True THEN
				sRet = sRet + sChar;
			END
		ELSE
			IF sChar = sCharEnd THEN
				bCopy = False;
				iCont = iLen +1;
				IF bIncludeCtrlChar = True THEN
					sRet = sRet + sChar;
				END
			ELSE
				IF bCopy = True THEN
					sRet = sRet + sChar;
				END
			END !sChar = sCharEnd
		END !sChar = sCharStart
	END !for
	RETURN sRet;
END

//#I
//data una tag ed il puntatore a variable.dbf estrae l'aventuale dimensione dell'array
//IN:
//   sTagName:nome tag da cercare in variable.dbf
//   hDev: puntatore a variable.dbf (COM)
//OUT:
//   -2: tag not found
//   -1: la tag non è un array
//   >0: dimensione dell'array
//#F
INT	 
FUNCTION GetTagIndex(STRING sTagName, INT hDev)
	INT	 iRet;
	INT	 iErr;
	STRING sVarAddr;
	STRING sVarIndex;
	
	DevFirst(hDev);
	iErr = DevFind(hDev, sTagName, "NAME");
	IF iErr = 0 THEN !tag found
		sVarAddr = DevGetField(hDev, "ADDR");
		sVarIndex = StrExtract(sVarAddr, "[", "]", False);
		IF sVarIndex <> "" THEN !found
			iRet = StrToInt(sVarIndex);
		ELSE
			iRet = -1;
		END
	ELSE !tag not found
		iRet = -2;
	END
	RETURN iRet;
END

//#I
//
//#F
FUNCTION ResetNumAlmSource()
	INT	 iCont;
	
	imNumAlmSource = 0;
	!ErrLog("azzeramento indici advalm");
	FOR iCont = 0 TO lbNumAdvAlmRec - 1 DO
		imAdvAlmSource[iCont] = -1;
		hmAdvAlmNumRecTag[iCont] = -1;
		imAdvAlmBank[iCont] = -1;
		imAdvAlmBit[iCont] = -1;
		imAdvAlmMsgBank[iCont] = -1;
		imAdvAlmMsgVal[iCont] = -1;
	END
	FOR iCont = 0 TO lbNumAlmTotPareto - 1 DO
		hmAdvAlmBFGCodeTag[iCont] = -1;
		imAdvAlmBFGCodeTagRootVar[iCont] = -1;
	END
	FOR iCont = 0 TO 19 DO
		hmAdvAlmBFGCodeTagMsgQue[iCont] = -1;
	END
END

//#I
//Restituisce la posizione di un allarme BFG nel buffer dei sottomessaggi di allarme
//IN: iBFGAlm: allarme lista BFG
//OUT: posizione relativa nell'array di sottomessaggio (da aggiungere con l'offset)
//#F
INT	 
FUNCTION AdvAlmGetPosMsg(INT iBFGAlm)
	iBFGAlm = hmAdvAlmBFGCodeTag[iBFGAlm];
	IF iBFGAlm > -1 THEN
		RETURN imAdvAlmMsgBank[iBFGAlm];
	ELSE
		RETURN -1;
	END
END

//#I
//Restituisce l'offset della sorgente allarmi
//IN: iNumSource: sorgente da cui si desidera ricavare l'offset
//#F
INT	 
FUNCTION GetAdvAlmSourceOffset(INT iNumSource)
	RETURN imAdvAlmSourceOffset[iNumSource];
END

//#I
//Restituisce l'offset multimessaggi della sorgente allarmi
//IN: iNumSource: sorgente da cui si desidera ricavare l'offset
//#F
INT	 
FUNCTION GetAdvAlmMsgSourceOffset(INT iNumSource)
	RETURN imAdvAlmSourceMsgOffset[iNumSource];
END

//#I
//Restituisce il tipo della sorgente allarmi
//#F
INT	 
FUNCTION GetAlmSourceType(INT iNumSource)
	RETURN imAlmSourceType[iNumSource];
END

//#I
//Restituisce il # di advalm
//#F
INT	 
FUNCTION GetimNumAdvAlm()
	RETURN imNumAdvAlm;
END

//#I
//Forza lo stato di un allarme
//IN: iAdvAlmRecNo: # dell'allarme secondo la lista BFG
//    iIsON: stato desiderato da impostare
//    iMsgValSet: messaggio da impostare (>0)
//#F
FUNCTION SetAdvAlmFromAlmRecNo(INT iAdvAlmRecNo, INT iIsOn = True, INT iMsgValSet = -1)
	INT	 iDummy;
	INT	 iAlmSource = imAdvAlmSource[iAdvAlmRecNo];
	INT	 iBank = imAdvAlmBank[iAdvAlmRecNo];
	INT	 iMsgVal;
	
	!ErrLog("SetAdvAlmFromAlmRecNo(" + IntToStr(iAdvAlmRecNo,) + "," + IntToStr(iIsOn) + ")");
	!iAlmSource =  imAdvAlmSource[iAdvAlmRecNo];
	!iBank = imAdvAlmBank[iAdvAlmRecNo];
	IF iMsgValSet > -1 THEN
		iMsgVal = iMsgValSet;
	ELSE
		iMsgVal = imAdvAlmMsgVal[iAdvAlmRecNo];
	END
	iDummy = GetAlmFromSource(iAlmSource, iBank);
	iDummy = SetBit(iDummy, imAdvAlmBit[iAdvAlmRecNo], iIsOn);
	IF iMsgVal <> -1 THEN
		SetAdvAlmMsg(iAdvAlmRecNo, iMsgVal);
	END
	SetAlmFromSource(iAlmSource, iBank, iDummy);
END

//#I
//Imposta un valore nell'array igCopiaAdvAlmMsg[.]
//IN: iAdvAlmRecNo: # di record
//    iVal: valore da impostare
//#F
FUNCTION SetAdvAlmMsg(INT iAdvAlmRecNo, INT iVal)
	igCopiaAdvAlmMsg[imAdvAlmSourceMsgOffset[imAdvAlmSource[iAdvAlmRecNo]] + imAdvAlmMsgBank[iAdvAlmRecNo]] = iVal;
END

//#I
//Dato il # di record restituisce il banco di appartenenza di un allarme
//IN: iNumRec: # di record
//OUT: banco di appartenenza
//#F
INT	 
FUNCTION Get_AdvAlmMsgBank(INT iNumRec)
	RETURN imAdvAlmMsgBank[iNumRec];
END

//#I
//
//#F
INT	 
FUNCTION Get_AdvAlmMsgVal(INT iNumRec)
	RETURN imAdvAlmMsgVal[iNumRec];
END

//#I
//
//#F
INT	 
FUNCTION Get_AdvAlmSourceId(INT iNumRec)
	RETURN imAdvAlmSource[iNumRec];
END

//#I
//
//#F
STRING 
FUNCTION Get_AdvAlmSourceName(INT iIdAlmSorg)
	RETURN smAlmSourceName[iIdAlmSorg];
END

//#I
//Copia le informazioni degli allarmi necessarie dalla DCU al PLC
//#F
FUNCTION CopyDCUInfoToPLC()
	INT	 iCont;
	INT	 iNumBank = imAdvAlmSourceOffset[1];
	INT	 iNumBankPLC = imAdvAlmSourceOffset[0];
	INT	 iNumAlmBankToCopy = 3;
	INT	 bLDWINCustomLanfranchi;
	
	IF igLDWINCustomerID = 26 THEN !Lanfranchi
		bLDWINCustomLanfranchi = True;
	END
	bgLDWINTaskOn[53] = True;
	WHILE bgLDWINTaskOn[53] = True DO
		!Copia Allarmi
		IF bLDWINCustomLanfranchi = True THEN
			FOR iCont = 0 TO 6 DO
				!ErrLog("alm PLC pos = " + IntToStr(iCont) + " offset = " + IntToStr(imAdvAlmSourceOffset[0]) + " Val = " + IntToStr(igCopiaAdvAlm[iCont + iNumBankPLC]));
				TagWrite("igAlmPLC", IntToStr(imCopiaAdvAlm[iCont + iNumBankPLC]), iCont, True, "LDWIN");
			END
		END
		FOR iCont = 0 TO iNumAlmBankToCopy - 1 DO
			!ErrLog("da dcu a plc pos = " + IntToStr(iCont) + " bank = " + IntToStr(iNumBank) + "; val = " + IntToStr(igCopiaAdvAlm[iCont + iNumBank]));
			TagWrite("itPLCDCUAlarms", IntToStr(imCopiaAdvAlm[iCont + iNumBank]), iCont, True, "LDWIN");
		END
		FOR iCont = 0 TO 19 DO
			!ErrLog("msg pos = " + IntToStr(iCont) + " offset = " + IntToStr(imAdvAlmSourceMsgOffset[1]) + " Val = " + IntToStr(igCopiaAdvAlmMsg[iCont + imAdvAlmSourceMsgOffset[1]]));
			TagWrite("itPLCDCUAlmMsg", IntToStr(igCopiaAdvAlmMsg[iCont + imAdvAlmSourceMsgOffset[1]]), iCont, True, "LDWIN");
		END
		SleepMS(1000);
	END
END

//#I
//Ricava il valore del banco allarmi di un particolare advalm
//IN: iNumRec: # di record advalm
//OUT: banco del record
//#F
INT	 
FUNCTION Get_AdvAlmBank(INT iNumRec)
	RETURN imAdvAlmBank[iNumRec];
END

//#I
//Ricava il valore del # di bit di un particolare advalm
//IN: iNumRec: # di record advalm
//OUT: bit del record
//#F
INT	 
FUNCTION Get_AdvAlmBit(INT iNumRec)
	RETURN imAdvAlmBit[iNumRec];
END

//#I
//Ricava il valore del # di bit di un particolare advalm
//IN: iNumRec: # di record advalm
//OUT: True: l'allarme è critico 21206
//#F
INT	 
FUNCTION Get_FAckAdvAlm(INT iNumRec)
	RETURN bmFAckAdvAlm[iNumRec];
END

//#I
//Ricava il velore del boolean bmStatoMac1OR5
//OUT: valore del boolean
//#F
INT	 
FUNCTION GetStatoMac1OR5()
	RETURN bmStatoMac1OR5;
END

//#I
//
//#F
FUNCTION RegANGrScritteIco(INT iAN)
	hmANGrScritteIco = iAN;
END

INT	 imColGiallo;
INT	 imColVerde;
INT	 imColRosso;
INT	 imColBlu1;
INT	 imColBckAlm;
//#I
//
//#F
FUNCTION InitTemplScritte()
	ErrLog("InitTemplScritte");
	imNumScrTempl = 0;
	!imColGrigio = MakeCitectColour(191, 191, 191);
	imColGiallo = MakeCitectColour(255, 255, 0);
	imColVerde = MakeCitectColour(0, 255, 0);
	imColRosso = MakeCitectColour(255, 0, 0);
	imColBlu1 = MakeCitectColour(0, 0, 255);
	imColBckAlm = MakeCitectColour(0, 30, 30);
	!Icone di stato macchina
	DefBoxScritte(0, 448, 0, 224, 45, 91, "@(Stato Macchina)");
	DefBoxScritteStato(0, 1, imColGiallo, "@(Ins. Dati)");
	DefBoxScritteStato(0, 2, imColVerde, "@(Automatico)");
	DefBoxScritteStato(0, 3, imColRosso, "@(Manuale)");
	DefBoxScritteStato(0, 4, imColBlu1, "@(Joystick)");
	DefBoxScritteStato(0, 5, imColGiallo, "@(Homing)");
	DefBoxScritteStato(0, 6, imColGiallo, "@(Altezza)");
	DefBoxScritteStato(0, 7, imColGiallo, "@(Rot. Inversa)");
	!Icone di bypass
	DefBoxScritte(1, 448, 48, 224, 45, 91, "@(Bypass)");
	DefBoxScritteStato(1, 0, imColGiallo, "[LD] @(Attivo)");
	DefBoxScritteStato(1, 1, imColVerde, "[LD] @(Disattivo)");
	DefBoxScritteStato(1, 2, imColGiallo, "[VI] @(Attivo)");
	DefBoxScritteStato(1, 3, imColVerde, "[VI] @(Disattivo)");
	DefBoxScritteStato(1, 4, imColGiallo, "[VS] @(Attivo)");
	DefBoxScritteStato(1, 6, imColGiallo, "[VS] @(Disattivo)");
	DefBoxScritteStato(1, 7, imColGiallo, "[CTP] @(Attivo)");
	DefBoxScritteStato(1, 8, imColVerde, "[CTP] @(Disattivo)");
	!Icone sistema MES
	DefBoxScritte(2, 306, 48, 224, 45, 91, "@(MES)");
	DefBoxScritteStato(2, 0, imColVerde, "@(Inattivo)");
	DefBoxScritteStato(2, 1, imColVerde, "@(In Funzione)");
	DefBoxScritteStato(2, 2, imColGiallo, "@(In Pausa)");
	DefBoxScritteStato(2, 3, imColGiallo, "@(In Riavvio)");
	DefBoxScritteStato(2, 4, imColGiallo, "@(Arrestato)");
	DefBoxScritteStato(2, 5, imColVerde, "@(Abortito)");
	DefBoxScritteStato(2, 6, imColGiallo, "@(Reset)");
	DefBoxScritteStato(2, 255, imColRosso, "@(Non Asservito)");
	!box allarme primario
	DefBoxScritte(3, 334, 0, 224, 13, 111, "", 1);
	DefBoxScritteStato(3, 1, imColRosso, "@(Errore Critico)");
	!box allarme secondario
	DefBoxScritte(4, 334, 16, 224, 13, 111, "", 1);
	DefBoxScritteStato(4, 1, imColGiallo, "@(Errore Non Critico)");
	!Box allarme HW
	DefBoxScritte(5, 334, 32, 224, 13, 111, "", 1);
	DefBoxScritteStato(5, 1, imColGiallo, "@(Errore Hardware)");
END

//#I
//Dichiara un singolo Box
//IN: iNumBox: Id
//    iPosOffsetPosX: da aggiungere se si è in 1024*768
//    sScrIntest: intestazione principale 
//#F
FUNCTION DefBoxScritte(INT iNumBox, INT iPosX, INT iPosY, INT iPosOffsetPosX, INT iAlt, INT iLargh, STRING sScrIntest, INT iTipo = 0)
	imScrTemplPosX[iNumBox] = iPosX;
	imScrTemplPosY[iNumBox] = iPosY;
	imScrTemplPosX2[iNumBox] = iPosX + iLargh;
	imScrTemplPosY2[iNumBox] = iPosY + iAlt;
	imAltBox[iNumBox] = iAlt;
	imLarghBox[iNumBox] = iLargh;
	imPosOffsetPosX[iNumBox] = iPosOffsetPosX;
	IF sScrIntest <> "" THEN
		smScrSuTemplInt[iNumBox] = StrToLocalText(sScrIntest);
	END
	!array con le scritte di stato
	imScrTepmlBoxType[iNumBox] = iTipo;
	imNumScrTempl = imNumScrTempl + 1;
END

INT	 hmFontScrTemp; !font per le scritte in nero
INT	 hmFontScrChiaro; !font per le scritte in nero
INT	 hmFontScrTemp2; !font per le scritte in nero
INT	 hmFontScrChiaro2; !font per le scritte in nero

//#I
//Dichiara un singolo Box
//IN: iNumBox: Id di box
//    iNumStato: stato di codifica
//    iColore: colore del box
//    sScrStato: Nome in stringa dello stato
//#F
FUNCTION DefBoxScritteStato(INT iNumBox, INT iNumStato, INT iColore, STRING sScrStato)
	imScrSuTemplCol[iNumBox][iNumStato] = iColore;
	IF GetLuminance(iColore) > 50 THEN
		IF imScrTepmlBoxType[iNumBox] = 0 THEN
			hmScrTemplFont[iNumBox][iNumStato] = hmFontScrTemp;
		ELSE
			hmScrTemplFont[iNumBox][iNumStato] = hmFontScrTemp2;
		END
	ELSE
		IF imScrTepmlBoxType[iNumBox] = 0 THEN
			hmScrTemplFont[iNumBox][iNumStato] = hmFontScrChiaro;
		ELSE
			hmScrTemplFont[iNumBox][iNumStato] = hmFontScrChiaro2;
		END
	END
	sltBoxScritte[iNumStato][iNumBox] = StrToLocalText(sScrStato);
END

//#I
//Task gestione scritte template
//#F
FUNCTION ScrTemplate()
	INT	 bEnable = True;
	INT	 iWidPag;
	INT	 iColSfondo;
	INT	 iCont;
	INT	 iX1;
	INT	 iX2;
	INT	 iXIntest;
	INT	 iYIntest;
	INT	 hPlotScritte;
	INT	 iBoxStato;
	INT	 iTipo;
	INT	 hFont;
	STRING sDummy;
	
	FOR iCont = 0 TO lbNumBoxScrTemplate - 1 DO
		imScrTemplSt[iCont] = -1;
	END
	imColGrigio = MakeCitectColour(191, 191, 191);
	hmFontScrTemp   = DspFont("Arial", 12, black, -1);
	hmFontScrChiaro = DspFont("Arial", 12, imColGrigio, -1);
	!font piccoli
	hmFontScrTemp2   = DspFont("Arial", 9, black, -1);
	hmFontScrChiaro2 = DspFont("Arial", 9, imColGrigio, -1);
	InitTemplScritte();
	WHILE bEnable = True DO
		IF hmANGrScritteIco <> -1 THEN
			hPlotScritte = PlotOpen(hmANGrScritteIco, "Display", 257);
			hmANGrScritteIco = -1; !resetta AN immediatamente
			IF hPlotScritte <> -1 THEN
				!determina in che risoluzione sei per tracciare correttamente le scritte
				sDummy = PageInfo(22);
				iWidPag = StrToInt(sDummy);
				FOR iCont = 0 TO imNumScrTempl - 1 DO
					!Determina il colore dello sfondo
					iBoxStato  = imScrTemplSt[iCont];
					!determina il tipo
					iTipo = imScrTepmlBoxType[iCont];
					IF iBoxStato <> -1 THEN
						iColSfondo = imScrSuTemplCol[iCont][iBoxStato];
						!IF iWidPAg = 768 THEN
						IF iWidPag = lbLDWINScreenY THEN
							iX1 = imPosOffsetPosX[iCont] + imScrTemplPosX[iCont];
							iX2 = imPosOffsetPosX[iCont] + imScrTemplPosX2[iCont];
						ELSE
							iX1 = imScrTemplPosX[iCont];
							iX2 = imScrTemplPosX2[iCont];
						END
						SELECT CASE iTipo
						CASE 0
							iXIntest = iX1 + 4;
							iYIntest = imScrTemplPosY[iCont] + 12;
						CASE 1
							iXIntest = iX1 + 2;
							iYIntest = imScrTemplPosY[iCont] + 10;
						END SELECT
						PlotDraw(hPlotScritte, 1, 0, imColGrigio, 1, iColSfondo, iX1, imScrTemplPosY[iCont],  iX2, imScrTemplPosY2[iCont]);
						sDummy = smScrSuTemplInt[iCont];
						hFont = hmScrTemplFont[iCont][iBoxStato];
						IF sDummy <> "" THEN
							PlotText(hPlotScritte, hFont, 0, iXIntest, iYIntest, sDummy);
						END
						sDummy = sltBoxScritte[iBoxStato][iCont]; !TODO: verificare...
						!ErrLog("Scritte: " + sDummy);
						IF sDummy <> "" THEN
							IF iTipo = 0 THEN
								iYIntest = iYIntest + 24; !sui box grandi scrivila in basso di un tot
							END
							PlotText(hPlotScritte, hFont, 0, iXIntest, iYIntest, sDummy);
						END
					END
				END
				PlotClose(hPlotScritte);
			END
			!ErrLog("ScrTemplateTS" + IntToStr(hgLDWINTaskId[35]));
			TaskSuspend(hgLDWINTaskId[35]);
		ELSE
			SleepMS(100);
		END
	END
END

//#I
//Ricava luminosità di un colore secondo la formula ITU-R BT.709
//#F
INT	 
FUNCTION GetLuminance(INT iColoreRGB)
	INT	 R;
	INT	 G;
	INT	 B;
	INT	 iColPack = CitectColourToPackedRGB(iColoreRGB);
	
	R = GetRedValue(iColPack);
	G = GetGreenValue(iColPack);
	B = GetBlueValue(iColPack);
	!RETURN Sqrt(0.299 * Pow(R, 2) + 0.587 * Pow(G, 2) + 0.114 * Pow(B, 2));
	RETURN (0.2126*R + 0.7152*G + 0.0722*B);
END

//#I
//Aggiunge un record ad advalm.dbf x allarmi 
//hDevAdvAlm: puntatore a AdvAlm.dbf
//sAlmNum:       codice di allarme BFG
//sAlmNamefinal: nome dell'allarme
//iAdvAlmRecNo:  # di record (se <> -1) ignora
// 7. sBuffer: bit dell'allarme 
// 8. sBank:         banco di advalmdef
//sPriv:         privilegio
//sCat:          categoria
//sAlmDescFinal: campo desc
//iAlmMsgBankFinal: banco
//13. iAlmMsgValFinal:  valore associato al multiallarnme
//14. sComment: "any useful comment..." 
//15. bChkUnicity: True: verifica se c'è già il record e quindi lavora sul record che trovi
//16. bChkSubMsgOn: se l'unicità è attiva, oltre alla colonna "TAG", verifica anche la colonna "DESC"
//17. sFAck: doppio Ack 21206
//18. iDCUMultitesta: DCU alm testing chamber index
//#F
FUNCTION AdvAlmAddRecord(INT hDevAdvAlm,        INT hFileAlmDef, STRING sAlmNum,     STRING sAlmNameFinal, 
	INT	 iAdvAlmRecNo = -1, STRING sBuffer = "0", INT iIdSorg = 7, STRING sBank = "0",
	STRING sPriv = "4",    STRING sCat = "2",    STRING sAlmDescFinal = "{HSTGetProc(0)}", INT iAlmMsgBankFinal = -1,
	INT	 iAlmMsgValFinal = -1, STRING sComment = "", INT bChkUnicity = False, INT bChkSubMsgOn = True, STRING sFAck = "0", INT iDCUMultitesta = False)
	!INT	 iAlmMsgValFinal = -1, STRING sComment = "", INT bChkUnicity = False, INT bChkSubMsgOn = True, STRING sFAck = "0")
!INT	 iAlmMsgValFinal = -1, STRING sComment = "", INT bChkUnicity = False, INT bChkSubMsgOn = True, STRING sFAck = "0", INT bDCUMultitesta = False)
	
	STRING sExpr;
	STRING sRec = IntToStr(iAdvAlmRecNo);
	STRING sAlm;
	STRING sDummy;
	STRING sDesc;
	STRING sBankMsg;
	STRING sValMsg;
	STRING sSorg;
	INT	 iDummy = StrToInt(sAlmNum);
	INT	 bUpdate = False; !TODO: prob. obsoleto
	INT	 bFound = False; !TODO: prob. obsoleto
	INT	 iLen = 0;
	!INT iCont;
	!INT iDummy = 0;
	
	!verifica che la composizione "root" e "var" + 1 spazio non superi i 69 caratteri
	!anticamente, vedi mail Golinelli 04/05/2016 il limite è stato fissato a 65
	!iLen = StrLength(sAlmNameFinal) + 1;
	sDummy = RemoveNative(sAlmNameFinal);
	sDummy = RemovePersonalization(sDummy, sAlmNameFinal);
	iLen = StrLength(sDummy) + 1;
	//IF iDummy = 11 THEN
	//ErrLog("11 " + sAlmNameFinal + " iLen=" + IntToStr(iLen));
	//FOR iCont = 0 TO iLen DO
	//ErrLog("11 " + IntToStr(iCont) + " " + StrMid(sDummy, iCont, 1));
	//END
	//END
	!IF iLen > 69 THEN
	IF iLen > 65 THEN
		sAlm = "AL" + sAlmNum;
		Message("Scritta troppo lunga [Max 65 car.] Errore", sAlm + " " + sAlmNameFinal + " la somma ROOT + VAR + 1 spazio deve essere <=65 car.^n Controllare Lemmi Lista Allarmi", 48);
		!si ipotizza che l'allarme sia nella forma @(...) @(...)
		!in caso di strabordamento, la stringa verrà tagliata e si aggiungerà ")" alla fine
		sDummy = sAlmNameFinal;
		sAlmNameFinal = StrLeft(sAlmNameFinal, 68) + ")"; !in emergenza, fai qualcosa!
		Message(sAlm, "Troncamento provvisorio lemma: " + sDummy + " --> " + sAlmNameFinal, 48);
	END
	!TODO: da testare: sta cosa si usa se si desidera eseguire un'importazione di allarmi selettiva (es: solo quelli del VI, quando AdvAlm.dbf è già popolato di record)
	!ma direi che sta funzionalità è obsoleta perchè in ogni caso si importa sempre tutto così advalm.dbf viene azzerato tutte le volte
	IF bChkUnicity = True THEN !TODO: prob. controllo obsoleto
		DevFirst(hDevAdvAlm);
		WHILE bFound = 0 DO
			sDummy = DevGetField(hDevAdvAlm, "TAG");
			IF StrLeft(sDummy, 5) = sAlmNum THEN
				!ErrLog("Trovato: " + sAlmTag);
				IF bFound = 0 THEN !trovato almTag
					IF bChkSubMsgOn = True THEN
						sDesc = StrTrim(DevGetField(hDevAdvAlm, "DESC"));
						IF sDesc = sAlmDescFinal THEN !ok,trovato record da aggiornare
							bUpdate = True;
							bFound = True;
						ELSE !passo al prossimo record altrimenti con la ricerca si entra nel loop infinito
							bFound = DevNext(hDevAdvAlm);
						END
					ELSE
						bUpdate = True;
						bFound = True;
					END
				END
			ELSE
				IF DevNext(hDevAdvAlm) <> 0 THEN
					bUpdate = False;
					bFound = True;
				END
			END
		END !WHILE bFound
	END
	IF bUpdate = False THEN
		DevAppend(hDevAdvAlm);
	ELSE
		iAdvAlmRecNo = DevRecNo(hDevAdvAlm);
	END
	sAlm = sConvert(iDummy);
	DevSetField(hDevAdvAlm, "TAG", "AL" + sAlm + "_" +  sRec);
	!IF bDCUMultitesta = False THEN
	IF iDCUMultitesta = 0 THEN !23213
		sAlmDescFinal = AlmStrWithSeparator(sAlmDescFinal);
	END
	sAlmNameFinal = AlmStrWithSeparator(sAlmNameFinal);
	DevSetField(hDevAdvAlm, "DESC", sAlmDescFinal);
	DevSetField(hDevAdvAlm, "NAME", sAlmNameFinal);
	DevSetField(hDevAdvAlm, "PRIV", sPriv);
	DevSetField(hDevAdvAlm, "CATEGORY", sCat);
	DevSetField(hDevAdvAlm, "COMMENT", sComment);
	sExpr = "AdvAlmIsOn(" + sRec + ")";
	sBankMsg = IntToStr(iAlmMsgBankFinal);
	sValMsg = IntToStr(iAlmMsgValFinal);
	sSorg = IntToStr(iIdSorg);
	DevSetField(hDevAdvAlm, "EXPR", sExpr);
	FileWriteLn(hFileAlmDef, StrToLocalText("   //AL" + sAlm + ": " + sAlmNameFinal + " " + sAlmDescFinal));
	FileWriteLn(hFileAlmDef, "   //Sorg.: " + sSorg + " Record Advalm.dbf: " + sRec);
	IF sFAck = "1" THEN !21206
		FileWriteLn(hFileAlmDef, "   //Doppio Ack: Sì");
	ELSE
		FileWriteLn(hFileAlmDef, "   //Doppio Ack: No");
	END
	FileWriteLn(hFileAlmDef, "   //Banco: " + sBank + " Bit: " + sBuffer + " Banco sottomess.: " + sBankMsg + " Codice: " + sValMsg);
	FileWrite(hFileAlmDef, "   AdvAlmDef(" + sSorg + "," + sAlmNum + "," + sBank + "," + sBuffer + "," + sBankMsg + "," + sValMsg + "," + sRec + ",");
	FileWrite(hFileAlmDef, "^"" + sAlmNameFinal + "^",");
	!FileWriteLn(hFileAlmDef, "^"" + sAlmDescFinal + "^"," + sFAck + ");");
	FileWriteLn(hFileAlmDef, "^"" + sAlmDescFinal + "^"," + sFAck + "," + IntToStr(iDCUMultitesta) + ");"); !23213
	!Lemmi nativi in modo che ci sia retrocompatibilità in traduzione con le lite allarmi precedenti
	IF hmAlmNative > -1 THEN
		FileWriteLn(hmAlmNative, "STRING smDummy" + IntToStr(imAlmNatDummyNum) + " = ^"" + sAlmNameFinal + "^";");
		IF sAlmDescFinal <> "" THEN
			iDummy = StrSearch(0, sAlmDescFinal, "{");
			IF iDummy = -1 THEN !Se non c'è la "{"...
				imAlmNatDummyNum = imAlmNatDummyNum + 1;
				FileWriteLn(hmAlmNative, "STRING smDummy" + IntToStr(imAlmNatDummyNum) + " = ^"" + sAlmDescFinal + "^";");
			END
		END
		imAlmNatDummyNum = imAlmNatDummyNum + 1;
	END
END

//#I
//Task di supporto per nastro CTP
//#F
FUNCTION CTPSupportTask()
	INT	 iCTPOffsetSec;
	INT	 bByPass = INIParamOn(lbCfgMainLDByPass);
	STRING sDummy;
	
	bgLDWINTaskOn[11] = True;
	iCTPOffsetSec = imAdvAlmSourceOffset[6] + 2; !si spera che la sorgente allarmi CTP rimanga sempre di ID=6
	WHILE bgLDWINTaskOn[11] = True DO
		IF bByPass = True THEN !se attivo il supporto per il bypass
			bgByPassOnOff[4]   = btHMI_AbilitazioneCTP; !Nastro Fasatore: bypass
			btCTPgbSynchroMODE = bgByPassOnOff[4]; !copia per Nastro Fasatore
			SetByPassStato(4);
		END
		IF GetCommAlmFail(2) = False THEN
			btPLCHMICTPSecAlmOn = (imCopiaAdvAlm[iCTPOffsetSec] <> 0) OR (imCopiaAdvAlm[iCTPOffsetSec + 1] <> 0);
			IF bgByPassOnOff[4] = True THEN
				sDummy = TagRead("itCTPActualFmtData_Params_dCommandSpeedtoBFG", 0, "LDWIN");
				IF sDummy <> "" THEN
					itPLCVelCTP_BFG = StrToInt(sDummy);
				END
			END
		END
		SleepMS(500);
	END
END

//#I
//Apre la tabella LDWINALArmList.csv
//OUT: Puntatore al device csv, oppure -1 in caso di errore
//#F
INT	 
FUNCTION LDWINAlarmListOpen()
	INT	 hDev = -1;
	INT	 bEnable = True;
	INT	 hFile = -1;
	INT	 iCont;
	INT	 iChar;
	STRING sVal;
	STRING sFormat = "{IdAlm,10},{CatAlm,3},{LevelAlm,10},{PLCCode,40},{SubMsgCode,3},{PhoenixCode,3},{IdComp,120},{AlmIta,120},{Priv,3},{En,3}";
	
	IF FileExist(smPathCsv) THEN
		!IF INIParamOn(lbCfgMyCriticalAlmDoubleAck) = True THEN
		IF INIParamOn(lbCfgMyCriticalAlmDoubleAck) = True OR INIParamOn(lbCfgMyCriticalReport) = True THEN
			sFormat = sFormat + ",{FAck,4}";
			!verifica che ci sia la colonna FACK verificando che una riga sia da 330 carqatteri complessivi
			hFile = FileOpen(smPathCsv, "r+");
			ErrSet(1);
			IF hFile > -1 THEN
				WHILE iChar <> 13 DO
					sVal = FileRead(hFile, 1);
					iChar = StrGetChar(sVal, 0);
					iCont = iCont + 1;
				END
				FileClose(hFile);
			END
			ErrSet(0);
			IF iCont < 330 THEN
				Message("LDWINAlarmList.csv incompatibile", "Manca la colonna degli allarmi Critici. Usare il burobot corretto", 48);
				bEnable = False;
			END
		END
		IF bEnable = True THEN
			DevModify("DevDummy", sFormat, "*", smPathCsv, ASCII_DEV);
			hDev = DevOpen("DevDummy", 0);
			IF hDev > -1 THEN
				DevFirst(hDev);
			END
		END
	ELSE
		Message("Import Allarmi [Errore]", smPathCsv + " non trovato!", 16);
	END
	RETURN hDev;
END

//#I
//
//#F
FUNCTION Set_AggiornaDataLDWIN(INT bVal)
	bmAggiornaDataLDWIN = bVal;
END

INT	 imNumCommAlms = -1;
INT	 hmAdvAlmRecCommAlms[lbNumAdvAlmRec]; !lista dei record degli allarmi di comunicazione

//#I
//Imposta la propietà di un determinato record di essere un allarme di comunicazione
//IN: iNumAlmRecord: # di record di advalm
//    iVal: valore da impostare
//#F
FUNCTION Set_bmCommAlm(INT iNumAlmRecord, INT iVal)
	!IF iNumAlmRecord = 0 THEN
	!Errlog("0");
	!END
	imNumCommAlms = imNumCommAlms + 1;
	IF imNumCommAlms > -1 AND imNumCommAlms < lbNumAlmTotPareto THEN
		bmCommAlm[iNumAlmRecord] = iVal;
		hmAdvAlmRecCommAlms[imNumCommAlms] = iNumAlmRecord;
	ELSE
		ErrLog("Set_bmCommAlm(" + IntToStr(iNumAlmRecord) + "...) Troppi allarmi definiti");
	END
END

//#I
//Determina a quale record corrisponde un'accoppiata codice di allarme, sottomessaggio
//IN: iBFGAlmCode: codice bonfi
//    iAlmCod: codice di sottomessaggio (-1 l'allarme non l'ha)
//OUT: # di record di AdvAlm.dbf o -1 se non trova nulla 
//#F
INT	 
FUNCTION GetAlmRecordRootVar(INT iBFGAlmCode, INT iAlmCod = -1)
	INT	 iDummy;
	INT	 iBank;
	INT	 iRec = -1;
	STRING sDummy;
	
	IF iAlmCod > -1 THEN
		iBank = imAdvAlmBFGCodeTagRootVar[iBFGAlmCode];
		IF iBank > -1 THEN
			!dal codice di sottomessaggio in lista allarmi, determina quale record
			!ErrLog("hmAdvAlmBFGCodeTagMsgQue[iBank] =" + IntToStr(hmAdvAlmBFGCodeTagMsgQue[iBank]) + " iBank=" + IntToStr(iBank));
			IF iAlmCod > -1 THEN
				iDummy = iAlmCod;
				QuePeek(hmAdvAlmBFGCodeTagMsgQue[iBank], iDummy, sDummy, 2);
				iRec = StrToInt(sDummy);
			END
		END
	ELSE
		iRec = hmAdvAlmBFGCodeTag[iBFGAlmCode];
	END
	RETURN iRec;
END

//#I
//Imposta il valore del flag di errore di comunicazione
///IN: iNumAlmRecord: # di record di advalm
//     iVal: valore da impostare
//#F
FUNCTION Set_bmCommAlmFail(INT iNumAlmRecord, INT iVal)
	IF iNumAlmRecord > -1 AND iNumAlmRecord < lbNumAlmTotPareto AND igValidazione = False THEN
		bmCommAlmFail[iNumAlmRecord] = iVal;
	END
END

//#I
//Funzione di reset degli allarmi di comunicazione gestiti da HMI: sulla lista non fa altro che forzare bmCommAlmFail[.] = False
//#F
FUNCTION LDWINCommAlmFailReset()
	INT	 iCont;
	INT	 iPriv;
	INT	 hAdvRec;
	
	FOR iCont = 0 TO imNumCommAlms DO
		hAdvRec = hmAdvAlmRecCommAlms[iCont];
		iPriv = imAdvAlmRecPriv[hAdvRec];
		IF bgPrivOn[iPriv] = True THEN
			bmCommAlmFail[hAdvRec] = False;
		END
	END
END

//#I
//Imposta il valore di un elto dell'array bmStsAlmFlagPrec[.]
//IN: iNum: # dell'elto
//    iVal: valore da impostare
//#F
FUNCTION Set_StsAlmFlagPrec(INT iNum, INT iVal)
	bmStsAlmFlagPrec[iNum] = iVal;
END

//#I
//Imposta il valore della variabile imDCUBatchTimePrec
//IN: iVal: valore da impostare
//#F
FUNCTION Set_DCUBatchTimePrec(INT iVal)
	imDCUBatchTimePrec = iVal;
END

//#I
//Imposta il valore della variabile imContTimeoutBlkBtn
//IN: iVal: valore da impostare
//#F
FUNCTION Set_imContTimeoutBlkBtn(INT iVal)
	imContTimeoutBlkBtn = iVal;
END

//#I
//Funzione task di copia dati e altro per personalizzazione Champions (id 29)
//Le specifiche sugli intervalli di variabilità sono desunte da ESRS 18247 ROF PV
//#F
FUNCTION ChampionsCustomerTask()
	INT	 bProdMarkOn;
	INT	 bProdMarkOnOld;
	INT	 iPLCDay = 1;
	INT	 iPLCYear = 20;
	INT	 iPLCId;
	INT	 iDCUDay = 1;
	INT	 iDCUYear = 20;
	INT	 iDCUId;
	INT	 iErr;
	INT	 bRefresh = False;
	INT	 bProdMark = INIParamOn(lbCfgMyProdMark);
	INT	 iAnnoDefault = DateYear(TimeCurrent(), 0);
	
	bgLDWINTaskOn[67] = True;
	WHILE bgLDWINTaskOn[67] = True DO
		ErrSet(1);
		iPLCDay = 1;
		IF QualityIsBad(itPLCDayOfYear.Q) = False THEN !se la qualità della tag è buona...
			iPLCDay = LDWINGetINTTagVal("itPLCDayOfYear", iPLCDay, True, 1, 365);
		END
		iPLCYear = iAnnoDefault;
		IF QualityIsBad(itPLCCurrentYear.Q) = False THEN !se la qualità della tag è buona...
			iPLCYear = LDWINGetINTTagVal("itPLCCurrentYear", iPLCYear, True, iPLCYear, 99);
		END
		iPLCId = 1;
		IF QualityIsBad(itPLCCurrentID.Q) = False THEN !se la qualità della tag è buona...
			iPLCId = LDWINGetINTTagVal("itPLCCurrentID", iPLCId, True);
		END
		iDCUDay = 1;
		IF QualityIsBad(itDCUDayOfYear.Q) = False THEN !se la qualità della tag è buona...
			iDCUDay = LDWINGetINTTagVal("itDCUDayOfYear", iDCUDay, True, -1, 365);
		END
		iDCUYear = iAnnoDefault;
		IF QualityIsBad(itDCUCurrentYear.Q) = False THEN !se la qualità della tag è buona...
			iDCUYear = LDWINGetINTTagVal("itDCUCurrentYear", iDCUYear, iDCUYear, 99);
		END
		iDCUId = 1;
		IF QualityIsBad(itDCUCurrentID.Q) = False THEN !se la qualità della tag è buona...
			iDCUId = LDWINGetINTTagVal("itDCUCurrentID", iDCUId, True);
		END
		
		IF iDCUDay = -1 THEN
			TagWrite("itDCUCurrentID", IntToStr(iPLCId), 0, True, "LDWIN");
			TagWrite("itDCUCurrentYear", IntToStr(iPLCYear), 0, True, "LDWIN");
			TagWrite("itDCUDayOfYear", IntToStr(iPLCDay), 0, True, "LDWIN");
			bRefresh = True;
		END
		IF bProdMark = True THEN
			bProdMarkOn = GetPLCHMICommandFeedBack(0);
			IF bProdMarkOn <> bProdMarkOnOld OR bRefresh = True THEN
				IF bProdMarkOn = 0 THEN !stampante disattivata
					iErr = DCUMailBoxCmd(200, 12, 0, True);
				ELSE !stampante attivata
					iErr = DCUMailBoxCmd(200, 11, 0, True);
				END
				IF iErr = 0 THEN
					bProdMarkOnOld = bProdMarkOn;
					bRefresh = False;
				END
			END
		END
		ErrSet(0);
		SleepMS(1000);
	END
END

//#I
//
//#F
INT	 
FUNCTION get_bmMacchinaInMoto()
	RETURN bmMacchinaInMoto;
END

//#I
//
//#F
FUNCTION set_bmMacchinaInMoto(INT bVal)
	bmMacchinaInMoto = bVal;
END

//#I
//
//#F
FUNCTION set_imScrTemplSt(INT iPos, INT iVal)
	imScrTemplSt[iPos] = iVal;
END

//#I
//Inizializza le lookup tables delle potenze di 2
//#F
FUNCTION LookupTableInit()
	INT	 iCont;
	INT	 iDummy;
	
	FOR iCont = 0 TO 31 DO
		iDummy = imExp2Bit[iCont]; !Compatibilità Con Citect 7.5: la potenza di 2 non può essere negativa per cui il valore a 31 bit non si riesce a calcolare con Pow(.)
		SetDiagno_imExp2Bit(iCont, iDummy);
		SetAbilRicTeste_imExp2Bit(iCont, iDummy);
		SetAlmRecovery_imExp2Bit(iCont, iDummy);
		SetSPCLib_imExp2Bit(iCont, iDummy);
		SetMailBoxDCU_imExp2Bit(iCont, iDummy);
		SetProc_imExp2Bit(iCont, iDummy);
		!SetConveyors_imExp2Bit(iCont, iDummy);
		SetSPCHist_imExp2Bit(iCont, iDummy);
		SetSocketTCP_imExp2Bit(iCont, iDummy);
		SetNelson_imExp2Bit(iCont, iDummy);
		SetSpr5_imExp2Bit(iCont, iDummy);
		SetBetaway_imExp2Bit(iCont, iDummy);
		SetHMI_imExp2Bit(iCont, iDummy);
	END
END

//#I
//Restituisce il valore per l'icona di modalità macchina
//#F
INT	 
FUNCTION GetExtModeIco()
	RETURN imExtModeIco;
END

//#I
//Imposta il valore per l'icona di modalità macchina
//#F
FUNCTION SetExtModeIco(INT iVal)
	imExtModeIco = iVal;
END

//#I
//Ritorna il valore della variabile di stato VI
//OUT: stato delle stazioni VI
//#F
INT	 
FUNCTION StVIIco()
	IF imContVIStScan >= 15 THEN
		imContVIStScan = 0;
		IF imNumVISt < Get_VINumDefStaz() - 1 THEN
			imNumVISt = imNumVISt + 1;
		ELSE
			imNumVISt = 0;
		END
	END
	imContVIStScan = imContVIStScan + 1;
	!Determinazione della condizione di allarme
	IF bmPLCVIAlm[imNumVISt] = True THEN
		RETURN 4;
	ELSE
		RETURN igStatoVIHMI[imNumVISt];
	END
END

//#I
//Informazioni sul VI coinvolto nella segnalazione Area Icone Superiore
//OUT: designazione dell'unità
//#F
STRING 
FUNCTION InfoVI()
	RETURN sgVIStatusTag[imNumVISt];
END

INT	 imAlmStrSep[500];
//#I
//
//AlmStrWithSeparator("[@(101PS)]")
//AlmStrWithSeparator("[@(Pressione Bassa): @(Collaudo)]")
//AlmStrWithSeparator("@(Pressione Bassa): @(Collaudo)")
//AlmStrWithSeparator("@(Scarti Consecutivi): @(Macchina)")
//#F
STRING 
FUNCTION AlmStrWithSeparator(STRING sArg = "@(Stringa1): @(Stringa2)")
	INT	 iLen = 0;
	INT	 iCont;
	STRING sOut = "";
	INT	 iChar;
	INT	 iCharSt = -10;
	INT	 iNumChiocc = 0;
	INT	 iNumCAtt;
	
	sArg = StrTrim(sArg);
	IF sArg <> "" THEN
		iLen = StrLength(sArg) - 1;
		IF iLen > -1 AND iLen < 499 THEN
			!Cerca il # di "@"
			FOR iCont = 0 TO iLen DO
				iChar = StrGetChar(sArg, iCont);
				IF iChar = 64 THEN
					iNumChiocc = iNumChiocc + 1;
				END
				imAlmStrSep[iCont] = iChar;
			END
			IF iNumChiocc =  1 AND imAlmStrSep[0] = 64 AND imAlmStrSep[iLen] = 41 THEN
				sOut = sArg; !se la stringa è del tipo "@(...)" no toques
			ELSE
				IF imAlmStrSep[0] <> 123 THEN !<> "{"
					IF imAlmStrSep[0] <> 64 THEN
						!in ogni caso deve cominciare con "@"
						StrSetChar(sOut, 0, 64); !"@"
						StrSetChar(sOut, 1, 40); !"("
						StrSetChar(sOut, 2, 0); !terminatore
					END
					FOR iCont = 0 TO iLen DO
						iChar = imAlmStrSep[iCont];
						!ErrLog("St: " + IntToStr(iCharSt) + " sOut:" + sOut + " sArg:" + sArg);
						SELECT CASE iCharSt
						CASE -10 !ricerca il primo "@"
							IF iChar = 64 THEN
								iCharSt = 0;
								iNumCAtt = 1;
								IF iCont > 0 AND imAlmStrSep[0] <> 64 THEN
									sOut = sOut + lbAlmTradSeparator;
									iCont = iCont + 1;
								ELSE
									sOut = sOut + CharToStr(iChar);
								END
							ELSE
								sOut = sOut + CharToStr(iChar);
							END
						CASE 0 !Ricerca il carattere ")"
							IF iChar = 41 AND iCont < iLen THEN
								IF iNumCAtt < iNumChiocc THEN
									sOut = sOut + lbAlmTradSeparator;
								ELSE
									IF imAlmStrSep[0] <> 64 THEN !primo caratt NON è "@"
										sOut = sOut + lbAlmTradSeparator;
									ELSE
										IF iNumCAtt = iNumChiocc AND imAlmStrSep[iLen] <> 41 THEN
											sOut = sOut + lbAlmTradSeparator;
										ELSE
											sOut = sOut + CharToStr(iChar);
										END
									END
								END
								iCharSt = 10;
							ELSE
								sOut = sOut + CharToStr(iChar);
							END
						CASE 10 !ricerca "@"
							IF iChar = 64 THEN
								iCont = iCont + 1;
								iNumCAtt = iNumCAtt + 1;
								sOut = sOut + lbAlmTradSeparator;
								iCharSt = 0;
							ELSE
								sOut = sOut + CharToStr(iChar);
							END
						END SELECT
					END
					IF imAlmStrSep[iLen] <> 41 THEN
						sOut = sOut + ")"; !deve sempre finire con ")"
					END
				ELSE
					sOut = sArg;
				END !<> "{"
			END
		END
	END !IF sArg <> ""
	RETURN sOut;
END

GLOBAL
INT	 igAlmDspPagePrec; !Id di pagina allarmi precedente
   
//#I
//Imposta il valore di imAlmDspPage
//#F
FUNCTION Set_AlmDspPage(INT iVal)
	STRING sDummy;
	
	igAlmDspPagePrec = imAlmDspPage; !memorizza il valore precedente
	IF iVal = 0 THEN !AlmAct
		LDWINSetShowBtn(100, bgBtnShow_100Init);
		LDWINSetShowBtn(152, True);
	ELSE
		LDWINSetShowBtn(100, False);
		LDWINSetShowBtn(152, False);
	END
	bgLDWINPageInfoReset = True;
	imAlmDspPage = iVal;
	sDummy = smAlmDspPageManName[iVal];
	Set_LDWINPaginaManuale(sDummy);
END

//#I
//Wrapper di visualizzazione degli allarmi Attivi ed Hw
//IN: iNumAN: # dell'AN
//#F
FUNCTION LDWINAlmDspLast(INT iNumAN = 27, INT iCount = 22, INT iType = 0, INT iDspPage = 0)
	INT	 bEnable = True;
	
	IF iDspPage = imAlmDspPage THEN
		IF iDspPage = 0 THEN
			!bEnable = NOT bgAlmDspGenie;
			bEnable = False;
		END
		IF bEnable = True THEN
			AlarmDspLast(iNumAN, iCount, iType);
		END
	END
END

//#I
//Wrapper di visualizzazione del sommario allarmi: la convivenza con le robe che funzionano con la fn AlarmDspLast(.), non la gradisce
//per cui sono stati piazzati una serie di fx riservate
//IN: iNumAN: # dell'AN
//#F
FUNCTION LDWINAlmDspSumm(INT iNumAN = 259)
	IF imAlmDspPage = 1 THEN
		AlarmDsp(iNumAN, 22, 10);
	END
END

//#I
//Determina il valore di imAlmDspPage
//OUT: valore della variabile
//#F
INT	 
FUNCTION Get_AlmDspPage()
	RETURN imAlmDspPage;
END

STRING smAckType[8] = "", "", "", "", "", "", "[1Ack]", "[Ack]";

//#I
//IN: iNumGenie: # di genie su cui effettuare l'operazione
//    iNumCol: # di colonna su cui eventualmente effettuare l'operazione
//#F
FUNCTION AlmDsp_LBUTTN_DN(INT iNumAN, INT iNumGenie = -1, INT iNumCol = 1)
	!la tag ricavata dall'almserver è del tipo ALxxx_AdvAlmRecNo->splitto la stringa su "_" e ottengo le due informazioni che mi servono
	STRING sTag;
	STRING sDummy;
	INT	 iAdvAlmRecNo = -1;
	INT	 hQue = -1;
	INT	 iValQue;
	INT	 bEnable = False;
	INT	 bError = False;
	STRING sMotivo = "";
	
	IF iNumGenie <= 0 THEN
		SELECT CASE imAlmDspPage!l'ack si può fare solamente nelle pagine di allarmi attivi o HW, ma hanno un comportamento diverso
		CASE 0 !allarmi attivi -> gestione Ack da LDWIN accedendo al almServer per poter intercettare gli eventi
			sDummy = AlarmGetDsp(iNumAN, "Tag");
			bEnable = True;
		CASE 2 !allarmi ack -> gestione ack di citect
			AlarmAck(0, 0);
		END SELECT
	ELSE
		IF iNumCol = 6 OR iNumCol = 7 THEN !FACK (6) e ACK (7)
			IF iNumGenie > 0 THEN
				iNumGenie = iNumGenie + Get_igOffsetTesta(16);
				sDummy = sltAlmActDsp[iNumGenie][0];
				bEnable = True;
			END
		END
	END
	IF bEnable = True THEN
		!Ricava il # di record in advalm.DBF e il nome BFG
		hQue = StrSplitInQue(sDummy, "_", False);
		bEnable = False;
		IF hQue <> -1 THEN
			sDummy = "";
			QueRead(hQue, iValQue, sDummy, 0);
			sTag = sDummy;
			QueRead(hQue, iValQue, sDummy, 0);
			iAdvAlmRecNo = StrToInt(sDummy);
			QueClose(hQue);
			!Ricava la successiva elaborazione impedendendola o per problemi di indice o per problemi di privilegio di ACK
			IF iAdvAlmRecNo > -1 THEN
				iValQue = imAdvAlmRecPriv[iAdvAlmRecNo];
				bEnable = bgPrivOn[iValQue];
			END
		END
		IF bEnable = True THEN !Se c'è il privilegio corretto
			smAlmAckComment = "NA"; !21206_41
			SELECT CASE iNumCol
			CASE 6 !FAck
				IF bmAlmServerAlmIsFAck[iAdvAlmRecNo] = False THEN
					IF INIParamOn(lbCfgMyGiustAckAlm) = True THEN !Giustificativo solo se alm non FACK della pagina allarmi attivi
						sMotivo = AckGetCommento(smAckType[iNumCol] + " " + sTag); !21206_1
					END
					SetCitectAlmFAckState(iAdvAlmRecNo);
					WrRptAT(sTag, StrTrim("@(Riconoscimento) " + smAckType[iNumCol] + " " + sMotivo));
				ELSE
					sDummy = "@(Già Riconosciuto da): " + sltAlmActUserIdFACK[iAdvAlmRecNo];
					bError = True;
				END
			CASE 7 !Ack
				!Con il doppio ACK, non si può ACKare con lo stesso utente
				IF INIParamOn(lbCfgMyCriticalAlmDoubleAck) = True THEN
					bEnable = ACKChkIfFACK(LDWINUserInfo(1), iAdvAlmRecNo);
				END
				IF bEnable = True THEN
					bEnable = False;
					IF INIParamOn(lbCfgMyGiustAckAlm) = True THEN
						IF INIParamOn(lbCfgMyCriticalAlmDoubleAck) = True THEN !Se sono attivi gli allarmi critici, il commento fallo solo su quelli
							IF GetCitectAlmAckState(iAdvAlmRecNo) = False AND bmFAckAdvAlm[iAdvAlmRecNo] = True THEN !Giustificativo solo se alm CRITICO non ACK della pagina allarmi attivi
								bEnable = True;
							END
						ELSE
							bEnable = True; !fallo sempre
						END
					END
					IF bEnable = True THEN
						sMotivo = AckGetCommento(smAckType[iNumCol] + " " + sTag); !21206_1
					END
					SetCitectAlmAckState(iAdvAlmRecNo);
					WrRptAT(sTag, StrTrim("@(Riconoscimento) " + smAckType[iNumCol] + " " + sMotivo));
				ELSE
					sDummy = "@(Riconoscimento) " + smAckType[iNumCol] + ": @(Non Consentito) @(Stesso UserID)";
					bError = True;
				END
			END SELECT
		ELSE
			sDummy = "@(Riconoscimento) " + smAckType[iNumCol] + ": @(Non Consentito)";
			bError = True;
		END
		IF bError = True THEN
			WrRptAT(sTag, sDummy);
			ShowMessageTask(sTag, StrToLocalText(sDummy), 16);
		END
	END
END

//#I
//IN: iNumGenie: # di genie su cui effettuare l'operazione
//    iNumCol: # di colonna su cui eventualmente effettuare l'operazione
//#F
FUNCTION AlmDsp_DOUBLE_SX(INT iNumAN, INT iNumGenie = -1, INT iNumCol = 0) 
	IF imAlmDspPage = 0 THEN
		IF iNumGenie = -1 THEN
			ManualeAlm(AlarmGetDsp(iNumAN, "Tag"));
		ELSE
			iNumGenie = iNumGenie + Get_igOffsetTesta(16);
			ManualeAlm(sltAlmActDsp[iNumGenie][0]);
		END
	END
END

//#I
//
//#F
FUNCTION AlmDspOnPageExit()
	IF imAlmDspPage = 0 THEN
		bgLDWINTaskOn[96] = False;
		LDWINTaskResume(96);
	END
END

INT	 hmAlmDsp_ExitBtn[3] = 258, 263, 267;
INT	 hmAlmDsp_ExitBtnArg[3] = 0, 1, 0;

//#I
//
//#F
FUNCTION AlmDsp_Exit()
	LDWINBtnInput(hmAlmDsp_ExitBtn[imAlmDspPage], 0, hmAlmDsp_ExitBtnArg[imAlmDspPage]);
END

//FUNCTION AlmDsp_Exit_old()
//	INT	 iDummy;
//	INT	 iArg;
//	
//	iDummy = hmAlmDsp_ExitBtn[imAlmDspPage];
//	iArg = hmAlmDsp_ExitBtnArg[imAlmDspPage];
//	LDWINBtnInput(iDummy, 0, iArg);
//END

//#I
//
//#F
INT	 
FUNCTION AlmDsp_ExitShow()
	RETURN LDWINShowBtn(hmAlmDsp_ExitBtn[imAlmDspPage]);
END


//#I
//
//#F
FUNCTION AlmDsp_Next()
	LDWINBtnInput(hmAlmDsp_NextBtn[imAlmDspPage], 0, hmAlmDsp_NextBtnArg[imAlmDspPage]);
END

//FUNCTION AlmDsp_Next_old()
//	INT	 iDummy;
//	INT	 iArg;
//	
//	iDummy = hmAlmDsp_NextBtn[imAlmDspPage];
//	iArg = hmAlmDsp_NextBtnArg[imAlmDspPage];
//	LDWINBtnInput(iDummy, 0, iArg);
//END

//#I
//Visualizzazione dei bottoni "succ" e "prec"
//#F
INT	 
FUNCTION AlmDsp_NextShow()
	RETURN LDWINShowBtn(hmAlmDsp_NextBtn[imAlmDspPage]);
END

//INT	 
//FUNCTION AlmDsp_NextShow_old()
//	INT	 iDummy;
//	
//	iDummy = hmAlmDsp_NextBtn[imAlmDspPage];
//	RETURN LDWINShowBtn(iDummy);
//END


//#I
//
//#F
FUNCTION AlmDsp_Prev()
	LDWINBtnInput(hmAlmDsp_PrevBtn[imAlmDspPage], 0, hmAlmDsp_PrevBtnArg[imAlmDspPage]);
END

//FUNCTION AlmDsp_Prev_old()
//	INT	 iDummy;
//	INT	 iArg;
//	
//	iDummy = hmAlmDsp_PrevBtn[imAlmDspPage];
//	iArg = hmAlmDsp_PrevBtnArg[imAlmDspPage];
//	LDWINBtnInput(iDummy, 0, iArg);
//END

//#I
//
//#F
INT	 
FUNCTION AlmDsp_PrevShow()
	RETURN LDWINShowBtn(hmAlmDsp_PrevBtn[imAlmDspPage]);
END

//INT	 
//FUNCTION AlmDsp_PrevShow_old()
//	INT	 iDummy;
//	
//	iDummy = hmAlmDsp_PrevBtn[imAlmDspPage];
//	RETURN LDWINShowBtn(iDummy);
//END

INT	 hmAlmDsp_ManualBtn[3] = 255, 260, 264;

//#I
//
//#F
FUNCTION AlmDsp_Manual()
	LDWINBtnInput(hmAlmDsp_ManualBtn[imAlmDspPage]);
END

//FUNCTION AlmDsp_Manual_old()
//	INT	 iDummy;
//	
//	iDummy = hmAlmDsp_ManualBtn[imAlmDspPage];
//	LDWINBtnInput(iDummy);
//END

//#I
//
//#F
INT	 
FUNCTION AlmDsp_ManualShow()
	RETURN LDWINShowBtn(hmAlmDsp_ManualBtn[imAlmDspPage]);
END

//INT	 
//FUNCTION AlmDsp_ManualShow_old()
//	INT	 iDummy;
//	
//	iDummy = hmAlmDsp_ManualBtn[imAlmDspPage];
//	RETURN LDWINShowBtn(iDummy);
//END

//#I
//
//#F
INT	 
FUNCTION Get_AlmSourceNumBank(INT hID)
	RETURN imAlmSourceNumBank[hID];
END

//#I
//Crea e restituisce la coda per la gestione degli allarmi HMIxMES shrinkati
//que: int=bitWordAlmMes - str=RecNoAlm
//#F
INT	 
FUNCTION CreateHMIAlmxMesQue()
	INT	 hQue = -1;
	INT	 iCont;
	INT	 iAlmNum;
	INT	 iBitAlmMES = 0;
	INT	 bWrite = False;
	
	hQue = QueOpen("HMIAlmxMES", 1);
	IF hQue <> -1 THEN
		FOR iCont = 0 TO imNumAdvAlm - 1 DO
			IF imAdvAlmSource[iCont] = 7 THEN !sorgente HMI
				iAlmNum = hmAdvAlmNumRecTag[iCont];
				!lo so che gli if non sono ottimizzati e si potrebbe fare con un unico if gestendo con le parentesi le condizioni ma nel modo successivo è più comodo fare debug
				IF iAlmNum >= 788 AND iAlmNum <= 791 THEN !ALM spc
					IF INIParamOn(lbCfgMySPCOn) = True THEN
						bWrite = True;
					END
				END
				IF iAlmNum >= 792 AND iAlmNum <= 795 THEN !ALM Runchart
					IF INIParamOn(lbCfgMyRunChart) = True AND INIParamOn(lbCfgLDEnable) = True THEN
						bWrite = True;
					END
				END
				IF iAlmNum >= 800 AND iAlmNum <= 802 THEN !ALM RemoteBck
					IF INIParamOn(lbCfgMyRemoteBck) = True THEN
						bWrite = True;
					END
				END
				IF bWrite = True THEN
					QueWrite(hQue, iBitAlmMES, IntToStr(iCont));
					iBitAlmMES = iBitAlmMES + 1;
					bWrite = False;
				END
			END
		END
		IF QueLength(hQue) = 0 THEN !in modo che non sia considerata valida se vuota
			QueClose(hQue)
			hQue = -1;
		END
	END
	RETURN hQue;
END

//#I
//Chiude il file dei lemmi nativi del sistema allarmi
//#F
FUNCTION Close_AlmNativeFile()
	IF hmAlmNative > -1 THEN
		FileClose(hmAlmNative);
		hmAlmNative = -1;
	END
END

//#I
//Cancella i file delle traduzioni allarmi native in modo da poter resettare la situaizone in caso di import errati
//#F
FUNCTION ResetAlmTrad()
	
	IF HMIConsensoOper("@(Reset Traduzioni Allarmi):",
		"@(ATTENZIONE!) Il consenso produrrà modifiche PERMANENTI",
		"Procedere con aggiornamento ?") = True THEN
		CancFileDir(StrToXPCmdPath(sgLDWINPercProgetto[1] + "\" + "Gest_AlmDefNative*.ci"));
		SleepMS(500);
		IF HMIConsensoOper("@(Reset Traduzioni Allarmi):",
			"@(Dopo la cancellazione è consigliabile eseguire un caricamento della lista allarmi)",
			"Procedere con aggiornamento ?") = True THEN
			ImportAdvAlm();
		ELSE
			HMICompileLDWINMsg();
		END
	END
END

//#I
//Aggiunge un record alla coda degli allarmi da scrivere su sql
//Gli argomenti passati sono quelli che non si riescono a ricavare con almRecNo o con le info di Citect
//IN: iAdvAlmRecNo: RecNo dell'AdvAlm
//    sUserID: user ID associato all'allarme
//    sCategory: categoria dell'allarme
//    bCitect72: True: retrocompatibilità per Citect7.2
//    bFACKOn: attivato il doppio ACK
//    sFACkDate, sFAckTime: data e ora di FACK
//    sAckComment: commento utente su Ack
//#F
!FUNCTION LDWINAddAlmToBuf(INT iAdvAlmRecNo, STRING sOnDate, STRING sOnTime, STRING sOffDate, STRING sOffTime, STRING sDeltaTime, STRING sAckDate, STRING sAckTime, 
!	STRING sUserId, STRING sCategory, INT bCitect72, INT bFACK, INT bSetFAck)
FUNCTION LDWINAddAlmToBuf(INT iAdvAlmRecNo, STRING sOnDate, STRING sOnTime, STRING sOffDate, STRING sOffTime, STRING sDeltaTime, STRING sAckDate, STRING sAckTime, 
	STRING sUserId, STRING sCategory, INT bCitect72, INT bFACK, INT bSetFAck, STRING sAckComment) !21206_41
	STRING sControlDateVal = "";
	STRING sDefaultDate = "0000-00-00";
	STRING sLDWINData = sgLDWINData;
	STRING sDateNow = LDWIN2SQLSetData(sLDWINData);
	STRING sTimeNow = smLDWINOraMinSec;
	STRING sUserName = sUserId;
	STRING sDummy;
	STRING sDesc;
	STRING sFAck = "--";
	STRING sAlmTag;
	STRING sAlmNameTrad;
	STRING sDescTrad;
	STRING sFAckDate = "0000-00-00";
	STRING sFAckTime = "";
	INT	 hQue;
	INT	 iCharLim = 255;
	INT	 bWrite = True;
	INT	 iCont;
	INT	 iPos;
	INT	 iColColor;
	INT	 iAckColor;
	INT	 iFAckColor;
	INT	 bDisAck = False;
	
	//`TAG`	strleft(sltAlmTagDev[iAdvAlmRecNo,5)
	//`Name`	stringtolocal(stAlmName[iAdvAlmRecNo])
	//`Native_NAME`	stAlmName[iAdvAlmRecNo]
	//`DESC_`	stringtolocal(stAlmDesc[iAdvAlmRecNo])
	//`Native_DESC`	stAlmDesc[iAdvAlmRecNo]
	//`ONDATE`	OnDate
	//`ONTIME`	OnTime
	//`ONTIMEStr`	OnTime in formato stringa
	//`OFFDATE`	OffDate
	//`OFFTIME`	OffTime
	//`DELTATIME`	DeltaTime
	//`ACKDATE`	AckDate
	//`ACKTIME`	AckTime
	//`UserId`	LDWINUserInfo(1)
	//`Time_`	now
	//`Date_`	now
	//`BATCH`	sgLottoRawData
	//`USERNAME` LDWINUserInfo(2)
	//`TimeStr_` in formato stringa
	
	IF bCitect72 = True THEN
		sControlDateVal = "0";
	END
	IF hmQueTaskAlmWrite <> -1 THEN
		hQue = QueOpen("SubQueAlmToSQL", 1);
		IF hQue <> -1 THEN
			sAlmTag = StrLeft(sltAlmTagDev[iAdvAlmRecNo], 5);
			!Controllo sulle date, se sono 0 allora le imposta a "0000-00-00"
			IF sOnDate = sControlDateVal THEN !se la onDate è 0 vuol dire che ci sono stati dei problemi nell'AlmServer[es cancellazione dei .dat]->non è da registrare il record
				bWrite = False;
				!ErrLog(StrLeft(sltAlmTagDev[iAdvAlmRecNo], 5) + ": OnDate non Valida, transizione annullata");
				ErrLog(sAlmTag + ": OnDate non Valida, transizione annullata");
			END
			IF bWrite = True THEN
				!Controllo sulle date, se sono 0 allora le imposta a "0000-00-00"
				IF sOffDate = sControlDateVal THEN
					sOffDate = sDefaultDate;
				END
				IF sAckDate = sControlDateVal THEN
					sAckDate = sDefaultDate;
				END
				IF bFACK = True THEN
					IF sFAckDate = sControlDateVal THEN
						sFAckDate = sDefaultDate;
					END
					IF bSetFAck = True THEN
						sFAckDate = sDateNow;
						sFAckTime = sTimeNow;
						sUserID = ""; !Forza la scrittura dello User id che ha FAckato l'allarme
					END
				END
				sAlmNameTrad = StrToLocalText(stAlmName[iAdvAlmRecNo]);
				LDWINAddStrToQueWithControl(hQue, "('", iCharLim);
				LDWINAddStrToQueWithControl(hQue, sAlmTag, iCharLim); !TAG
				LDWINAddStrToQueWithControl(hQue, "','", iCharLim);
				LDWINAddStrToQueWithControl(hQue, sAlmNameTrad, iCharLim); !Name
				LDWINAddStrToQueWithControl(hQue, "','", iCharLim);
				LDWINAddStrToQueWithControl(hQue, stAlmName[iAdvAlmRecNo], iCharLim); !Native_Name
				LDWINAddStrToQueWithControl(hQue, "','", iCharLim);
				sDesc = stAlmDesc[iAdvAlmRecNo];
				IF StrLeft(sDesc, 1) = "{" THEN !è un multitesta che ha il comando GetAdvAlmMsg(RecNo) ma essendo stringa non possiamo eseguirlo dato che non abbiamo l'eval
					SELECT CASE hmAdvAlmNumRecTag[iAdvAlmRecNo] !RB75
					CASE 800
						sDesc = RemoteBckGetAlmMsg();
					//CASE ELSE
					//	sDesc = GetAdvAlmMsg(iAdvAlmRecNo);
					END SELECT
				END
				sDescTrad = StrToLocalText(sDesc);
				LDWINAddStrToQueWithControl(hQue, sDescTrad, iCharLim); !Desc
				LDWINAddStrToQueWithControl(hQue, "','", iCharLim);
				LDWINAddStrToQueWithControl(hQue, sDesc, iCharLim); !Native_Desc
				LDWINAddStrToQueWithControl(hQue, "','", iCharLim);
				LDWINAddStrToQueWithControl(hQue, LDWIN2SQLSetData(sOnDate), iCharLim); !OnDate
				LDWINAddStrToQueWithControl(hQue, "','", iCharLim);
//				IF bgNewSQLRpt = False THEN
//					LDWINAddStrToQueWithControl(hQue, sOnTime, iCharLim); !OnTime
//					LDWINAddStrToQueWithControl(hQue, "','", iCharLim);
//				ELSE
					LDWINAddStrToQueWithControl(hQue, sOnTime + "','" + sOnTime + "','", iCharLim); !OnTime, ONTIMEStr (Grazie Citect 7.5, duplicazione in str per poter leggere poi)
//				END
				LDWINAddStrToQueWithControl(hQue, LDWIN2SQLSetData(sOffDate), iCharLim); !OffDate
				LDWINAddStrToQueWithControl(hQue, "','", iCharLim);
				LDWINAddStrToQueWithControl(hQue, sOffTime, iCharLim); !OffTime
				LDWINAddStrToQueWithControl(hQue, "','", iCharLim);
				LDWINAddStrToQueWithControl(hQue, sDeltaTime, iCharLim); !DeltaTime
				LDWINAddStrToQueWithControl(hQue, "','", iCharLim);
				!FACK Date&Time
				LDWINAddStrToQueWithControl(hQue, LDWIN2SQLSetData(sFAckDate) + "','" + sFAckTime + "','", iCharLim); !FAckDate, !FAckTime
				!ACK Date&Time
				LDWINAddStrToQueWithControl(hQue, LDWIN2SQLSetData(sAckDate) + "','" + sAckTime + "','", iCharLim); !AckDate, AckTime
				IF sUserId <> "system" THEN
					sUserId = LDWINUserInfo(1);
					sUserName = LDWINUserInfo(2);
				END
				LDWINAddStrToQueWithControl(hQue, sUserId, iCharLim); !UserId
				LDWINAddStrToQueWithControl(hQue, "','" + sTimeNow + "','" + sDateNow + "','", iCharLim); !TIME, DATE
				LDWINAddStrToQueWithControl(hQue, sgLottoRawData, iCharLim); !BATCH
				LDWINAddStrToQueWithControl(hQue, "','", iCharLim);
				LDWINAddStrToQueWithControl(hQue, sUserName, iCharLim); !USERNAME
				!Critico 21206_41
				LDWINAddStrToQueWithControl(hQue, "','" + IntToStr(bmFAckAdvAlm[iAdvAlmRecNo]), iCharLim); !allarme critico
				!Commento 21206_41
				LDWINAddStrToQueWithControl(hQue, "','" + sAckComment, iCharLim); !commento
				!IF bgNewSQLRpt = False THEN
				!	LDWINAddStrToQueWithControl(hQue, "')", iCharLim);
				!ELSE
					LDWINAddStrToQueWithControl(hQue, "','" + sTimeNow + "')", iCharLim);
				!END
				
				!debug
				!PrintQueOnErrLog(hQue, 1);
				!----------------------
				!Scrivi il puntatore alla coda del singolo record nella coda globale
				QueWrite(hmQueTaskAlmWrite, QueLength(hmQueTaskAlmWrite), IntToStr(hQue));
				!aggiornare variabili per nuova pagina alarmi attivi
				iPos = -1; !posizione del record da modificare
				iCont = 1;
				WHILE iPos = -1 DO
					IF sltAlmActDsp[iCont][0] <> "" THEN !se la tag è definita
						IF sltAlmActDsp[iCont][0] = sltAlmTagDev[iAdvAlmRecNo] THEN !analizzo la tag contenuta, se è uguale è la pos che mi serve
							iPos = iCont; !ho trovato la posizione da modificare
						END
					ELSE !se non ho ancora trovato la pos [ci pensa il ciclo ad uscire quando la trova] la pos è quella analizzata perchè vuol dire che il record non è presente e la pos attuale è la prima libera
						iPos = iCont; !scrivere dati nella posizione attuale[che è la prima libera
					END
					iCont = iCont + 1;
				END
				!iPos contiene la posizione da modificare
				!se l'allarme risulta ACK[ACKDate <> sDefaultDate] ed OFF[OFFDATE<>sDefaultDate] allora è da rimuovere e shiftare tutti i record successivi [con qualcosa] verso l'alto
				IF sAckDate <> sDefaultDate AND sOffDate <> sDefaultDate THEN !rimuovere
					!shifto verso "alto" tutti irecord succesivi ad iPos, compresi i colori
					WHILE iPos <> -1 DO
						IF iPos = 1001 THEN !ultima riga, non c'è nulla da shiftare, basta azzerare il contenuto
							sltAlmActDsp[iPos][0] = "";
							sltAlmActDsp[iPos][1] = "";
							sltAlmActDsp[iPos][2] = "";
							sltAlmActDsp[iPos][3] = "";
							sltAlmActDsp[iPos][4] = "";
							sltAlmActDsp[iPos][5] = "";
							sltAlmActDsp[iPos][6] = "";
							sltAlmActDsp[iPos][7] = "";
							iPos = -1; !fine ciclo
						ELSE
							FOR iCont = 0 TO 14 DO !copio il valore dell'intera riga successiva[anche i campi non usati nella attuale [iPos]
								GnAlmActDspSet(iPos, iCont, sltAlmActDsp[iPos + 1][iCont], imDspAlmGenieColor[iPos + 1][iCont],
								bmDspAlmGenieShow[iPos + 1][iCont], bmDspAlmGenieDis[iPos + 1][iCont]);
							END
							hmDspAlmGenie2AdvAlmNumRec[iPos] = hmDspAlmGenie2AdvAlmNumRec[iPos + 1];
							IF sltAlmActDsp[iPos][0] = "" THEN !se l'elemento shiftato è vuoto allora fine [lo si shifta comunque in modo da cancellare l'elemento attuale]
								iPos = -1;
							ELSE !prossimo elemento
								iPos = iPos + 1;
							END
						END
					END
					!imNumAlmGenie = imNumAlmGenie - 1;
				ELSE !modificare/aggiungere
					sltAlmActDsp[iPos][0] = sltAlmTagDev[iAdvAlmRecNo]; !TAG AdvAlm.DBF
					sltAlmActDsp[iPos][6] = sFAck; !FAck -> si,no oppure "--"
					!Gestione colori colonne [la colonna 0 non viene visualizzata]
					SELECT CASE sCategory
					CASE "1"!primari
						IF sOffDate = sDefaultDate THEN !allarme acceso
							iColColor = 1; !rosso acceso
						ELSE !allarme spento
							iColColor = 2!rosso spento
						END
						iAckColor = 3; !colore no Ack
						iFAckColor = 3; !colore no FAck
					CASE "2"!secondari
						IF sOffDate = sDefaultDate THEN !allarme acceso
							iColColor = 4; !giallo acceso
						ELSE !allarme spento
							iColColor = 5!giallo spento
						END
						iAckColor = 6; !colore no Ack
						iFAckColor = 6; !colore no FAck
					CASE "3"!warning
						IF sOffDate = sDefaultDate THEN !allarme acceso
							iColColor = 7; !Blu acceso
						ELSE !allarme spento
							iColColor = 8!Blu spento
						END
						iAckColor = 9; !colore no Ack
						iFAckColor = 9; !colore no FAck
					END SELECT
					IF bFACK = True THEN
						IF bmFAckAdvAlm[iAdvAlmRecNo] = True THEN
							IF sFAckDate = sDefaultDate AND bmAlmServerAlmIsFAck[iAdvAlmRecNo] = False THEN
								sFAck = sgSiNoTrad[0]; !NO
								bDisAck = True; !non è possibile fare ACK vero se prima non si esegue FACK
							ELSE
								sFAck = sgSiNoTrad[1]; !SI
								iFAckColor = 10; !Verde Acceso
							END
						END
						sltAlmActDsp[iPos][6] = sFAck; !FAck -> si,no oppure "--"
					END
					!modifica il valore del colore ack se l'allarme è ack -> fatto qui riduco la presenza di if nel case
					IF sAckDate = sDefaultDate THEN
						sDummy = sgSiNoTrad[0]; !NO
					ELSE
						sDummy = sgSiNoTrad[1]; !SI
						iAckColor = 10; !Verde Acceso
						IF bFACK = True THEN !21206_41 [BUG]
							IF bmFAckAdvAlm[iAdvAlmRecNo] = False THEN
								iFAckColor = 10; !colore no FAck (dello stesso tipo se alm NON è critico)
							END
						END
					END
					sltAlmActDsp[iPos][7] = sDummy; !Ack -> si,no
					GnAlmActDspSet(iPos, 1, sAlmTag, iColColor); !TAG AdvAlm.DBF
					GnAlmActDspSet(iPos, 2, sLDWINData, iColColor); !Data ultima transizione
					GnAlmActDspSet(iPos, 3, sTimeNow, iColColor); !Ora ultima transizione
					GnAlmActDspSet(iPos, 4, sAlmNameTrad, iColColor); !Nome
					GnAlmActDspSet(iPos, 5, sDescTrad, iColColor); !Descrizione
					GnAlmActDspSet(iPos, 6, sFAck, iFAckColor, bFACK); !Fack-> non implementato -> impostato al momento allo stesso colore dell'ack
					GnAlmActDspSet(iPos, 7, sDummy, iAckColor, True, bDisAck); !Ack
					GnAlmActDspSet(iPos, 8, sUserId, iColColor); !Utente
					hmDspAlmGenie2AdvAlmNumRec[iPos] = iAdvAlmRecNo;
				END
				!debug
				!TestShowActAlmMarix();
				!-----
				!---------------------------------------------------
			END !IF bWrite
		ELSE
			Message("LDWINAddAlmToBuf", "SubQue not open", 16);
		END
	ELSE
		Message("LDWINAddAlmToBuf", "MainQue not open", 16);
	END
END

//#I
//Task di scrittura dei record allarmi su SQL
//#F
FUNCTION TaskWriteAlarmToSQL()
	INT	 iQueLen;
	INT	 iMaxRecordToWrite = 10;
	INT	 iRecordWritten = 0;
	INT	 hQue;
	INT	 iValQue;
	INT	 hDb;
	INT	 iDb = 11;
	INT	 iErr;
	INT	 iWaitMs = 500;
	INT	 bWriteToSQL = False;
	INT	 hQueWrite = -1; !coda in cui bufferizzare le stringhe di scrittura su sql che verrano inserite nei sQLSet/SQLAppend
	INT	 iCharLim = 255;
	STRING sValQue;
	
	!ErrLog("AVVIO TaskWriteAlarmToSQL");
	LDWINDefTask(95, "TaskWriteAlarmToSQL", True);
	IF hmQueTaskAlmWrite = -1 THEN
		hmQueTaskAlmWrite = QueOpen("QueAlmToSQL", 1);
	END
	IF hQueWrite = -1 THEN
		hQueWrite = QueOpen("QueWriteAlmToSQL", 1);
	END
	WHILE bgLDWINTaskOn[95] = True DO
		IF hmQueTaskAlmWrite <> -1 AND hQueWrite <> -1 THEN
			iQueLen = QueLength(hmQueTaskAlmWrite);
			IF iQueLen > 0 THEN
				hDb = SQLServerOpenConnection(iDb); !se è già aperto non succede nulla
				IF iRecordWritten = 0 THEN
//					IF bgNewSQLRpt = False THEN
//						LDWINAddStrToQueWithControl(hQueWrite, "INSERT INTO alarms (`TAG`,`NAME`,`Native_NAME`,`DESC_`,`Native_DESC`,`ONDATE`,`ONTIME`,`OFFDATE`,`OFFTIME`,`DELTATIME`,", iCharLim);
//						LDWINAddStrToQueWithControl(hQueWrite, "`FACKDATE`,`FACKTIME`,`ACKDATE`,`ACKTIME`,`UserId`,`Time_`,`Date_`,`BATCH`,`USERNAME`,`Critical`,`AckComment`) VALUES ", iCharLim); !21206_41
//					ELSE
						LDWINAddStrToQueWithControl(hQueWrite, "INSERT INTO alarms (`TAG`,`NAME`,`Native_NAME`,`DESC_`,`Native_DESC`,`ONDATE`,`ONTIME`,`ONTIMEStr`,`OFFDATE`,`OFFTIME`,`DELTATIME`,", iCharLim);
						LDWINAddStrToQueWithControl(hQueWrite, "`FACKDATE`,`FACKTIME`,`ACKDATE`,`ACKTIME`,`UserId`,`Time_`,`Date_`,`BATCH`,`USERNAME`,`Critical`,`AckComment`,`TimeStr_`) VALUES ", iCharLim); !21206_41
//					END
				END
				!Estrai un record dalla coda e preparalo x la scrittura SQL
				QueRead(hmQueTaskAlmWrite, iValQue, sValQue, 0); !sValQue contiene l'handle alla coda contenente i dati del record
				hQue = StrToInt(sValQue);
				IF hQue <> -1 THEN
					IF iRecordWritten > 0 THEN!non è il primo elemento quindi devo inserire "," tra i due inserimenti
						LDWINAddStrToQueWithControl(hQueWrite, ",", iCharLim);
					END
					iErr = QueRead(hQue, iValQue, sValQue, 0); !sValQue contiene il testo da scrivere
					WHILE iErr = 0 DO !finchè la lettura va bene ci sono dei dati
						LDWINAddStrToQueWithControl(hQueWrite, sValQue, iCharLim);
						iErr = QueRead(hQue, iValQue, sValQue, 0); !sValQue contiene il testo da scrivere
					END
					!fine record
					QueClose(hQue);
					iRecordWritten = iRecordWritten + 1;
				END
				IF iRecordWritten = iMaxRecordToWrite THEN !scrivi su SQL
					bWriteToSQL = True;
				END
			ELSE !sleep solo se non ho più nulla da scrivere
				IF iRecordWritten > 0 THEN !la coda è vuota ma ho degli elementi da scrivere
					bWriteToSQL = True;
				ELSE
					SleepMS(iWaitMs);
				END
			END
			IF bWriteToSQL = True AND QueLength(hQueWrite) > 0 THEN
				!Scrittura su sql del contenuto di hQueWrite
				iErr = QueRead(hQueWrite, iValQue, sValQue, 0); !sValQue contiene il testo da scrivere
				SQLSet(hDB, sValQue);
				iErr = QueRead(hQueWrite, iValQue, sValQue, 0); !sValQue contiene il testo da scrivere
				WHILE iErr = 0 DO !finchè la lettura va bene ci sono dei dati
					SQLAppend(hDB, sValQue);
					iErr = QueRead(hQueWrite, iValQue, sValQue, 0); !sValQue contiene il testo da scrivere
				END
				SQLExec(hDB, "");
				SQLServerCloseConnection(iDb); !per evitare che il server mysql chiuda la connessione per inattività
				iRecordWritten = 0;
				bWriteToSQL = False;
			END
		ELSE
			SleepMS(iWaitMs);
		END
	END !While del task
	QueClose(hmQueTaskAlmWrite);
	QueClose(hQueWrite);
	!ErrLog("FINE TaskWriteAlarmToSQL");
	LDWINTaskEnd(95);
END

//#I
//Restituisce un elto del vettore  bmDspAlmGenieShow[.][.]
//IN: iR: riga
//    iC: Colonna
//#F
INT	 
FUNCTION Get_DspAlmGenieShow(INT iR, INT iC)
	IF iR > 0 THEN
		iR = iR + Get_igOffsetTesta(16);
	END
	RETURN bmDspAlmGenieShow[iR][iC] AND imAlmDspPage = 0;
END

//#I
//Restituisce un elto del vettore  bmDspAlmGenieDis[.][.]
//IN: iR: Riga
//    iC: Colonna
//#F
INT	 
FUNCTION Get_DspAlmGenieDis(INT iR, INT iC)
	IF iR > 0 THEN
		iR = iR + Get_igOffsetTesta(16);
	END
	RETURN bmDspAlmGenieDis[iR][iC];
END

//#I
//Restituisce un elto del vettore imDspAlmGenieColor[.][.]
//Codici colore:
//0 ciano per le scritte generiche
//1 rosso acceso
//2 rosso spento
//3 rosso lampeggiante
//4 giallo acceso
//5 giallo spento
//6 giallo lampeggiante
//7 blu acceso
//8 blu spento
//9 blu lampeggiante
//10 verde acceso
//11 verde spento
//
//IN: iR: Riga
//    iC: Colonna
//#F
INT	 
FUNCTION Get_DspAlmGenieColor(INT iR, INT iC)
	IF iR > 0 THEN
		iR = iR + Get_igOffsetTesta(16);
	END
	RETURN imDspAlmGenieColor[iR][iC];
END

//#I
//Restituisce un elto del vettore  imDspAlmGenieColor[.][.]
//IN: iR: Riga
//    iC: Colonna
//#F
STRING 
FUNCTION AlDp(INT iNumGenie, INT iCol)
	IF iNumGenie > 0 THEN
		iNumGenie = iNumGenie + Get_igOffsetTesta(16);
	END
	RETURN sltAlmActDsp[iNumGenie][iCol];
END

//#I
//
//#F
INT	 
FUNCTION AlmActDspOp(INT iNumGenie, INT iCol)
	SELECT CASE iCol
	CASE 5 !Fack
		Prompt("");
	CASE 6 !Ack
		IF iNumGenie > 0 THEN !il genie 0 è sempre l'intestazione
			Prompt("Test");
		END
	END SELECT
	!TODO: fillare con le operazioni
	RETURN 0;
END

//#I
//
//#F
FUNCTION TestShowActAlmMarix()
	INT	 iPos = 1;
	INT	 iCont;
	
	ErrLog("-----INIZIO stampa sltAlmActDsp-----");
	IF sltAlmActDsp[1][0] <> "" THEN !c'è almeno un elemento
		WHILE iPos <> -1 DO
			ErrLog(" Riga[" + IntToStr(iPos) + "]");
			FOR iCont = 0 TO 7 DO
				ErrLog("  Colonna [" + IntToStr(iCont) + "]|Colore=" + IntToStr(imDspAlmGenieColor[iPos][iCont]) + "| = " + sltAlmActDsp[iPos][iCont]);
			END
			IF iPos = 1001 THEN
				iPos = -1;
			ELSE
				IF sltAlmActDsp[iPos + 1][0] <> "" THEN !c'è l'elemento successivo
					iPos = iPos + 1;
				ELSE !nessun elemento valido
					iPos = -1; !fine ciclo
				END
			END
		END
	ELSE
		ErrLog("nessun elemento valido");
	END
	ErrLog("-----FINE stampa sltAlmActDsp-----");
END

//#I
//Imposta una colonna del genie almactdsp
//IN: iR, iC: coordinate di riga e colonna
//    sVal: valore da impostare per quella cella
//    iColor: Colore da impostare
//    bShow: visibilità della cella
//    bDis: disabilitazione della cella
//#F
FUNCTION GnAlmActDspSet(INT iR, INT iC, STRING sVal, INT iColor = 0, INT bShow = True, INT bDis = False)
	sltAlmActDsp[iR][iC] = sVal;
	imDspAlmGenieColor[iR][iC] = iColor;
	bmDspAlmGenieShow[iR][iC] = bShow;
	bmDspAlmGenieDis[iR][iC] = bDis;
END

//#I
//funzione che attiva/disattiva un allarme impostando il bit relativo ed il valore del sottomessaggio se serve
//impostatndo i valori direttamente nei buffer di copia è necessario che i task di copia siano stati fermati dalla funzione TestStopCopiaAlm
//N.B.
//l'attivazione di allarmi multimessaggio in recno diversi porteranno alla disattivazione dell'allarme precedente a causa del cambiamento del valore del multimessaggio
//gli allarmi multimessaggio del pacchetto 14 potrebbero non funzionare correttamente a causa della diversa gestione dei multimessaggi
//#F
FUNCTION TestAlmMoreSmart(INT iAdvAlmRecNo, INT bOn = True)
	INT	 iActBit = imAdvAlmBit[iAdvAlmRecNo];
	INT	 iMsgVal = imAdvAlmMsgVal[iAdvAlmRecNo];
	INT	 iCopyActPos = imCopiaAdvAlmPos[iAdvAlmRecNo];
	INT	 iCopyMsgPos = imCopiaAdvAlmMsgPos[iAdvAlmRecNo];
	INT	 bWriteMsg = False;
	INT	 iTimeoutSec = 5;
	INT	 iWaitMs = 500;
	INT	 iContTimeout = (1000/iWaitMs) * iTimeoutSec;
	INT	 iCont;
	INT	 bEnable;
	INT	 iNumTeste = LDWINIniGetIntValMem(lbCfgNumTeste);
	
	IF iAdvAlmRecNo > -1 AND iAdvAlmRecNo < imNumAdvAlm THEN
		IF TestStopCopiaAlm() = True THEN !per sicurezza sospendo sempre i task di copia
			IF iMsgVal = - 2 THEN !multitesta
				//iMsgVal = 57; !testa 57 -> essendo massimo 50 sappiamo che è un valore di debug
				iMsgVal = StrToInt(StrTrim(StrRight(stAlmDesc[iAdvAlmRecNo], 2)));
				bWriteMsg = True;
			ELSE
				IF iMsgVal <> -1 THEN !multimessaggio
					bWriteMsg = True;
				END
			END
			!attivazione multimessaggio
			IF bWriteMsg = True THEN
				!se è un multimessaggio, per far comparire il nuovo allarme bisogna anche disattivare il bit di attivazione e poi riattivarlo
				imCopiaAdvAlm[iCopyActPos] = SetBit(imCopiaAdvAlm[iCopyActPos], iActBit, False);
				iCont = 0;
				bEnable = True;
				WHILE bEnable = True DO
					IF GetCitectAlmActState(iAdvAlmRecNo) = False THEN !attendo che l'allarme sia spento
						bEnable = False;
					ELSE
						iCont = iCont + 1;
						IF iCont > iContTimeout THEN
							bEnable = False;
							iCont = 0;
							Message("TestAlmMoreSmart", sltAlmTagDev[iAdvAlmRecNo] + ": Timeout attesa disattivazione per valorizzazione multimessaggio", 0);
						END
						SleepMS(iWaitMs);
					END
				END
				!setto valore multimessaggio
				igCopiaAdvAlmMsg[iCopyMsgPos] = iMsgVal;
			END
			!attivazione allarme
			imCopiaAdvAlm[iCopyActPos] = SetBit(imCopiaAdvAlm[iCopyActPos], iActBit, bOn);
			iCont = 0;
			bEnable = True;
			WHILE bEnable = True DO
				IF GetCitectAlmActState(iAdvAlmRecNo) = bOn THEN !attendo che l'allarme vada nello stato richiesto da bOn
					bEnable = False;
				ELSE
					iCont = iCont + 1;
					IF iCont > iContTimeout THEN
						bEnable = False;
						iCont = 0;
						Message("TestAlmMoreSmart", sltAlmTagDev[iAdvAlmRecNo] + ": Timeout attesa cambio stato allarme", 0);
					END
					SleepMS(iWaitMs);
				END
			END
		ELSE
			Message("SQLAlarmTest - ERRORE", "Suspend task copia allarmi fallita", 16);
		END
	ELSE
		Message("TestAlmMoreSmart", "AdvAlmRecNo non valido", 16);
	END
END

//#I
//Task di servizio per la pagina AlmDsp
//#F
FUNCTION AlmDspTask()
	INT	 iNumAlmGenie = 0;
	INT	 iCont;
	INT	 iPagSelez;
	INT	 iPagMax;
	INT	 bInit = True;
	INT	 iAdvAlmRecNo;
	INT	 bFack = INIParamOn(lbCfgMyCriticalAlmDoubleAck);
	STRING sPag;
	STRING sDesc;
	
	bgLDWINTaskOn[96] = True;
	WHILE bgLDWINTaskOn[96] = True DO
		!Determina il # di oggetti
		iNumAlmGenie = 0;
		FOR iCont = 1 TO 1000 DO
			!FOR iCont = 1 TO imNumAdvAlm DO
			IF sltAlmActDsp[iCont][0] <> "" THEN
				IF bInit = True THEN
					iAdvAlmRecNo = hmDspAlmGenie2AdvAlmNumRec[iCont];
					!Traduzione del nome allarme
					sltAlmActDsp[iCont][4] = StrToLocalText(stAlmName[iAdvAlmRecNo]);
					!Descrizione allarme
					sDesc = stAlmDesc[iAdvAlmRecNo];
					IF StrLeft(sDesc, 1) = "{" THEN !è un multitesta che ha il comando GetAdvAlmMsg(RecNo) ma essendo stringa non possiamo eseguirlo dato che non abbiamo l'eval
						sDesc = GetAdvAlmMsg(iAdvAlmRecNo);
					END
					sltAlmActDsp[iCont][5] = StrToLocalText(sDesc);
					IF bFack = True THEN
						IF bmAlmServerAlmIsFAck[iAdvAlmRecNo] = True THEN
							sltAlmActDsp[iCont][6] = StrToLocalText(sgSiNoTrad[1]);
						END
					END
					sltAlmActDsp[iCont][7] = StrToLocalText(sgSiNoTrad[bmAlmServerAlmIsAck[iAdvAlmRecNo]]);
				END
				iNumAlmGenie = iNumAlmGenie + 1;
			END
		END
		TestPagDefGrp(16, lbNumAlmGeniePerPage, iNumAlmGenie, 0, 256, 257);
		sPag = "@(Allarmi Attivi)";
		iPagSelez = Get_igOffsetTesta(16)/lbNumAlmGeniePerPage;
		iPagSelez = iPagSelez + 1;
		iPagMax = GetMdlNumGrp(16);
		IF iPagMax > 1 THEN
			sPag = sPag + " " + IntToStr(iPagSelez) + "/" + IntToStr(iPagMax);
		END
		SetLDWINPageInfo(sPag);
		!ErrLog("AlmDspTaskTS" + IntToStr(hgLDWINTaskId[96]));
		bInit = False;
		TaskSuspend(hgLDWINTaskId[96]);
	END
	hgLDWINTaskId[96] = -1;
END

//#I
//
//#F
//FUNCTION GetCitectAlmInfo(INT iAlmRecNo)
//	INT iVal = 0; !Puntatore a record interno Citect
//	STRING sVal = "";
//	
//	IF iAlmRecNo > -1 AND iAlmRecNo < imNumAdvAlm THEN
//		sVal = sltAlmTagDev[iAlmRecNo];
//		iVal = AlarmFirstTagRec(sVal, "", "", "LDWIN");
//		sVal = AlarmGetFieldRec(iVal, "State");! restituisce il tipo di stato di attivazione-> "ON" o "OFF"
//		IF sVal = "OFF" THEN
//			bmAlmServerAlmIsOn[iAlmRecNo] = False;
//		ELSE
//			bmAlmServerAlmIsOn[iAlmRecNo] = True;
//		END
//		sVal = StrLeft(AlarmGetFieldRec(iVal, "Type"), 5);! restituisce il tipo di ack-> "UNACK" o "ACKNO"
//		IF sVal = "UNACK" THEN
//			bmAlmServerAlmIsAck[iAlmRecNo] = False;
//		ELSE
//			bmAlmServerAlmIsAck[iAlmRecNo] = True;
//		END
//	END
//END

//#I
//Stampa tutte le informazioni di un allarme hardware
//IN: iRec: # di record in advalm.dbf
//#F
FUNCTION PrintAlm(INT iRec)
	STRING sVal;
	IF iRec > -1 AND iRec < imNumAdvAlm THEN
		sVal = sltAlmTagDev[iRec];
		iRec = AlarmFirstTagRec(sVal, "", "", "LDWIN");
		ErrLog("---PRINT INFO ALM:");
		PrintAlmSingleInfo(iRec, "Desc");
		PrintAlmSingleInfo(iRec, "Name");
		PrintAlmSingleInfo(iRec, "Tag");
		PrintAlmSingleInfo(iRec, "Type");
		PrintAlmSingleInfo(iRec, "State");
		PrintAlmSingleInfo(iRec, "OnDate");
		PrintAlmSingleInfo(iRec, "OnTime");
		PrintAlmSingleInfo(iRec, "OffDate");
		PrintAlmSingleInfo(iRec, "OffTime");
		PrintAlmSingleInfo(iRec, "DeltaTime");
		PrintAlmSingleInfo(iRec, "AckDate");
		PrintAlmSingleInfo(iRec, "AckTime");
		PrintAlmSingleInfo(iRec, "UserName");
		PrintAlmSingleInfo(iRec, "Category");
		ErrLog("----------------------------------------");
	END
END

//#I
//Imposta le stringhe eventualmente tradotte (grazie Citect 7.5 e seguenti!) di stato ACK 21206_75
//#F
//FUNCTION SetAckStrings_new()
//	INT	 iLang;
//	INT	 hDev = -1;
//	INT	 bDefaultAck = False;
//	INT	 bDefaultNAck = False;
//	STRING sDBF = "";
//	
//	iLang = LDWINIniGetIntValMem(lbCfgHMISelLanguage);
//	sDBF = "D:\CitectData\User\Include\" + sgLangNomeDb[iLang] + ".dbf";
//	IF FileExist(sDBF) THEN
//		!ErrLog("Esiste");
//		DevModify("DevDummy", "*", "*", sDBF, dBASE_DEV);
//		hDev = DevOpen("DevDummy", 0);
//		IF hDev > -1 THEN
//			DevSeek(hDev, 0);
//			DevFind(hDev, "ACKNOWLEDGED", "NATIVE");
//			smAckStatus = DevGetField(hDev, "LOCAL");
//			IF smAckStatus = "" THEN
//				bDefaultAck = True;
//			END
//			DevSeek(hDev, 0);
//			DevFind(hDev, "UNACKNOWLEDGED", "NATIVE");
//			smUnackStatus = DevGetField(hDev, "LOCAL");
//			IF smUnackStatus = "" THEN
//				bDefaultNAck = True;
//			END
//			DevClose(hDev);
//		END
//	ELSE
//		bDefaultAck = True;
//		bDefaultNAck = True;
//	END
//	IF bDefaultACK = True THEN
//		smAckStatus = "ACKNOWLEDGED";
//	END
//	IF bDefaultNACK = True THEN
//		smUnackStatus = "UNACKNOWLEDGED";
//	END
//END

//FUNCTION SetAckStrings()
//	smAckStatus = StrToLocalText("@(ACKNOWLEDGED)");
//	smUnackStatus = StrToLocalText("@(UNACKNOWLEDGED)");
//END

//#I
//Esegue lo spegnimento del task AlmManage 21206_75
//IN: bOverrideCitectDelAlm: True: quando il task si disattiva, non cancellare la dir dati di Citect
//#F
FUNCTION QuitAlmManage(INT bOverrideCitectDelAlm = False)
	bmCitectAlmsDelOverride = bOverrideCitectDelAlm; !Se si cambia lingua, evita di cancellare la dir dei dati di Citct mentre va, cosa non gradita :-(
	SetLDWINTaskOn(76, False); !fai finire il task ProcDspLastAlarm
	SetLDWINTaskOff(13, 100);
	LDWINTaskOn(76);
END

//#I
//Esegue la sospensione del task AlmManage 21206_75
//OUT: -1 timeout
//#F
INT	 
FUNCTION SuspendAlmManage()
	INT	 iCont = 0;
	
	IF hgLDWINTaskId[13] > -1 THEN
		bmAlmManageSuspend = True;
		bgLDWINTaskIdResumed[13] = False;
		bgLDWINTaskIdEnResume[13]  = True;
		WHILE bmAlmManageSuspend = True DO
			ErrLog("Sospensione AlmManage in corso...");
			iCont = iCont + 1;
			IF iCont > 20 THEN
				ErrLog("SuspendAlmManage Timeout");
				RETURN -1;
			END
			SleepMS(200);
		END
		SleepMS(500);
	END
	RETURN 0;
END

//#I
//Aspetta il riavvio di AlmManage
//OUT: -1 timeout
//#F
INT	 
FUNCTION WaitAlmManageResume()
	INT	 iCont = 0;
	
	IF hgLDWINTaskId[13] > -1 THEN
		WHILE bgLDWINTaskIdResumed[13] = False DO
			ErrLog("RiavvioAlmManage in corso...");
			iCont = iCont + 1;
			IF iCont > 20 THEN
				ErrLog("WaitAlmManageResume Timeout");
				RETURN -1;
			END
			SleepMS(200);
		END
	END
	RETURN 0;
END


//#I
//Esegue il FAck di un singolo allarme
//OUT: 0:noErr
//#F
INT	 
FUNCTION SetCitectAlmFAckState(INT iAlmRecNo)
	INT	 bRet = False;
	
	IF iAlmRecNo > -1 AND iAlmRecNo < imNumAdvAlm THEN
		bRet = True;
		bmAlmServerAlmIsFAck[iAlmRecNo] = bRet;
		sltAlmActUserIdFACK[iAlmRecNo] = LDWINUserInfo(1);
	END
	RETURN bRet;
END

//#I
//Restituisce lo stato di ack di un singolo allarme
//OUT: 0:noAck
//     1:Ack
//#F
INT	 
FUNCTION GetCitectAlmFAckState(INT iAlmRecNo)
	INT	 iVal = False;
	
	//IF iAlmRecNo = 0 THEN
	//ErrLog("IrecNo 0");
	//END
	IF iAlmRecNo > -1 AND iAlmRecNo < imNumAdvAlm THEN
		RETURN bmAlmServerAlmIsFAck[iAlmRecNo];
	END
	RETURN iVal;
END

//#I
//
//#F
INT	 
FUNCTION ACKChkIfFACK(STRING sUserID, INT iAlmRecNo)
	INT	 bEnable = False;
	
	IF iAlmRecNo > -1 AND iAlmRecNo < imNumAdvAlm THEN
		IF bmFAckAdvAlm[iAlmRecNo] = True THEN
			IF bmAlmServerAlmIsFAck[iAlmRecNo] = True THEN
				IF VerificaBackdoorId(sUserID) = True OR bgPrivOn[8] THEN !se sono con backdoor/tecnico tutto fa brodo
					bEnable = True;
				ELSE
					IF sUserID <> sltAlmActUserIdFACK[iAlmRecNo] THEN
						bEnable =  True;
					END
				END
			END
		ELSE
			bEnable = True
		END
	END
	RETURN bEnable;
END

//#I
//Verifica che tutti gli allrmi critici siano ACKATI.
//Da usare per abilitare il reset degli allarmi
//IN: bOutForm: True: visualizza un form che avverte che il tal allarme critico non è AckAto
//OUT: True: tutti gli allarmi sono ACKati e quindi il reset può essere effettuato/consenso stabilito
//     2 Non consentito perchè c'è almeno un allarme critico non completamente ACKAto
//#F
INT	 
FUNCTION ChkAlmResetEnabling(INT bOutForm = True)
	INT	 iCont;
	INT	 bRet = False;
	INT	 iNumNoFACK = 0;
	!INT	 bVal = False;
	INT	 bFACK = INIParamOn(lbCfgMyCriticalAlmDoubleAck);
	STRING sDummy;
	!STRING sUserID = LDWINUserInfo(1);
	
	IF bFACK = True THEN
		FOR iCont = 0 TO imNumAdvAlm - 1 DO
			IF bmFAckAdvAlm[iCont] = True THEN
				IF GetCitectAlmAckState(iCont) = False THEN
					IF bOutForm = True THEN
						sDummy = DefAlmTag(hmAdvAlmNumRecTag[iCont]) + " @(Non Riconosciuto)";
						TaskNew("LDWINMessage", "^"@(Reset Allarmi)^", ^"@(Non Consentito): @(Allarme Critico) " + sDummy + "^"", 8);
						WrRptAT("@(Reset Allarmi)", "@(Non Consentito): " + sDummy);
					END
					RETURN 2;
				END
			END
		END
	END
	IF iNumNoFACK = 0 THEN
		bRet = True;
	END
	RETURN bRet;
END

//#I
//TODO: sostituire in AdvAlmAddRecord(.) e riprovare a importare una lista allarmi
//#F
STRING 
FUNCTION DefAlmTag(INT iAlmDevRecNo)
	RETURN "AL" + sConvert(iAlmDevRecNo);
END

//#I
//Dato il codice allarme BFG, restituisce la categoria. Wrapper per rendere alcuni array locali e rendere il task almmanage più veloce
//IN: iBGAlm: # allarme da lista allarmi
//#F
INT	 
FUNCTION BFGAlmGetCategoria(INT iBFGAlm)
	iBFGAlm = hmAdvAlmBFGCodeTag[iBFGAlm]; !Restituisce il RecNo
	RETURN imCategoriaAdvAlm[iBFGAlm];
END

//INT
//FUNCTION BFGAlmGetCategoria_old(INT iBFGAlm)
//   INT iDummy;
//   INT iRecNo;
//   
//   iRecNo = hmAdvAlmBFGCodeTag[iBFGAlm]; !Restituisce il RecNo
//	iDummy = imCategoriaAdvAlm[iRecNo];
//	RETURN iDummy;
//END

//#I
//Restituisce un elto del vettore imCategoriaAdvAlm[.]
//IN: iRecNo dell'advalm
//OUT: valore dell'elto
//#F
INT	 
FUNCTION GetCategoriaAdvAlm(INT iRecNo)
	RETURN imCategoriaAdvAlm[iRecNo];
END

//#I
//Restituisce un elto del vettore hmAdvAlmBFGCodeTag[.]
//IN: iBFGAlm: # allarme BFG
//OUT: RecNo dell'allarme
//#F
INT	 
FUNCTION GetAdvAlmBFGCodeTag(INT iBFGAlm)
	RETURN hmAdvAlmBFGCodeTag[iBFGAlm];
END

//#I
//Restituisce un elto del vettore hmAdvAlmNumRecTag[.]
//IN: iRecNo: RecNo dell'allarme
//OUT: Tag BFG in # dell'allarme
//#F
INT	 
FUNCTION GetAdvAlmNumRecTag(INT iRecNo)
	RETURN hmAdvAlmNumRecTag[iRecNo];
END

//#I
//Imposta il valore di un elto del vettore hmAdvAlmNumRecTag[.] (per uso test)
//IN: iRecNo: RecNo dell'allarme
//    iBfg: Allarme Bonfi da impostare
//#F
FUNCTION SetAdvAlmNumRecTag(INT iRecNo, INT iBfg)
	hmAdvAlmNumRecTag[iRecNo] = iBfg;
END

//#I
//Imposta il valore della var. imNumAdvAlm
//IN: iVal: valore da impostare
//#F
FUNCTION SetNumAdvAlm(INT iVal)
	imNumAdvAlm = iVal;
END

//#I
//Gestione del motivo di una modifica. in questa versione, l'esecuzione è bloccata finchè non viene immesso una stringa valida
//IN: sParName: AT provocato dalla modifica 21206_1
//#F
STRING 
FUNCTION AckGetCommento(STRING sTag, STRING sMotivo = "")
	INT	 bErrato = True;
	INT	 iNumMaxCar;
	STRING sDummy;
	STRING sOut;
	
	WHILE bErrato = True DO
		!iNumMaxCar = 15;
		!iNumMaxCar = 24;
		iNumMaxCar = LDWINIniGetIntValMem(lbCfgMyGiustAckAlm);
		IF iNumMaxCar > 0 THEN
			sDummy = FormKeyPad(0, sMotivo, "", 0, 2, iNumMaxCar, 2, 7, sTag + " @(Commento)");
			IF sDummy <> "" THEN
				smAlmAckComment = sDummy; !21206_41
				bErrato = False;
				sOut = " @(Commento): " + sDummy;
			END
		END
	END
	RETURN sOut;
END

//#I
//Wrapper per la funzionalità di doppio ACK 21206_1, per evitare timeout task bottoni
//#F
FUNCTION FnAckAll()
	STRING sMotivo = "";
	STRING sDummy = "";
	
	smAlmAckComment = "NA"; !21206_41
	LDWINSetDisBtn(152, True); !disabilitazione del pulsante (da gestire anche su reset allarmi)
	IF INIParamOn(lbCfgMyGiustAckAlm) = True THEN
		IF ChkAckCommentEnabling() = True THEN
			sMotivo = AckGetCommento("[@(Riconoscimento Tutti)]");
		END
	END
	IF SetALLCitectAlmAckState() = 0 THEN
		SleepMS(2000); !tempo di attesa perchè da eventi si è visto che pressioni multiple dell'ack entro i due secondi producono allarmi con ONDATE 0
		sDummy = "[@(OK)]";
	ELSE
		sDummy = "[@(Errore)]";
	END
	LDWINSetDisBtn(152, False);
	WrRptAT("@(Riconoscimento Tutti)", StrTrim(sDummy + " " + sMotivo));
END

//#I
//Determina se alla pressione del tasto ACK all è necessario il commento 21206_1
//E' necessario il commento quando a schermo è presente almeno un allarme CRITICO FACKTO
//#F
INT	 
FUNCTION ChkAckCommentEnabling()
	INT	 iCont;
	INT	 bRet = False;
	
	IF INIParamOn(lbCfgMyCriticalAlmDoubleAck) = True THEN !Se sono attivi gli allarmi critici, il commento fallo solo su quelli
		FOR iCont = 0 TO imNumAdvAlm - 1 DO
			IF bmFAckAdvAlm[iCont] = True THEN !se è critico e se ce n'è almeno uno FACKATO ma non ACKATO
				IF GetCitectAlmAckState(iCont) = False AND GetCitectAlmFAckState(iCont) = True THEN
					bRet = True;
				END
			END
		END
	ELSE
		bRet = True; !altrimeti fallo sempre (come era stato originariamente pensato)
	END
	RETURN bRet;
END

//#I
//Restituisce lo stato di attivazione agendo sulle ore di attivazione disattivazione perchè, grazie alla str...ata di tradurre le info dal serve al cambio
//lingua, succedono casini (grazie 7.5!!!)
//IN: sOnTime: Ora di attivazione
//    sOffTime: ora di disattivazione
//#F
INT	 
FUNCTION GetAlmOnByTime(STRING sOnTime, STRING sOffTime)
	IF sOnTime = "" THEN
		RETURN False;
	ELSE
		IF sOffTime = "" THEN
			RETURN True;
		ELSE
			RETURN False;
		END
	END
END

//#I
//
//#F
FUNCTION ByPassCalcStatusTask(INT iLDWINCustomerID)
	INT	 iByPassSt;
	INT	 iByPassStPrec = -1;
	
	LDWINDefTask(103, "ByPassCalcStatusTask", True);
	WHILE bgLDWINTaskOn[103] = True DO
		ByPassCalcStatus();
		IF iLDWINCustomerID = 25 THEN !Green Mountain
			iByPassSt = LDActiveIco();
			IF iByPassSt <> iByPassStPrec THEN
				iByPassStPrec = iByPassSt;
				imScrTemplSt[1] = iByPassSt;
				LDWINTaskResume(35);
			END
		END
		SleepMS(500);
	END
END

//#I
//Visualizza l'ora di LDWIN in formato HH:MM
//#F
STRING 
FUNCTION DspOra()
	RETURN smLDWINOra;
END

//#I
//Visualizza i minuti dell'ora di LDWIN
//#F
STRING 
FUNCTION DspMin()
	RETURN smLDWINMin;
END

//#I
//Visualizza l'ora di LDWIN in formato HH:MM
//#F
STRING 
FUNCTION DspOraMin()
	RETURN smLDWINOraMin;
END

//#I
//Wrapper di inizializzazione per mantenere di modula le varie stringhe temporali
//#F
FUNCTION LDWINTimeInit()
	STRING sDummy = CalcDataLDWIN();
	
	sgLDWINData = sDummy;
	CalcDataRawDataSQL();
	!smLDWINDataPrec   = sgLDWINData; !inizializzalo al valore della data di avvio x riconoscere il cambio di data
	smLDWINDataPrec   = sDummy; !inizializzalo al valore della data di avvio x riconoscere il cambio di data
	!sgLDWINDataEstesa = Date(9);
	sDummy = Time(1);
	!smLDWINOraMinSec  = Time(1);
	!smLDWINOraMin     = StrLeft(smLDWINOraMinSec, 5);
	smLDWINOraMinSec  = sDummy;
	smLDWINOraMin     = StrLeft(sDummy, 5);
END

//#I
//Visualizza l'ora e data di LDWIN
//#F
STRING 
FUNCTION DspDataLDWIN()
	RETURN smDspDataLDWIN;
END

//#I
//Determina visualizzazione data e ora di LDWIN
//#F
FUNCTION CalcDspDataLDWIN()
	smDspDataLDWIN = sgLDWINData + sgLDWINDataSpazi + smLDWINOraMin; !fmt anno a 4 cifre iso
END

//#I
//Restituisce ora:minuti:secondi di LDWIN
//OUT: valore in stringa
//#F
STRING 
FUNCTION DspOraMinSec()
	RETURN smLDWINOraMinSec;
END

//#I
//Restituisce data + " " + ora:minuti:secondi di LDWIN
//OUT: valore in stringa
//#F
STRING 
FUNCTION DspDataOraMinSec()
	RETURN sgLDWINData + " " + smLDWINOraMinSec;
END

//#I
//Set a value of an element of imCopiaAdvAlm[.] vector
//IN: iPos: array position
//    iVal: value to set
//#F
FUNCTION SetCopiaAdvAlm(INT iPos, INT iVal)
   imCopiaAdvAlm[iPos] = iVal;
END

//#I
//Get the value of an element of imCopiaAdvAlm[.] vector
//IN: iPos: array position
//OUT: vector element value
//#F
INT
FUNCTION GetCopiaAdvAlm(INT iPos)
   RETURN imCopiaAdvAlm[iPos];
END

//#I
//Sets a bit of a SPC alarm
//IN: iNumBit: bit # to activate
//    iSPCNumBank: alarm bank #
//    bVal: boolean value to set
//    iSPCAdvAlmSrcOffset: HMI SPC alarm offset
//#F
FUNCTION SPCAlmSet(INT iNumBit, INT iSPCNumBank, INT bVal, INT iSPCAdvAlmSrcOffset = GetAdvAlmSourceOffset(7))
	iSPCNumBank = iSPCAdvAlmSrcOffset + iSPCNumBank;
	imCopiaAdvAlm[iSPCNumBank] = SetBit(imCopiaAdvAlm[iSPCNumBank], iNumBit, bVal);
END

